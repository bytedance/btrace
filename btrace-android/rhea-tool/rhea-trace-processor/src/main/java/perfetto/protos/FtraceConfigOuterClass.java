// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: protos/perfetto/config/ftrace/ftrace_config.proto
// Protobuf Java Version: 4.29.3

package perfetto.protos;

public final class FtraceConfigOuterClass {
  private FtraceConfigOuterClass() {}
  static {
    com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
      com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
      /* major= */ 4,
      /* minor= */ 29,
      /* patch= */ 3,
      /* suffix= */ "",
      FtraceConfigOuterClass.class.getName());
  }
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }

  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistry registry) {
    registerAllExtensions(
        (com.google.protobuf.ExtensionRegistryLite) registry);
  }
  public interface FtraceConfigOrBuilder extends
      // @@protoc_insertion_point(interface_extends:perfetto.protos.FtraceConfig)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Ftrace events to record, example: "sched/sched_switch".
     * </pre>
     *
     * <code>repeated string ftrace_events = 1;</code>
     * @return A list containing the ftraceEvents.
     */
    java.util.List<java.lang.String>
        getFtraceEventsList();
    /**
     * <pre>
     * Ftrace events to record, example: "sched/sched_switch".
     * </pre>
     *
     * <code>repeated string ftrace_events = 1;</code>
     * @return The count of ftraceEvents.
     */
    int getFtraceEventsCount();
    /**
     * <pre>
     * Ftrace events to record, example: "sched/sched_switch".
     * </pre>
     *
     * <code>repeated string ftrace_events = 1;</code>
     * @param index The index of the element to return.
     * @return The ftraceEvents at the given index.
     */
    java.lang.String getFtraceEvents(int index);
    /**
     * <pre>
     * Ftrace events to record, example: "sched/sched_switch".
     * </pre>
     *
     * <code>repeated string ftrace_events = 1;</code>
     * @param index The index of the value to return.
     * @return The bytes of the ftraceEvents at the given index.
     */
    com.google.protobuf.ByteString
        getFtraceEventsBytes(int index);

    /**
     * <pre>
     * Android-specific event categories:
     * </pre>
     *
     * <code>repeated string atrace_categories = 2;</code>
     * @return A list containing the atraceCategories.
     */
    java.util.List<java.lang.String>
        getAtraceCategoriesList();
    /**
     * <pre>
     * Android-specific event categories:
     * </pre>
     *
     * <code>repeated string atrace_categories = 2;</code>
     * @return The count of atraceCategories.
     */
    int getAtraceCategoriesCount();
    /**
     * <pre>
     * Android-specific event categories:
     * </pre>
     *
     * <code>repeated string atrace_categories = 2;</code>
     * @param index The index of the element to return.
     * @return The atraceCategories at the given index.
     */
    java.lang.String getAtraceCategories(int index);
    /**
     * <pre>
     * Android-specific event categories:
     * </pre>
     *
     * <code>repeated string atrace_categories = 2;</code>
     * @param index The index of the value to return.
     * @return The bytes of the atraceCategories at the given index.
     */
    com.google.protobuf.ByteString
        getAtraceCategoriesBytes(int index);

    /**
     * <code>repeated string atrace_apps = 3;</code>
     * @return A list containing the atraceApps.
     */
    java.util.List<java.lang.String>
        getAtraceAppsList();
    /**
     * <code>repeated string atrace_apps = 3;</code>
     * @return The count of atraceApps.
     */
    int getAtraceAppsCount();
    /**
     * <code>repeated string atrace_apps = 3;</code>
     * @param index The index of the element to return.
     * @return The atraceApps at the given index.
     */
    java.lang.String getAtraceApps(int index);
    /**
     * <code>repeated string atrace_apps = 3;</code>
     * @param index The index of the value to return.
     * @return The bytes of the atraceApps at the given index.
     */
    com.google.protobuf.ByteString
        getAtraceAppsBytes(int index);

    /**
     * <pre>
     * Some processes can emit data through atrace or through the perfetto SDK via
     * the "track_event" data source. For these categories, the SDK will be
     * preferred, if possible, for this config.
     * </pre>
     *
     * <code>repeated string atrace_categories_prefer_sdk = 28;</code>
     * @return A list containing the atraceCategoriesPreferSdk.
     */
    java.util.List<java.lang.String>
        getAtraceCategoriesPreferSdkList();
    /**
     * <pre>
     * Some processes can emit data through atrace or through the perfetto SDK via
     * the "track_event" data source. For these categories, the SDK will be
     * preferred, if possible, for this config.
     * </pre>
     *
     * <code>repeated string atrace_categories_prefer_sdk = 28;</code>
     * @return The count of atraceCategoriesPreferSdk.
     */
    int getAtraceCategoriesPreferSdkCount();
    /**
     * <pre>
     * Some processes can emit data through atrace or through the perfetto SDK via
     * the "track_event" data source. For these categories, the SDK will be
     * preferred, if possible, for this config.
     * </pre>
     *
     * <code>repeated string atrace_categories_prefer_sdk = 28;</code>
     * @param index The index of the element to return.
     * @return The atraceCategoriesPreferSdk at the given index.
     */
    java.lang.String getAtraceCategoriesPreferSdk(int index);
    /**
     * <pre>
     * Some processes can emit data through atrace or through the perfetto SDK via
     * the "track_event" data source. For these categories, the SDK will be
     * preferred, if possible, for this config.
     * </pre>
     *
     * <code>repeated string atrace_categories_prefer_sdk = 28;</code>
     * @param index The index of the value to return.
     * @return The bytes of the atraceCategoriesPreferSdk at the given index.
     */
    com.google.protobuf.ByteString
        getAtraceCategoriesPreferSdkBytes(int index);

    /**
     * <pre>
     * Size of each per-cpu kernel ftrace ring buffer.
     * Not guaranteed if there are multiple concurrent tracing sessions, as the
     * buffers cannot be resized without pausing recording in the kernel.
     * </pre>
     *
     * <code>optional uint32 buffer_size_kb = 10;</code>
     * @return Whether the bufferSizeKb field is set.
     */
    boolean hasBufferSizeKb();
    /**
     * <pre>
     * Size of each per-cpu kernel ftrace ring buffer.
     * Not guaranteed if there are multiple concurrent tracing sessions, as the
     * buffers cannot be resized without pausing recording in the kernel.
     * </pre>
     *
     * <code>optional uint32 buffer_size_kb = 10;</code>
     * @return The bufferSizeKb.
     */
    int getBufferSizeKb();

    /**
     * <pre>
     * If set, specifies how often the tracing daemon reads from the kernel ring
     * buffer. Not guaranteed if there are multiple concurrent tracing sessions.
     * Leave unset unless you're fine-tuning a local config.
     * </pre>
     *
     * <code>optional uint32 drain_period_ms = 11;</code>
     * @return Whether the drainPeriodMs field is set.
     */
    boolean hasDrainPeriodMs();
    /**
     * <pre>
     * If set, specifies how often the tracing daemon reads from the kernel ring
     * buffer. Not guaranteed if there are multiple concurrent tracing sessions.
     * Leave unset unless you're fine-tuning a local config.
     * </pre>
     *
     * <code>optional uint32 drain_period_ms = 11;</code>
     * @return The drainPeriodMs.
     */
    int getDrainPeriodMs();

    /**
     * <pre>
     * If set, the tracing daemon will read kernel ring buffers as soon as
     * they're filled past this percentage of occupancy. In other words, a value
     * of 50 means that a read pass is triggered as soon as any per-cpu buffer is
     * half-full. Not guaranteed if there are multiple concurrent tracing
     * sessions.
     * Currently does nothing on Linux kernels below v6.9.
     * Introduced in: perfetto v48.
     * </pre>
     *
     * <code>optional uint32 drain_buffer_percent = 29;</code>
     * @return Whether the drainBufferPercent field is set.
     */
    boolean hasDrainBufferPercent();
    /**
     * <pre>
     * If set, the tracing daemon will read kernel ring buffers as soon as
     * they're filled past this percentage of occupancy. In other words, a value
     * of 50 means that a read pass is triggered as soon as any per-cpu buffer is
     * half-full. Not guaranteed if there are multiple concurrent tracing
     * sessions.
     * Currently does nothing on Linux kernels below v6.9.
     * Introduced in: perfetto v48.
     * </pre>
     *
     * <code>optional uint32 drain_buffer_percent = 29;</code>
     * @return The drainBufferPercent.
     */
    int getDrainBufferPercent();

    /**
     * <code>optional .perfetto.protos.FtraceConfig.CompactSchedConfig compact_sched = 12;</code>
     * @return Whether the compactSched field is set.
     */
    boolean hasCompactSched();
    /**
     * <code>optional .perfetto.protos.FtraceConfig.CompactSchedConfig compact_sched = 12;</code>
     * @return The compactSched.
     */
    perfetto.protos.FtraceConfigOuterClass.FtraceConfig.CompactSchedConfig getCompactSched();
    /**
     * <code>optional .perfetto.protos.FtraceConfig.CompactSchedConfig compact_sched = 12;</code>
     */
    perfetto.protos.FtraceConfigOuterClass.FtraceConfig.CompactSchedConfigOrBuilder getCompactSchedOrBuilder();

    /**
     * <code>optional .perfetto.protos.FtraceConfig.PrintFilter print_filter = 22;</code>
     * @return Whether the printFilter field is set.
     */
    boolean hasPrintFilter();
    /**
     * <code>optional .perfetto.protos.FtraceConfig.PrintFilter print_filter = 22;</code>
     * @return The printFilter.
     */
    perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter getPrintFilter();
    /**
     * <code>optional .perfetto.protos.FtraceConfig.PrintFilter print_filter = 22;</code>
     */
    perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilterOrBuilder getPrintFilterOrBuilder();

    /**
     * <pre>
     * Enables symbol name resolution against /proc/kallsyms.
     * It requires that either traced_probes is running as root or that
     * kptr_restrict has been manually lowered.
     * It does not disclose KASLR, symbol addresses are mangled.
     * </pre>
     *
     * <code>optional bool symbolize_ksyms = 13;</code>
     * @return Whether the symbolizeKsyms field is set.
     */
    boolean hasSymbolizeKsyms();
    /**
     * <pre>
     * Enables symbol name resolution against /proc/kallsyms.
     * It requires that either traced_probes is running as root or that
     * kptr_restrict has been manually lowered.
     * It does not disclose KASLR, symbol addresses are mangled.
     * </pre>
     *
     * <code>optional bool symbolize_ksyms = 13;</code>
     * @return The symbolizeKsyms.
     */
    boolean getSymbolizeKsyms();

    /**
     * <code>optional .perfetto.protos.FtraceConfig.KsymsMemPolicy ksyms_mem_policy = 17;</code>
     * @return Whether the ksymsMemPolicy field is set.
     */
    boolean hasKsymsMemPolicy();
    /**
     * <code>optional .perfetto.protos.FtraceConfig.KsymsMemPolicy ksyms_mem_policy = 17;</code>
     * @return The ksymsMemPolicy.
     */
    perfetto.protos.FtraceConfigOuterClass.FtraceConfig.KsymsMemPolicy getKsymsMemPolicy();

    /**
     * <pre>
     * By default the kernel symbolizer is lazily initialized on a deferred task
     * to reduce ftrace's time-to-start-recording. Unfortunately that makes
     * ksyms integration tests hard. This flag forces the kernel symbolizer to be
     * initialized synchronously on the data source start and hence avoiding
     * timing races in tests.
     * DEPRECATED in v28 / Android U. This is now the default behavior, setting it
     * to true is a no-op.
     * </pre>
     *
     * <code>optional bool initialize_ksyms_synchronously_for_testing = 14 [deprecated = true];</code>
     * @deprecated perfetto.protos.FtraceConfig.initialize_ksyms_synchronously_for_testing is deprecated.
     *     See protos/perfetto/config/ftrace/ftrace_config.proto;l=123
     * @return Whether the initializeKsymsSynchronouslyForTesting field is set.
     */
    @java.lang.Deprecated boolean hasInitializeKsymsSynchronouslyForTesting();
    /**
     * <pre>
     * By default the kernel symbolizer is lazily initialized on a deferred task
     * to reduce ftrace's time-to-start-recording. Unfortunately that makes
     * ksyms integration tests hard. This flag forces the kernel symbolizer to be
     * initialized synchronously on the data source start and hence avoiding
     * timing races in tests.
     * DEPRECATED in v28 / Android U. This is now the default behavior, setting it
     * to true is a no-op.
     * </pre>
     *
     * <code>optional bool initialize_ksyms_synchronously_for_testing = 14 [deprecated = true];</code>
     * @deprecated perfetto.protos.FtraceConfig.initialize_ksyms_synchronously_for_testing is deprecated.
     *     See protos/perfetto/config/ftrace/ftrace_config.proto;l=123
     * @return The initializeKsymsSynchronouslyForTesting.
     */
    @java.lang.Deprecated boolean getInitializeKsymsSynchronouslyForTesting();

    /**
     * <pre>
     * When this boolean is true AND the ftrace_events contains "kmem/rss_stat",
     * this option causes traced_probes to enable the "kmem/rss_stat_throttled"
     * event instead if present, and fall back to "kmem/rss_stat" if not present.
     * The historical context for this is the following:
     * - Up to Android S (12), the rss_stat was internally throttled in its
     * kernel implementation.
     * - A change introduced in the kernels after S has introduced a new
     * "rss_stat_throttled" making the original "rss_stat" event unthrottled
     * (hence very spammy).
     * - Not all Android T/13 devices will receive a new kernel though, hence we
     * need to deal with both cases.
     * For more context: go/rss-stat-throttled.
     * </pre>
     *
     * <code>optional bool throttle_rss_stat = 15;</code>
     * @return Whether the throttleRssStat field is set.
     */
    boolean hasThrottleRssStat();
    /**
     * <pre>
     * When this boolean is true AND the ftrace_events contains "kmem/rss_stat",
     * this option causes traced_probes to enable the "kmem/rss_stat_throttled"
     * event instead if present, and fall back to "kmem/rss_stat" if not present.
     * The historical context for this is the following:
     * - Up to Android S (12), the rss_stat was internally throttled in its
     * kernel implementation.
     * - A change introduced in the kernels after S has introduced a new
     * "rss_stat_throttled" making the original "rss_stat" event unthrottled
     * (hence very spammy).
     * - Not all Android T/13 devices will receive a new kernel though, hence we
     * need to deal with both cases.
     * For more context: go/rss-stat-throttled.
     * </pre>
     *
     * <code>optional bool throttle_rss_stat = 15;</code>
     * @return The throttleRssStat.
     */
    boolean getThrottleRssStat();

    /**
     * <pre>
     * If true, avoid enabling events that aren't statically known by
     * traced_probes. Otherwise, the default is to emit such events as
     * GenericFtraceEvent protos.
     * Prefer to keep this flag at its default. This was added for Android
     * tracing, where atrace categories and/or atrace HAL requested events can
     * expand to events that aren't of interest to the tracing user.
     * Introduced in: Android T.
     * </pre>
     *
     * <code>optional bool disable_generic_events = 16;</code>
     * @return Whether the disableGenericEvents field is set.
     */
    boolean hasDisableGenericEvents();
    /**
     * <pre>
     * If true, avoid enabling events that aren't statically known by
     * traced_probes. Otherwise, the default is to emit such events as
     * GenericFtraceEvent protos.
     * Prefer to keep this flag at its default. This was added for Android
     * tracing, where atrace categories and/or atrace HAL requested events can
     * expand to events that aren't of interest to the tracing user.
     * Introduced in: Android T.
     * </pre>
     *
     * <code>optional bool disable_generic_events = 16;</code>
     * @return The disableGenericEvents.
     */
    boolean getDisableGenericEvents();

    /**
     * <pre>
     * The subset of syscalls to record. To record all syscalls, leave this unset
     * and add "ftrace_events: raw_syscalls/sys_{enter,exit}" to the config.
     * * before perfetto v43, requires the config to also enable
     * raw_syscalls/sys_{enter,exit}.
     * * perfetto v43+ does the right thing if you set only this field.
     * Example: ["sys_read", "sys_open"].
     * Introduced in: Android U.
     * </pre>
     *
     * <code>repeated string syscall_events = 18;</code>
     * @return A list containing the syscallEvents.
     */
    java.util.List<java.lang.String>
        getSyscallEventsList();
    /**
     * <pre>
     * The subset of syscalls to record. To record all syscalls, leave this unset
     * and add "ftrace_events: raw_syscalls/sys_{enter,exit}" to the config.
     * * before perfetto v43, requires the config to also enable
     * raw_syscalls/sys_{enter,exit}.
     * * perfetto v43+ does the right thing if you set only this field.
     * Example: ["sys_read", "sys_open"].
     * Introduced in: Android U.
     * </pre>
     *
     * <code>repeated string syscall_events = 18;</code>
     * @return The count of syscallEvents.
     */
    int getSyscallEventsCount();
    /**
     * <pre>
     * The subset of syscalls to record. To record all syscalls, leave this unset
     * and add "ftrace_events: raw_syscalls/sys_{enter,exit}" to the config.
     * * before perfetto v43, requires the config to also enable
     * raw_syscalls/sys_{enter,exit}.
     * * perfetto v43+ does the right thing if you set only this field.
     * Example: ["sys_read", "sys_open"].
     * Introduced in: Android U.
     * </pre>
     *
     * <code>repeated string syscall_events = 18;</code>
     * @param index The index of the element to return.
     * @return The syscallEvents at the given index.
     */
    java.lang.String getSyscallEvents(int index);
    /**
     * <pre>
     * The subset of syscalls to record. To record all syscalls, leave this unset
     * and add "ftrace_events: raw_syscalls/sys_{enter,exit}" to the config.
     * * before perfetto v43, requires the config to also enable
     * raw_syscalls/sys_{enter,exit}.
     * * perfetto v43+ does the right thing if you set only this field.
     * Example: ["sys_read", "sys_open"].
     * Introduced in: Android U.
     * </pre>
     *
     * <code>repeated string syscall_events = 18;</code>
     * @param index The index of the value to return.
     * @return The bytes of the syscallEvents at the given index.
     */
    com.google.protobuf.ByteString
        getSyscallEventsBytes(int index);

    /**
     * <pre>
     * If true, enable the "function_graph" kernel tracer that emits events
     * whenever a kernel function is entered and exited
     * (funcgraph_entry/funcgraph_exit).
     * Notes on use:
     * * Requires |symbolize_ksyms| for function name resolution.
     * * Use |function_filters| or |function_graph_roots| to constrain the traced
     * set of functions, otherwise the event bandwidth will be too high for
     * practical use.
     * * The data source might be rejected if there is already a concurrent
     * ftrace data source that does not use function graph itself, as we do not
     * support switching kernel tracers mid-trace.
     * * Requires a kernel compiled with CONFIG_FUNCTION_GRAPH_TRACER. This is
     * enabled if "cat /sys/kernel/tracing/available_tracers" includes
     * "function_graph".
     * Android:
     * * Available only on debuggable builds.
     * * Introduced in: Android U.
     * </pre>
     *
     * <code>optional bool enable_function_graph = 19;</code>
     * @return Whether the enableFunctionGraph field is set.
     */
    boolean hasEnableFunctionGraph();
    /**
     * <pre>
     * If true, enable the "function_graph" kernel tracer that emits events
     * whenever a kernel function is entered and exited
     * (funcgraph_entry/funcgraph_exit).
     * Notes on use:
     * * Requires |symbolize_ksyms| for function name resolution.
     * * Use |function_filters| or |function_graph_roots| to constrain the traced
     * set of functions, otherwise the event bandwidth will be too high for
     * practical use.
     * * The data source might be rejected if there is already a concurrent
     * ftrace data source that does not use function graph itself, as we do not
     * support switching kernel tracers mid-trace.
     * * Requires a kernel compiled with CONFIG_FUNCTION_GRAPH_TRACER. This is
     * enabled if "cat /sys/kernel/tracing/available_tracers" includes
     * "function_graph".
     * Android:
     * * Available only on debuggable builds.
     * * Introduced in: Android U.
     * </pre>
     *
     * <code>optional bool enable_function_graph = 19;</code>
     * @return The enableFunctionGraph.
     */
    boolean getEnableFunctionGraph();

    /**
     * <pre>
     * Constrains the set of functions traced when |enable_function_graph| is
     * true. Supports globs, e.g. "sched*". You can specify multiple filters,
     * in which case all matching functions will be traced. See kernel
     * documentation on ftrace "set_ftrace_filter" file for more details.
     * Android:
     * * Available only on debuggable builds.
     * * Introduced in: Android U.
     * </pre>
     *
     * <code>repeated string function_filters = 20;</code>
     * @return A list containing the functionFilters.
     */
    java.util.List<java.lang.String>
        getFunctionFiltersList();
    /**
     * <pre>
     * Constrains the set of functions traced when |enable_function_graph| is
     * true. Supports globs, e.g. "sched*". You can specify multiple filters,
     * in which case all matching functions will be traced. See kernel
     * documentation on ftrace "set_ftrace_filter" file for more details.
     * Android:
     * * Available only on debuggable builds.
     * * Introduced in: Android U.
     * </pre>
     *
     * <code>repeated string function_filters = 20;</code>
     * @return The count of functionFilters.
     */
    int getFunctionFiltersCount();
    /**
     * <pre>
     * Constrains the set of functions traced when |enable_function_graph| is
     * true. Supports globs, e.g. "sched*". You can specify multiple filters,
     * in which case all matching functions will be traced. See kernel
     * documentation on ftrace "set_ftrace_filter" file for more details.
     * Android:
     * * Available only on debuggable builds.
     * * Introduced in: Android U.
     * </pre>
     *
     * <code>repeated string function_filters = 20;</code>
     * @param index The index of the element to return.
     * @return The functionFilters at the given index.
     */
    java.lang.String getFunctionFilters(int index);
    /**
     * <pre>
     * Constrains the set of functions traced when |enable_function_graph| is
     * true. Supports globs, e.g. "sched*". You can specify multiple filters,
     * in which case all matching functions will be traced. See kernel
     * documentation on ftrace "set_ftrace_filter" file for more details.
     * Android:
     * * Available only on debuggable builds.
     * * Introduced in: Android U.
     * </pre>
     *
     * <code>repeated string function_filters = 20;</code>
     * @param index The index of the value to return.
     * @return The bytes of the functionFilters at the given index.
     */
    com.google.protobuf.ByteString
        getFunctionFiltersBytes(int index);

    /**
     * <pre>
     * If |enable_function_graph| is true, trace this set of functions *and* all
     * of its callees. Supports globs. Can be set together with
     * |function_filters|, in which case only callees matching the filter will be
     * traced. If setting both, you most likely want all roots to also be
     * included in |function_filters|.
     * Android:
     * * Available only on debuggable builds.
     * * Introduced in: Android U.
     * </pre>
     *
     * <code>repeated string function_graph_roots = 21;</code>
     * @return A list containing the functionGraphRoots.
     */
    java.util.List<java.lang.String>
        getFunctionGraphRootsList();
    /**
     * <pre>
     * If |enable_function_graph| is true, trace this set of functions *and* all
     * of its callees. Supports globs. Can be set together with
     * |function_filters|, in which case only callees matching the filter will be
     * traced. If setting both, you most likely want all roots to also be
     * included in |function_filters|.
     * Android:
     * * Available only on debuggable builds.
     * * Introduced in: Android U.
     * </pre>
     *
     * <code>repeated string function_graph_roots = 21;</code>
     * @return The count of functionGraphRoots.
     */
    int getFunctionGraphRootsCount();
    /**
     * <pre>
     * If |enable_function_graph| is true, trace this set of functions *and* all
     * of its callees. Supports globs. Can be set together with
     * |function_filters|, in which case only callees matching the filter will be
     * traced. If setting both, you most likely want all roots to also be
     * included in |function_filters|.
     * Android:
     * * Available only on debuggable builds.
     * * Introduced in: Android U.
     * </pre>
     *
     * <code>repeated string function_graph_roots = 21;</code>
     * @param index The index of the element to return.
     * @return The functionGraphRoots at the given index.
     */
    java.lang.String getFunctionGraphRoots(int index);
    /**
     * <pre>
     * If |enable_function_graph| is true, trace this set of functions *and* all
     * of its callees. Supports globs. Can be set together with
     * |function_filters|, in which case only callees matching the filter will be
     * traced. If setting both, you most likely want all roots to also be
     * included in |function_filters|.
     * Android:
     * * Available only on debuggable builds.
     * * Introduced in: Android U.
     * </pre>
     *
     * <code>repeated string function_graph_roots = 21;</code>
     * @param index The index of the value to return.
     * @return The bytes of the functionGraphRoots at the given index.
     */
    com.google.protobuf.ByteString
        getFunctionGraphRootsBytes(int index);

    /**
     * <pre>
     * If true, does not clear ftrace buffers before the start of the program.
     * This makes sense only if this is the first ftrace data source instance
     * created after the daemon has been started. Can be useful for gathering boot
     * traces, if ftrace has been separately configured (e.g. via kernel
     * commandline).
     * </pre>
     *
     * <code>optional bool preserve_ftrace_buffer = 23;</code>
     * @return Whether the preserveFtraceBuffer field is set.
     */
    boolean hasPreserveFtraceBuffer();
    /**
     * <pre>
     * If true, does not clear ftrace buffers before the start of the program.
     * This makes sense only if this is the first ftrace data source instance
     * created after the daemon has been started. Can be useful for gathering boot
     * traces, if ftrace has been separately configured (e.g. via kernel
     * commandline).
     * </pre>
     *
     * <code>optional bool preserve_ftrace_buffer = 23;</code>
     * @return The preserveFtraceBuffer.
     */
    boolean getPreserveFtraceBuffer();

    /**
     * <pre>
     * If true, overrides the default timestamp clock and uses a raw hardware
     * based monotonic clock for getting timestamps.
     * * Introduced in: Android U.
     * </pre>
     *
     * <code>optional bool use_monotonic_raw_clock = 24;</code>
     * @return Whether the useMonotonicRawClock field is set.
     */
    boolean hasUseMonotonicRawClock();
    /**
     * <pre>
     * If true, overrides the default timestamp clock and uses a raw hardware
     * based monotonic clock for getting timestamps.
     * * Introduced in: Android U.
     * </pre>
     *
     * <code>optional bool use_monotonic_raw_clock = 24;</code>
     * @return The useMonotonicRawClock.
     */
    boolean getUseMonotonicRawClock();

    /**
     * <pre>
     * If |instance_name| is not empty, then attempt to use that tracefs instance
     * for event recording. Normally, this means
     * `/sys/kernel/tracing/instances/$instance_name`.
     *
     * The name "hyp" is reserved.
     *
     * The instance must already exist, the tracing daemon *will not* create it
     * for you as it typically doesn't have such permissions.
     * Only a subset of features is guaranteed to work with non-default instances,
     * at the time of writing:
     * * ftrace_events
     * * buffer_size_kb
     * </pre>
     *
     * <code>optional string instance_name = 25;</code>
     * @return Whether the instanceName field is set.
     */
    boolean hasInstanceName();
    /**
     * <pre>
     * If |instance_name| is not empty, then attempt to use that tracefs instance
     * for event recording. Normally, this means
     * `/sys/kernel/tracing/instances/$instance_name`.
     *
     * The name "hyp" is reserved.
     *
     * The instance must already exist, the tracing daemon *will not* create it
     * for you as it typically doesn't have such permissions.
     * Only a subset of features is guaranteed to work with non-default instances,
     * at the time of writing:
     * * ftrace_events
     * * buffer_size_kb
     * </pre>
     *
     * <code>optional string instance_name = 25;</code>
     * @return The instanceName.
     */
    java.lang.String getInstanceName();
    /**
     * <pre>
     * If |instance_name| is not empty, then attempt to use that tracefs instance
     * for event recording. Normally, this means
     * `/sys/kernel/tracing/instances/$instance_name`.
     *
     * The name "hyp" is reserved.
     *
     * The instance must already exist, the tracing daemon *will not* create it
     * for you as it typically doesn't have such permissions.
     * Only a subset of features is guaranteed to work with non-default instances,
     * at the time of writing:
     * * ftrace_events
     * * buffer_size_kb
     * </pre>
     *
     * <code>optional string instance_name = 25;</code>
     * @return The bytes for instanceName.
     */
    com.google.protobuf.ByteString
        getInstanceNameBytes();

    /**
     * <pre>
     * If true, |buffer_size_kb| is interpreted as a lower bound, allowing the
     * implementation to choose a bigger buffer size.
     *
     * Most configs for perfetto v43+ should simply leave both fields unset.
     *
     * If you need a config compatible with a range of perfetto builds and you
     * used to set a non-default buffer_size_kb, consider setting both fields.
     * Example:
     * buffer_size_kb: 4096
     * buffer_size_lower_bound: true
     * On older builds, the per-cpu buffers will be exactly 4 MB.
     * On v43+, buffers will be at least 4 MB.
     * In both cases, neither is guaranteed if there are other concurrent
     * perfetto ftrace sessions, as the buffers cannot be resized without pausing
     * the recording in the kernel.
     * Introduced in: perfetto v43.
     * </pre>
     *
     * <code>optional bool buffer_size_lower_bound = 27;</code>
     * @return Whether the bufferSizeLowerBound field is set.
     */
    boolean hasBufferSizeLowerBound();
    /**
     * <pre>
     * If true, |buffer_size_kb| is interpreted as a lower bound, allowing the
     * implementation to choose a bigger buffer size.
     *
     * Most configs for perfetto v43+ should simply leave both fields unset.
     *
     * If you need a config compatible with a range of perfetto builds and you
     * used to set a non-default buffer_size_kb, consider setting both fields.
     * Example:
     * buffer_size_kb: 4096
     * buffer_size_lower_bound: true
     * On older builds, the per-cpu buffers will be exactly 4 MB.
     * On v43+, buffers will be at least 4 MB.
     * In both cases, neither is guaranteed if there are other concurrent
     * perfetto ftrace sessions, as the buffers cannot be resized without pausing
     * the recording in the kernel.
     * Introduced in: perfetto v43.
     * </pre>
     *
     * <code>optional bool buffer_size_lower_bound = 27;</code>
     * @return The bufferSizeLowerBound.
     */
    boolean getBufferSizeLowerBound();
  }
  /**
   * <pre>
   * Next id: 30
   * </pre>
   *
   * Protobuf type {@code perfetto.protos.FtraceConfig}
   */
  public static final class FtraceConfig extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:perfetto.protos.FtraceConfig)
      FtraceConfigOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 29,
        /* patch= */ 3,
        /* suffix= */ "",
        FtraceConfig.class.getName());
    }
    // Use FtraceConfig.newBuilder() to construct.
    private FtraceConfig(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private FtraceConfig() {
      ftraceEvents_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
      atraceCategories_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
      atraceApps_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
      atraceCategoriesPreferSdk_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
      ksymsMemPolicy_ = 0;
      syscallEvents_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
      functionFilters_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
      functionGraphRoots_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
      instanceName_ = "";
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return perfetto.protos.FtraceConfigOuterClass.internal_static_perfetto_protos_FtraceConfig_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return perfetto.protos.FtraceConfigOuterClass.internal_static_perfetto_protos_FtraceConfig_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              perfetto.protos.FtraceConfigOuterClass.FtraceConfig.class, perfetto.protos.FtraceConfigOuterClass.FtraceConfig.Builder.class);
    }

    /**
     * <pre>
     * When symbolize_ksyms=true, determines whether the traced_probes daemon
     * should keep the symbol map in memory (and reuse it for future tracing
     * sessions) or clear it (saving memory) and re-create it on each tracing
     * session (wasting cpu and wall time).
     * The tradeoff is roughly:
     * KSYMS_RETAIN: pay a fixed ~1.2 MB cost after the first trace.
     * KSYMS_CLEANUP_ON_STOP: pay a ~300-500ms cost when starting each trace.
     * Default behavior: KSYMS_CLEANUP_ON_STOP.
     * </pre>
     *
     * Protobuf enum {@code perfetto.protos.FtraceConfig.KsymsMemPolicy}
     */
    public enum KsymsMemPolicy
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <code>KSYMS_UNSPECIFIED = 0;</code>
       */
      KSYMS_UNSPECIFIED(0),
      /**
       * <code>KSYMS_CLEANUP_ON_STOP = 1;</code>
       */
      KSYMS_CLEANUP_ON_STOP(1),
      /**
       * <code>KSYMS_RETAIN = 2;</code>
       */
      KSYMS_RETAIN(2),
      ;

      static {
        com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
          com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
          /* major= */ 4,
          /* minor= */ 29,
          /* patch= */ 3,
          /* suffix= */ "",
          KsymsMemPolicy.class.getName());
      }
      /**
       * <code>KSYMS_UNSPECIFIED = 0;</code>
       */
      public static final int KSYMS_UNSPECIFIED_VALUE = 0;
      /**
       * <code>KSYMS_CLEANUP_ON_STOP = 1;</code>
       */
      public static final int KSYMS_CLEANUP_ON_STOP_VALUE = 1;
      /**
       * <code>KSYMS_RETAIN = 2;</code>
       */
      public static final int KSYMS_RETAIN_VALUE = 2;


      public final int getNumber() {
        return value;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static KsymsMemPolicy valueOf(int value) {
        return forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       */
      public static KsymsMemPolicy forNumber(int value) {
        switch (value) {
          case 0: return KSYMS_UNSPECIFIED;
          case 1: return KSYMS_CLEANUP_ON_STOP;
          case 2: return KSYMS_RETAIN;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<KsymsMemPolicy>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          KsymsMemPolicy> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<KsymsMemPolicy>() {
              public KsymsMemPolicy findValueByNumber(int number) {
                return KsymsMemPolicy.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return perfetto.protos.FtraceConfigOuterClass.FtraceConfig.getDescriptor().getEnumTypes().get(0);
      }

      private static final KsymsMemPolicy[] VALUES = values();

      public static KsymsMemPolicy valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private KsymsMemPolicy(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:perfetto.protos.FtraceConfig.KsymsMemPolicy)
    }

    public interface CompactSchedConfigOrBuilder extends
        // @@protoc_insertion_point(interface_extends:perfetto.protos.FtraceConfig.CompactSchedConfig)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <pre>
       * If true, and sched_switch or sched_waking ftrace events are enabled,
       * record those events in the compact format.
       *
       * If the field is unset, the default is:
       * * perfetto v42.0+: enabled
       * * before: disabled
       * </pre>
       *
       * <code>optional bool enabled = 1;</code>
       * @return Whether the enabled field is set.
       */
      boolean hasEnabled();
      /**
       * <pre>
       * If true, and sched_switch or sched_waking ftrace events are enabled,
       * record those events in the compact format.
       *
       * If the field is unset, the default is:
       * * perfetto v42.0+: enabled
       * * before: disabled
       * </pre>
       *
       * <code>optional bool enabled = 1;</code>
       * @return The enabled.
       */
      boolean getEnabled();
    }
    /**
     * <pre>
     * Configuration for compact encoding of scheduler events. When enabled (and
     * recording the relevant ftrace events), specific high-volume events are
     * encoded in a denser format than normal.
     * </pre>
     *
     * Protobuf type {@code perfetto.protos.FtraceConfig.CompactSchedConfig}
     */
    public static final class CompactSchedConfig extends
        com.google.protobuf.GeneratedMessage implements
        // @@protoc_insertion_point(message_implements:perfetto.protos.FtraceConfig.CompactSchedConfig)
        CompactSchedConfigOrBuilder {
    private static final long serialVersionUID = 0L;
      static {
        com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
          com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
          /* major= */ 4,
          /* minor= */ 29,
          /* patch= */ 3,
          /* suffix= */ "",
          CompactSchedConfig.class.getName());
      }
      // Use CompactSchedConfig.newBuilder() to construct.
      private CompactSchedConfig(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
        super(builder);
      }
      private CompactSchedConfig() {
      }

      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return perfetto.protos.FtraceConfigOuterClass.internal_static_perfetto_protos_FtraceConfig_CompactSchedConfig_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return perfetto.protos.FtraceConfigOuterClass.internal_static_perfetto_protos_FtraceConfig_CompactSchedConfig_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                perfetto.protos.FtraceConfigOuterClass.FtraceConfig.CompactSchedConfig.class, perfetto.protos.FtraceConfigOuterClass.FtraceConfig.CompactSchedConfig.Builder.class);
      }

      private int bitField0_;
      public static final int ENABLED_FIELD_NUMBER = 1;
      private boolean enabled_ = false;
      /**
       * <pre>
       * If true, and sched_switch or sched_waking ftrace events are enabled,
       * record those events in the compact format.
       *
       * If the field is unset, the default is:
       * * perfetto v42.0+: enabled
       * * before: disabled
       * </pre>
       *
       * <code>optional bool enabled = 1;</code>
       * @return Whether the enabled field is set.
       */
      @java.lang.Override
      public boolean hasEnabled() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * If true, and sched_switch or sched_waking ftrace events are enabled,
       * record those events in the compact format.
       *
       * If the field is unset, the default is:
       * * perfetto v42.0+: enabled
       * * before: disabled
       * </pre>
       *
       * <code>optional bool enabled = 1;</code>
       * @return The enabled.
       */
      @java.lang.Override
      public boolean getEnabled() {
        return enabled_;
      }

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        if (((bitField0_ & 0x00000001) != 0)) {
          output.writeBool(1, enabled_);
        }
        getUnknownFields().writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (((bitField0_ & 0x00000001) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeBoolSize(1, enabled_);
        }
        size += getUnknownFields().getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof perfetto.protos.FtraceConfigOuterClass.FtraceConfig.CompactSchedConfig)) {
          return super.equals(obj);
        }
        perfetto.protos.FtraceConfigOuterClass.FtraceConfig.CompactSchedConfig other = (perfetto.protos.FtraceConfigOuterClass.FtraceConfig.CompactSchedConfig) obj;

        if (hasEnabled() != other.hasEnabled()) return false;
        if (hasEnabled()) {
          if (getEnabled()
              != other.getEnabled()) return false;
        }
        if (!getUnknownFields().equals(other.getUnknownFields())) return false;
        return true;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        if (hasEnabled()) {
          hash = (37 * hash) + ENABLED_FIELD_NUMBER;
          hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
              getEnabled());
        }
        hash = (29 * hash) + getUnknownFields().hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static perfetto.protos.FtraceConfigOuterClass.FtraceConfig.CompactSchedConfig parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static perfetto.protos.FtraceConfigOuterClass.FtraceConfig.CompactSchedConfig parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static perfetto.protos.FtraceConfigOuterClass.FtraceConfig.CompactSchedConfig parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static perfetto.protos.FtraceConfigOuterClass.FtraceConfig.CompactSchedConfig parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static perfetto.protos.FtraceConfigOuterClass.FtraceConfig.CompactSchedConfig parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static perfetto.protos.FtraceConfigOuterClass.FtraceConfig.CompactSchedConfig parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static perfetto.protos.FtraceConfigOuterClass.FtraceConfig.CompactSchedConfig parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input);
      }
      public static perfetto.protos.FtraceConfigOuterClass.FtraceConfig.CompactSchedConfig parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      public static perfetto.protos.FtraceConfigOuterClass.FtraceConfig.CompactSchedConfig parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseDelimitedWithIOException(PARSER, input);
      }

      public static perfetto.protos.FtraceConfigOuterClass.FtraceConfig.CompactSchedConfig parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static perfetto.protos.FtraceConfigOuterClass.FtraceConfig.CompactSchedConfig parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input);
      }
      public static perfetto.protos.FtraceConfigOuterClass.FtraceConfig.CompactSchedConfig parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(perfetto.protos.FtraceConfigOuterClass.FtraceConfig.CompactSchedConfig prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * <pre>
       * Configuration for compact encoding of scheduler events. When enabled (and
       * recording the relevant ftrace events), specific high-volume events are
       * encoded in a denser format than normal.
       * </pre>
       *
       * Protobuf type {@code perfetto.protos.FtraceConfig.CompactSchedConfig}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessage.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:perfetto.protos.FtraceConfig.CompactSchedConfig)
          perfetto.protos.FtraceConfigOuterClass.FtraceConfig.CompactSchedConfigOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return perfetto.protos.FtraceConfigOuterClass.internal_static_perfetto_protos_FtraceConfig_CompactSchedConfig_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return perfetto.protos.FtraceConfigOuterClass.internal_static_perfetto_protos_FtraceConfig_CompactSchedConfig_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  perfetto.protos.FtraceConfigOuterClass.FtraceConfig.CompactSchedConfig.class, perfetto.protos.FtraceConfigOuterClass.FtraceConfig.CompactSchedConfig.Builder.class);
        }

        // Construct using perfetto.protos.FtraceConfigOuterClass.FtraceConfig.CompactSchedConfig.newBuilder()
        private Builder() {

        }

        private Builder(
            com.google.protobuf.GeneratedMessage.BuilderParent parent) {
          super(parent);

        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          bitField0_ = 0;
          enabled_ = false;
          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return perfetto.protos.FtraceConfigOuterClass.internal_static_perfetto_protos_FtraceConfig_CompactSchedConfig_descriptor;
        }

        @java.lang.Override
        public perfetto.protos.FtraceConfigOuterClass.FtraceConfig.CompactSchedConfig getDefaultInstanceForType() {
          return perfetto.protos.FtraceConfigOuterClass.FtraceConfig.CompactSchedConfig.getDefaultInstance();
        }

        @java.lang.Override
        public perfetto.protos.FtraceConfigOuterClass.FtraceConfig.CompactSchedConfig build() {
          perfetto.protos.FtraceConfigOuterClass.FtraceConfig.CompactSchedConfig result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public perfetto.protos.FtraceConfigOuterClass.FtraceConfig.CompactSchedConfig buildPartial() {
          perfetto.protos.FtraceConfigOuterClass.FtraceConfig.CompactSchedConfig result = new perfetto.protos.FtraceConfigOuterClass.FtraceConfig.CompactSchedConfig(this);
          if (bitField0_ != 0) { buildPartial0(result); }
          onBuilt();
          return result;
        }

        private void buildPartial0(perfetto.protos.FtraceConfigOuterClass.FtraceConfig.CompactSchedConfig result) {
          int from_bitField0_ = bitField0_;
          int to_bitField0_ = 0;
          if (((from_bitField0_ & 0x00000001) != 0)) {
            result.enabled_ = enabled_;
            to_bitField0_ |= 0x00000001;
          }
          result.bitField0_ |= to_bitField0_;
        }

        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof perfetto.protos.FtraceConfigOuterClass.FtraceConfig.CompactSchedConfig) {
            return mergeFrom((perfetto.protos.FtraceConfigOuterClass.FtraceConfig.CompactSchedConfig)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(perfetto.protos.FtraceConfigOuterClass.FtraceConfig.CompactSchedConfig other) {
          if (other == perfetto.protos.FtraceConfigOuterClass.FtraceConfig.CompactSchedConfig.getDefaultInstance()) return this;
          if (other.hasEnabled()) {
            setEnabled(other.getEnabled());
          }
          this.mergeUnknownFields(other.getUnknownFields());
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          if (extensionRegistry == null) {
            throw new java.lang.NullPointerException();
          }
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                case 8: {
                  enabled_ = input.readBool();
                  bitField0_ |= 0x00000001;
                  break;
                } // case 8
                default: {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
              } // switch (tag)
            } // while (!done)
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.unwrapIOException();
          } finally {
            onChanged();
          } // finally
          return this;
        }
        private int bitField0_;

        private boolean enabled_ ;
        /**
         * <pre>
         * If true, and sched_switch or sched_waking ftrace events are enabled,
         * record those events in the compact format.
         *
         * If the field is unset, the default is:
         * * perfetto v42.0+: enabled
         * * before: disabled
         * </pre>
         *
         * <code>optional bool enabled = 1;</code>
         * @return Whether the enabled field is set.
         */
        @java.lang.Override
        public boolean hasEnabled() {
          return ((bitField0_ & 0x00000001) != 0);
        }
        /**
         * <pre>
         * If true, and sched_switch or sched_waking ftrace events are enabled,
         * record those events in the compact format.
         *
         * If the field is unset, the default is:
         * * perfetto v42.0+: enabled
         * * before: disabled
         * </pre>
         *
         * <code>optional bool enabled = 1;</code>
         * @return The enabled.
         */
        @java.lang.Override
        public boolean getEnabled() {
          return enabled_;
        }
        /**
         * <pre>
         * If true, and sched_switch or sched_waking ftrace events are enabled,
         * record those events in the compact format.
         *
         * If the field is unset, the default is:
         * * perfetto v42.0+: enabled
         * * before: disabled
         * </pre>
         *
         * <code>optional bool enabled = 1;</code>
         * @param value The enabled to set.
         * @return This builder for chaining.
         */
        public Builder setEnabled(boolean value) {

          enabled_ = value;
          bitField0_ |= 0x00000001;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * If true, and sched_switch or sched_waking ftrace events are enabled,
         * record those events in the compact format.
         *
         * If the field is unset, the default is:
         * * perfetto v42.0+: enabled
         * * before: disabled
         * </pre>
         *
         * <code>optional bool enabled = 1;</code>
         * @return This builder for chaining.
         */
        public Builder clearEnabled() {
          bitField0_ = (bitField0_ & ~0x00000001);
          enabled_ = false;
          onChanged();
          return this;
        }

        // @@protoc_insertion_point(builder_scope:perfetto.protos.FtraceConfig.CompactSchedConfig)
      }

      // @@protoc_insertion_point(class_scope:perfetto.protos.FtraceConfig.CompactSchedConfig)
      private static final perfetto.protos.FtraceConfigOuterClass.FtraceConfig.CompactSchedConfig DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new perfetto.protos.FtraceConfigOuterClass.FtraceConfig.CompactSchedConfig();
      }

      public static perfetto.protos.FtraceConfigOuterClass.FtraceConfig.CompactSchedConfig getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final com.google.protobuf.Parser<CompactSchedConfig>
          PARSER = new com.google.protobuf.AbstractParser<CompactSchedConfig>() {
        @java.lang.Override
        public CompactSchedConfig parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          Builder builder = newBuilder();
          try {
            builder.mergeFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.setUnfinishedMessage(builder.buildPartial());
          } catch (com.google.protobuf.UninitializedMessageException e) {
            throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
          } catch (java.io.IOException e) {
            throw new com.google.protobuf.InvalidProtocolBufferException(e)
                .setUnfinishedMessage(builder.buildPartial());
          }
          return builder.buildPartial();
        }
      };

      public static com.google.protobuf.Parser<CompactSchedConfig> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<CompactSchedConfig> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public perfetto.protos.FtraceConfigOuterClass.FtraceConfig.CompactSchedConfig getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    public interface PrintFilterOrBuilder extends
        // @@protoc_insertion_point(interface_extends:perfetto.protos.FtraceConfig.PrintFilter)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <code>repeated .perfetto.protos.FtraceConfig.PrintFilter.Rule rules = 1;</code>
       */
      java.util.List<perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule> 
          getRulesList();
      /**
       * <code>repeated .perfetto.protos.FtraceConfig.PrintFilter.Rule rules = 1;</code>
       */
      perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule getRules(int index);
      /**
       * <code>repeated .perfetto.protos.FtraceConfig.PrintFilter.Rule rules = 1;</code>
       */
      int getRulesCount();
      /**
       * <code>repeated .perfetto.protos.FtraceConfig.PrintFilter.Rule rules = 1;</code>
       */
      java.util.List<? extends perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.RuleOrBuilder> 
          getRulesOrBuilderList();
      /**
       * <code>repeated .perfetto.protos.FtraceConfig.PrintFilter.Rule rules = 1;</code>
       */
      perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.RuleOrBuilder getRulesOrBuilder(
          int index);
    }
    /**
     * <pre>
     * Optional filter for "ftrace/print" events.
     *
     * The filter consists of multiple rules. As soon as a rule matches (the rules
     * are processed in order), its `allow` field will be used as the outcome: if
     * `allow` is true, the event will be included in the trace, otherwise it will
     * be discarded. If an event does not match any rule, it will be allowed by
     * default (a rule with an empty prefix and allow=false, disallows everything
     * by default).
     * </pre>
     *
     * Protobuf type {@code perfetto.protos.FtraceConfig.PrintFilter}
     */
    public static final class PrintFilter extends
        com.google.protobuf.GeneratedMessage implements
        // @@protoc_insertion_point(message_implements:perfetto.protos.FtraceConfig.PrintFilter)
        PrintFilterOrBuilder {
    private static final long serialVersionUID = 0L;
      static {
        com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
          com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
          /* major= */ 4,
          /* minor= */ 29,
          /* patch= */ 3,
          /* suffix= */ "",
          PrintFilter.class.getName());
      }
      // Use PrintFilter.newBuilder() to construct.
      private PrintFilter(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
        super(builder);
      }
      private PrintFilter() {
        rules_ = java.util.Collections.emptyList();
      }

      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return perfetto.protos.FtraceConfigOuterClass.internal_static_perfetto_protos_FtraceConfig_PrintFilter_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return perfetto.protos.FtraceConfigOuterClass.internal_static_perfetto_protos_FtraceConfig_PrintFilter_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.class, perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Builder.class);
      }

      public interface RuleOrBuilder extends
          // @@protoc_insertion_point(interface_extends:perfetto.protos.FtraceConfig.PrintFilter.Rule)
          com.google.protobuf.MessageOrBuilder {

        /**
         * <pre>
         * This rule matches if `prefix` matches exactly with the beginning of
         * the "ftrace/print" "buf" field.
         * </pre>
         *
         * <code>string prefix = 1;</code>
         * @return Whether the prefix field is set.
         */
        boolean hasPrefix();
        /**
         * <pre>
         * This rule matches if `prefix` matches exactly with the beginning of
         * the "ftrace/print" "buf" field.
         * </pre>
         *
         * <code>string prefix = 1;</code>
         * @return The prefix.
         */
        java.lang.String getPrefix();
        /**
         * <pre>
         * This rule matches if `prefix` matches exactly with the beginning of
         * the "ftrace/print" "buf" field.
         * </pre>
         *
         * <code>string prefix = 1;</code>
         * @return The bytes for prefix.
         */
        com.google.protobuf.ByteString
            getPrefixBytes();

        /**
         * <pre>
         * This rule matches if the "buf" field contains an atrace-style print
         * message as specified in `atrace_msg`.
         * </pre>
         *
         * <code>.perfetto.protos.FtraceConfig.PrintFilter.Rule.AtraceMessage atrace_msg = 3;</code>
         * @return Whether the atraceMsg field is set.
         */
        boolean hasAtraceMsg();
        /**
         * <pre>
         * This rule matches if the "buf" field contains an atrace-style print
         * message as specified in `atrace_msg`.
         * </pre>
         *
         * <code>.perfetto.protos.FtraceConfig.PrintFilter.Rule.AtraceMessage atrace_msg = 3;</code>
         * @return The atraceMsg.
         */
        perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.AtraceMessage getAtraceMsg();
        /**
         * <pre>
         * This rule matches if the "buf" field contains an atrace-style print
         * message as specified in `atrace_msg`.
         * </pre>
         *
         * <code>.perfetto.protos.FtraceConfig.PrintFilter.Rule.AtraceMessage atrace_msg = 3;</code>
         */
        perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.AtraceMessageOrBuilder getAtraceMsgOrBuilder();

        /**
         * <code>optional bool allow = 2;</code>
         * @return Whether the allow field is set.
         */
        boolean hasAllow();
        /**
         * <code>optional bool allow = 2;</code>
         * @return The allow.
         */
        boolean getAllow();

        perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.MatchCase getMatchCase();
      }
      /**
       * Protobuf type {@code perfetto.protos.FtraceConfig.PrintFilter.Rule}
       */
      public static final class Rule extends
          com.google.protobuf.GeneratedMessage implements
          // @@protoc_insertion_point(message_implements:perfetto.protos.FtraceConfig.PrintFilter.Rule)
          RuleOrBuilder {
      private static final long serialVersionUID = 0L;
        static {
          com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
            com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
            /* major= */ 4,
            /* minor= */ 29,
            /* patch= */ 3,
            /* suffix= */ "",
            Rule.class.getName());
        }
        // Use Rule.newBuilder() to construct.
        private Rule(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
          super(builder);
        }
        private Rule() {
        }

        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return perfetto.protos.FtraceConfigOuterClass.internal_static_perfetto_protos_FtraceConfig_PrintFilter_Rule_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return perfetto.protos.FtraceConfigOuterClass.internal_static_perfetto_protos_FtraceConfig_PrintFilter_Rule_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.class, perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.Builder.class);
        }

        public interface AtraceMessageOrBuilder extends
            // @@protoc_insertion_point(interface_extends:perfetto.protos.FtraceConfig.PrintFilter.Rule.AtraceMessage)
            com.google.protobuf.MessageOrBuilder {

          /**
           * <code>optional string type = 1;</code>
           * @return Whether the type field is set.
           */
          boolean hasType();
          /**
           * <code>optional string type = 1;</code>
           * @return The type.
           */
          java.lang.String getType();
          /**
           * <code>optional string type = 1;</code>
           * @return The bytes for type.
           */
          com.google.protobuf.ByteString
              getTypeBytes();

          /**
           * <code>optional string prefix = 2;</code>
           * @return Whether the prefix field is set.
           */
          boolean hasPrefix();
          /**
           * <code>optional string prefix = 2;</code>
           * @return The prefix.
           */
          java.lang.String getPrefix();
          /**
           * <code>optional string prefix = 2;</code>
           * @return The bytes for prefix.
           */
          com.google.protobuf.ByteString
              getPrefixBytes();
        }
        /**
         * <pre>
         * Matches an atrace message of the form:
         * &lt;type&gt;|pid|&lt;prefix&gt;...
         * </pre>
         *
         * Protobuf type {@code perfetto.protos.FtraceConfig.PrintFilter.Rule.AtraceMessage}
         */
        public static final class AtraceMessage extends
            com.google.protobuf.GeneratedMessage implements
            // @@protoc_insertion_point(message_implements:perfetto.protos.FtraceConfig.PrintFilter.Rule.AtraceMessage)
            AtraceMessageOrBuilder {
        private static final long serialVersionUID = 0L;
          static {
            com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
              com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
              /* major= */ 4,
              /* minor= */ 29,
              /* patch= */ 3,
              /* suffix= */ "",
              AtraceMessage.class.getName());
          }
          // Use AtraceMessage.newBuilder() to construct.
          private AtraceMessage(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
            super(builder);
          }
          private AtraceMessage() {
            type_ = "";
            prefix_ = "";
          }

          public static final com.google.protobuf.Descriptors.Descriptor
              getDescriptor() {
            return perfetto.protos.FtraceConfigOuterClass.internal_static_perfetto_protos_FtraceConfig_PrintFilter_Rule_AtraceMessage_descriptor;
          }

          @java.lang.Override
          protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
              internalGetFieldAccessorTable() {
            return perfetto.protos.FtraceConfigOuterClass.internal_static_perfetto_protos_FtraceConfig_PrintFilter_Rule_AtraceMessage_fieldAccessorTable
                .ensureFieldAccessorsInitialized(
                    perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.AtraceMessage.class, perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.AtraceMessage.Builder.class);
          }

          private int bitField0_;
          public static final int TYPE_FIELD_NUMBER = 1;
          @SuppressWarnings("serial")
          private volatile java.lang.Object type_ = "";
          /**
           * <code>optional string type = 1;</code>
           * @return Whether the type field is set.
           */
          @java.lang.Override
          public boolean hasType() {
            return ((bitField0_ & 0x00000001) != 0);
          }
          /**
           * <code>optional string type = 1;</code>
           * @return The type.
           */
          @java.lang.Override
          public java.lang.String getType() {
            java.lang.Object ref = type_;
            if (ref instanceof java.lang.String) {
              return (java.lang.String) ref;
            } else {
              com.google.protobuf.ByteString bs = 
                  (com.google.protobuf.ByteString) ref;
              java.lang.String s = bs.toStringUtf8();
              if (bs.isValidUtf8()) {
                type_ = s;
              }
              return s;
            }
          }
          /**
           * <code>optional string type = 1;</code>
           * @return The bytes for type.
           */
          @java.lang.Override
          public com.google.protobuf.ByteString
              getTypeBytes() {
            java.lang.Object ref = type_;
            if (ref instanceof java.lang.String) {
              com.google.protobuf.ByteString b = 
                  com.google.protobuf.ByteString.copyFromUtf8(
                      (java.lang.String) ref);
              type_ = b;
              return b;
            } else {
              return (com.google.protobuf.ByteString) ref;
            }
          }

          public static final int PREFIX_FIELD_NUMBER = 2;
          @SuppressWarnings("serial")
          private volatile java.lang.Object prefix_ = "";
          /**
           * <code>optional string prefix = 2;</code>
           * @return Whether the prefix field is set.
           */
          @java.lang.Override
          public boolean hasPrefix() {
            return ((bitField0_ & 0x00000002) != 0);
          }
          /**
           * <code>optional string prefix = 2;</code>
           * @return The prefix.
           */
          @java.lang.Override
          public java.lang.String getPrefix() {
            java.lang.Object ref = prefix_;
            if (ref instanceof java.lang.String) {
              return (java.lang.String) ref;
            } else {
              com.google.protobuf.ByteString bs = 
                  (com.google.protobuf.ByteString) ref;
              java.lang.String s = bs.toStringUtf8();
              if (bs.isValidUtf8()) {
                prefix_ = s;
              }
              return s;
            }
          }
          /**
           * <code>optional string prefix = 2;</code>
           * @return The bytes for prefix.
           */
          @java.lang.Override
          public com.google.protobuf.ByteString
              getPrefixBytes() {
            java.lang.Object ref = prefix_;
            if (ref instanceof java.lang.String) {
              com.google.protobuf.ByteString b = 
                  com.google.protobuf.ByteString.copyFromUtf8(
                      (java.lang.String) ref);
              prefix_ = b;
              return b;
            } else {
              return (com.google.protobuf.ByteString) ref;
            }
          }

          private byte memoizedIsInitialized = -1;
          @java.lang.Override
          public final boolean isInitialized() {
            byte isInitialized = memoizedIsInitialized;
            if (isInitialized == 1) return true;
            if (isInitialized == 0) return false;

            memoizedIsInitialized = 1;
            return true;
          }

          @java.lang.Override
          public void writeTo(com.google.protobuf.CodedOutputStream output)
                              throws java.io.IOException {
            if (((bitField0_ & 0x00000001) != 0)) {
              com.google.protobuf.GeneratedMessage.writeString(output, 1, type_);
            }
            if (((bitField0_ & 0x00000002) != 0)) {
              com.google.protobuf.GeneratedMessage.writeString(output, 2, prefix_);
            }
            getUnknownFields().writeTo(output);
          }

          @java.lang.Override
          public int getSerializedSize() {
            int size = memoizedSize;
            if (size != -1) return size;

            size = 0;
            if (((bitField0_ & 0x00000001) != 0)) {
              size += com.google.protobuf.GeneratedMessage.computeStringSize(1, type_);
            }
            if (((bitField0_ & 0x00000002) != 0)) {
              size += com.google.protobuf.GeneratedMessage.computeStringSize(2, prefix_);
            }
            size += getUnknownFields().getSerializedSize();
            memoizedSize = size;
            return size;
          }

          @java.lang.Override
          public boolean equals(final java.lang.Object obj) {
            if (obj == this) {
             return true;
            }
            if (!(obj instanceof perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.AtraceMessage)) {
              return super.equals(obj);
            }
            perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.AtraceMessage other = (perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.AtraceMessage) obj;

            if (hasType() != other.hasType()) return false;
            if (hasType()) {
              if (!getType()
                  .equals(other.getType())) return false;
            }
            if (hasPrefix() != other.hasPrefix()) return false;
            if (hasPrefix()) {
              if (!getPrefix()
                  .equals(other.getPrefix())) return false;
            }
            if (!getUnknownFields().equals(other.getUnknownFields())) return false;
            return true;
          }

          @java.lang.Override
          public int hashCode() {
            if (memoizedHashCode != 0) {
              return memoizedHashCode;
            }
            int hash = 41;
            hash = (19 * hash) + getDescriptor().hashCode();
            if (hasType()) {
              hash = (37 * hash) + TYPE_FIELD_NUMBER;
              hash = (53 * hash) + getType().hashCode();
            }
            if (hasPrefix()) {
              hash = (37 * hash) + PREFIX_FIELD_NUMBER;
              hash = (53 * hash) + getPrefix().hashCode();
            }
            hash = (29 * hash) + getUnknownFields().hashCode();
            memoizedHashCode = hash;
            return hash;
          }

          public static perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.AtraceMessage parseFrom(
              java.nio.ByteBuffer data)
              throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
          }
          public static perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.AtraceMessage parseFrom(
              java.nio.ByteBuffer data,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
          }
          public static perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.AtraceMessage parseFrom(
              com.google.protobuf.ByteString data)
              throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
          }
          public static perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.AtraceMessage parseFrom(
              com.google.protobuf.ByteString data,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
          }
          public static perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.AtraceMessage parseFrom(byte[] data)
              throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data);
          }
          public static perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.AtraceMessage parseFrom(
              byte[] data,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            return PARSER.parseFrom(data, extensionRegistry);
          }
          public static perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.AtraceMessage parseFrom(java.io.InputStream input)
              throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input);
          }
          public static perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.AtraceMessage parseFrom(
              java.io.InputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input, extensionRegistry);
          }

          public static perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.AtraceMessage parseDelimitedFrom(java.io.InputStream input)
              throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseDelimitedWithIOException(PARSER, input);
          }

          public static perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.AtraceMessage parseDelimitedFrom(
              java.io.InputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
          }
          public static perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.AtraceMessage parseFrom(
              com.google.protobuf.CodedInputStream input)
              throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input);
          }
          public static perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.AtraceMessage parseFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws java.io.IOException {
            return com.google.protobuf.GeneratedMessage
                .parseWithIOException(PARSER, input, extensionRegistry);
          }

          @java.lang.Override
          public Builder newBuilderForType() { return newBuilder(); }
          public static Builder newBuilder() {
            return DEFAULT_INSTANCE.toBuilder();
          }
          public static Builder newBuilder(perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.AtraceMessage prototype) {
            return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
          }
          @java.lang.Override
          public Builder toBuilder() {
            return this == DEFAULT_INSTANCE
                ? new Builder() : new Builder().mergeFrom(this);
          }

          @java.lang.Override
          protected Builder newBuilderForType(
              com.google.protobuf.GeneratedMessage.BuilderParent parent) {
            Builder builder = new Builder(parent);
            return builder;
          }
          /**
           * <pre>
           * Matches an atrace message of the form:
           * &lt;type&gt;|pid|&lt;prefix&gt;...
           * </pre>
           *
           * Protobuf type {@code perfetto.protos.FtraceConfig.PrintFilter.Rule.AtraceMessage}
           */
          public static final class Builder extends
              com.google.protobuf.GeneratedMessage.Builder<Builder> implements
              // @@protoc_insertion_point(builder_implements:perfetto.protos.FtraceConfig.PrintFilter.Rule.AtraceMessage)
              perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.AtraceMessageOrBuilder {
            public static final com.google.protobuf.Descriptors.Descriptor
                getDescriptor() {
              return perfetto.protos.FtraceConfigOuterClass.internal_static_perfetto_protos_FtraceConfig_PrintFilter_Rule_AtraceMessage_descriptor;
            }

            @java.lang.Override
            protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
                internalGetFieldAccessorTable() {
              return perfetto.protos.FtraceConfigOuterClass.internal_static_perfetto_protos_FtraceConfig_PrintFilter_Rule_AtraceMessage_fieldAccessorTable
                  .ensureFieldAccessorsInitialized(
                      perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.AtraceMessage.class, perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.AtraceMessage.Builder.class);
            }

            // Construct using perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.AtraceMessage.newBuilder()
            private Builder() {

            }

            private Builder(
                com.google.protobuf.GeneratedMessage.BuilderParent parent) {
              super(parent);

            }
            @java.lang.Override
            public Builder clear() {
              super.clear();
              bitField0_ = 0;
              type_ = "";
              prefix_ = "";
              return this;
            }

            @java.lang.Override
            public com.google.protobuf.Descriptors.Descriptor
                getDescriptorForType() {
              return perfetto.protos.FtraceConfigOuterClass.internal_static_perfetto_protos_FtraceConfig_PrintFilter_Rule_AtraceMessage_descriptor;
            }

            @java.lang.Override
            public perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.AtraceMessage getDefaultInstanceForType() {
              return perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.AtraceMessage.getDefaultInstance();
            }

            @java.lang.Override
            public perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.AtraceMessage build() {
              perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.AtraceMessage result = buildPartial();
              if (!result.isInitialized()) {
                throw newUninitializedMessageException(result);
              }
              return result;
            }

            @java.lang.Override
            public perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.AtraceMessage buildPartial() {
              perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.AtraceMessage result = new perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.AtraceMessage(this);
              if (bitField0_ != 0) { buildPartial0(result); }
              onBuilt();
              return result;
            }

            private void buildPartial0(perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.AtraceMessage result) {
              int from_bitField0_ = bitField0_;
              int to_bitField0_ = 0;
              if (((from_bitField0_ & 0x00000001) != 0)) {
                result.type_ = type_;
                to_bitField0_ |= 0x00000001;
              }
              if (((from_bitField0_ & 0x00000002) != 0)) {
                result.prefix_ = prefix_;
                to_bitField0_ |= 0x00000002;
              }
              result.bitField0_ |= to_bitField0_;
            }

            @java.lang.Override
            public Builder mergeFrom(com.google.protobuf.Message other) {
              if (other instanceof perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.AtraceMessage) {
                return mergeFrom((perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.AtraceMessage)other);
              } else {
                super.mergeFrom(other);
                return this;
              }
            }

            public Builder mergeFrom(perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.AtraceMessage other) {
              if (other == perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.AtraceMessage.getDefaultInstance()) return this;
              if (other.hasType()) {
                type_ = other.type_;
                bitField0_ |= 0x00000001;
                onChanged();
              }
              if (other.hasPrefix()) {
                prefix_ = other.prefix_;
                bitField0_ |= 0x00000002;
                onChanged();
              }
              this.mergeUnknownFields(other.getUnknownFields());
              onChanged();
              return this;
            }

            @java.lang.Override
            public final boolean isInitialized() {
              return true;
            }

            @java.lang.Override
            public Builder mergeFrom(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws java.io.IOException {
              if (extensionRegistry == null) {
                throw new java.lang.NullPointerException();
              }
              try {
                boolean done = false;
                while (!done) {
                  int tag = input.readTag();
                  switch (tag) {
                    case 0:
                      done = true;
                      break;
                    case 10: {
                      type_ = input.readBytes();
                      bitField0_ |= 0x00000001;
                      break;
                    } // case 10
                    case 18: {
                      prefix_ = input.readBytes();
                      bitField0_ |= 0x00000002;
                      break;
                    } // case 18
                    default: {
                      if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                        done = true; // was an endgroup tag
                      }
                      break;
                    } // default:
                  } // switch (tag)
                } // while (!done)
              } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                throw e.unwrapIOException();
              } finally {
                onChanged();
              } // finally
              return this;
            }
            private int bitField0_;

            private java.lang.Object type_ = "";
            /**
             * <code>optional string type = 1;</code>
             * @return Whether the type field is set.
             */
            public boolean hasType() {
              return ((bitField0_ & 0x00000001) != 0);
            }
            /**
             * <code>optional string type = 1;</code>
             * @return The type.
             */
            public java.lang.String getType() {
              java.lang.Object ref = type_;
              if (!(ref instanceof java.lang.String)) {
                com.google.protobuf.ByteString bs =
                    (com.google.protobuf.ByteString) ref;
                java.lang.String s = bs.toStringUtf8();
                if (bs.isValidUtf8()) {
                  type_ = s;
                }
                return s;
              } else {
                return (java.lang.String) ref;
              }
            }
            /**
             * <code>optional string type = 1;</code>
             * @return The bytes for type.
             */
            public com.google.protobuf.ByteString
                getTypeBytes() {
              java.lang.Object ref = type_;
              if (ref instanceof String) {
                com.google.protobuf.ByteString b = 
                    com.google.protobuf.ByteString.copyFromUtf8(
                        (java.lang.String) ref);
                type_ = b;
                return b;
              } else {
                return (com.google.protobuf.ByteString) ref;
              }
            }
            /**
             * <code>optional string type = 1;</code>
             * @param value The type to set.
             * @return This builder for chaining.
             */
            public Builder setType(
                java.lang.String value) {
              if (value == null) { throw new NullPointerException(); }
              type_ = value;
              bitField0_ |= 0x00000001;
              onChanged();
              return this;
            }
            /**
             * <code>optional string type = 1;</code>
             * @return This builder for chaining.
             */
            public Builder clearType() {
              type_ = getDefaultInstance().getType();
              bitField0_ = (bitField0_ & ~0x00000001);
              onChanged();
              return this;
            }
            /**
             * <code>optional string type = 1;</code>
             * @param value The bytes for type to set.
             * @return This builder for chaining.
             */
            public Builder setTypeBytes(
                com.google.protobuf.ByteString value) {
              if (value == null) { throw new NullPointerException(); }
              type_ = value;
              bitField0_ |= 0x00000001;
              onChanged();
              return this;
            }

            private java.lang.Object prefix_ = "";
            /**
             * <code>optional string prefix = 2;</code>
             * @return Whether the prefix field is set.
             */
            public boolean hasPrefix() {
              return ((bitField0_ & 0x00000002) != 0);
            }
            /**
             * <code>optional string prefix = 2;</code>
             * @return The prefix.
             */
            public java.lang.String getPrefix() {
              java.lang.Object ref = prefix_;
              if (!(ref instanceof java.lang.String)) {
                com.google.protobuf.ByteString bs =
                    (com.google.protobuf.ByteString) ref;
                java.lang.String s = bs.toStringUtf8();
                if (bs.isValidUtf8()) {
                  prefix_ = s;
                }
                return s;
              } else {
                return (java.lang.String) ref;
              }
            }
            /**
             * <code>optional string prefix = 2;</code>
             * @return The bytes for prefix.
             */
            public com.google.protobuf.ByteString
                getPrefixBytes() {
              java.lang.Object ref = prefix_;
              if (ref instanceof String) {
                com.google.protobuf.ByteString b = 
                    com.google.protobuf.ByteString.copyFromUtf8(
                        (java.lang.String) ref);
                prefix_ = b;
                return b;
              } else {
                return (com.google.protobuf.ByteString) ref;
              }
            }
            /**
             * <code>optional string prefix = 2;</code>
             * @param value The prefix to set.
             * @return This builder for chaining.
             */
            public Builder setPrefix(
                java.lang.String value) {
              if (value == null) { throw new NullPointerException(); }
              prefix_ = value;
              bitField0_ |= 0x00000002;
              onChanged();
              return this;
            }
            /**
             * <code>optional string prefix = 2;</code>
             * @return This builder for chaining.
             */
            public Builder clearPrefix() {
              prefix_ = getDefaultInstance().getPrefix();
              bitField0_ = (bitField0_ & ~0x00000002);
              onChanged();
              return this;
            }
            /**
             * <code>optional string prefix = 2;</code>
             * @param value The bytes for prefix to set.
             * @return This builder for chaining.
             */
            public Builder setPrefixBytes(
                com.google.protobuf.ByteString value) {
              if (value == null) { throw new NullPointerException(); }
              prefix_ = value;
              bitField0_ |= 0x00000002;
              onChanged();
              return this;
            }

            // @@protoc_insertion_point(builder_scope:perfetto.protos.FtraceConfig.PrintFilter.Rule.AtraceMessage)
          }

          // @@protoc_insertion_point(class_scope:perfetto.protos.FtraceConfig.PrintFilter.Rule.AtraceMessage)
          private static final perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.AtraceMessage DEFAULT_INSTANCE;
          static {
            DEFAULT_INSTANCE = new perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.AtraceMessage();
          }

          public static perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.AtraceMessage getDefaultInstance() {
            return DEFAULT_INSTANCE;
          }

          private static final com.google.protobuf.Parser<AtraceMessage>
              PARSER = new com.google.protobuf.AbstractParser<AtraceMessage>() {
            @java.lang.Override
            public AtraceMessage parsePartialFrom(
                com.google.protobuf.CodedInputStream input,
                com.google.protobuf.ExtensionRegistryLite extensionRegistry)
                throws com.google.protobuf.InvalidProtocolBufferException {
              Builder builder = newBuilder();
              try {
                builder.mergeFrom(input, extensionRegistry);
              } catch (com.google.protobuf.InvalidProtocolBufferException e) {
                throw e.setUnfinishedMessage(builder.buildPartial());
              } catch (com.google.protobuf.UninitializedMessageException e) {
                throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
              } catch (java.io.IOException e) {
                throw new com.google.protobuf.InvalidProtocolBufferException(e)
                    .setUnfinishedMessage(builder.buildPartial());
              }
              return builder.buildPartial();
            }
          };

          public static com.google.protobuf.Parser<AtraceMessage> parser() {
            return PARSER;
          }

          @java.lang.Override
          public com.google.protobuf.Parser<AtraceMessage> getParserForType() {
            return PARSER;
          }

          @java.lang.Override
          public perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.AtraceMessage getDefaultInstanceForType() {
            return DEFAULT_INSTANCE;
          }

        }

        private int bitField0_;
        private int matchCase_ = 0;
        @SuppressWarnings("serial")
        private java.lang.Object match_;
        public enum MatchCase
            implements com.google.protobuf.Internal.EnumLite,
                com.google.protobuf.AbstractMessage.InternalOneOfEnum {
          PREFIX(1),
          ATRACE_MSG(3),
          MATCH_NOT_SET(0);
          private final int value;
          private MatchCase(int value) {
            this.value = value;
          }
          /**
           * @param value The number of the enum to look for.
           * @return The enum associated with the given number.
           * @deprecated Use {@link #forNumber(int)} instead.
           */
          @java.lang.Deprecated
          public static MatchCase valueOf(int value) {
            return forNumber(value);
          }

          public static MatchCase forNumber(int value) {
            switch (value) {
              case 1: return PREFIX;
              case 3: return ATRACE_MSG;
              case 0: return MATCH_NOT_SET;
              default: return null;
            }
          }
          public int getNumber() {
            return this.value;
          }
        };

        public MatchCase
        getMatchCase() {
          return MatchCase.forNumber(
              matchCase_);
        }

        public static final int PREFIX_FIELD_NUMBER = 1;
        /**
         * <pre>
         * This rule matches if `prefix` matches exactly with the beginning of
         * the "ftrace/print" "buf" field.
         * </pre>
         *
         * <code>string prefix = 1;</code>
         * @return Whether the prefix field is set.
         */
        public boolean hasPrefix() {
          return matchCase_ == 1;
        }
        /**
         * <pre>
         * This rule matches if `prefix` matches exactly with the beginning of
         * the "ftrace/print" "buf" field.
         * </pre>
         *
         * <code>string prefix = 1;</code>
         * @return The prefix.
         */
        public java.lang.String getPrefix() {
          java.lang.Object ref = "";
          if (matchCase_ == 1) {
            ref = match_;
          }
          if (ref instanceof java.lang.String) {
            return (java.lang.String) ref;
          } else {
            com.google.protobuf.ByteString bs = 
                (com.google.protobuf.ByteString) ref;
            java.lang.String s = bs.toStringUtf8();
            if (bs.isValidUtf8() && (matchCase_ == 1)) {
              match_ = s;
            }
            return s;
          }
        }
        /**
         * <pre>
         * This rule matches if `prefix` matches exactly with the beginning of
         * the "ftrace/print" "buf" field.
         * </pre>
         *
         * <code>string prefix = 1;</code>
         * @return The bytes for prefix.
         */
        public com.google.protobuf.ByteString
            getPrefixBytes() {
          java.lang.Object ref = "";
          if (matchCase_ == 1) {
            ref = match_;
          }
          if (ref instanceof java.lang.String) {
            com.google.protobuf.ByteString b = 
                com.google.protobuf.ByteString.copyFromUtf8(
                    (java.lang.String) ref);
            if (matchCase_ == 1) {
              match_ = b;
            }
            return b;
          } else {
            return (com.google.protobuf.ByteString) ref;
          }
        }

        public static final int ATRACE_MSG_FIELD_NUMBER = 3;
        /**
         * <pre>
         * This rule matches if the "buf" field contains an atrace-style print
         * message as specified in `atrace_msg`.
         * </pre>
         *
         * <code>.perfetto.protos.FtraceConfig.PrintFilter.Rule.AtraceMessage atrace_msg = 3;</code>
         * @return Whether the atraceMsg field is set.
         */
        @java.lang.Override
        public boolean hasAtraceMsg() {
          return matchCase_ == 3;
        }
        /**
         * <pre>
         * This rule matches if the "buf" field contains an atrace-style print
         * message as specified in `atrace_msg`.
         * </pre>
         *
         * <code>.perfetto.protos.FtraceConfig.PrintFilter.Rule.AtraceMessage atrace_msg = 3;</code>
         * @return The atraceMsg.
         */
        @java.lang.Override
        public perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.AtraceMessage getAtraceMsg() {
          if (matchCase_ == 3) {
             return (perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.AtraceMessage) match_;
          }
          return perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.AtraceMessage.getDefaultInstance();
        }
        /**
         * <pre>
         * This rule matches if the "buf" field contains an atrace-style print
         * message as specified in `atrace_msg`.
         * </pre>
         *
         * <code>.perfetto.protos.FtraceConfig.PrintFilter.Rule.AtraceMessage atrace_msg = 3;</code>
         */
        @java.lang.Override
        public perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.AtraceMessageOrBuilder getAtraceMsgOrBuilder() {
          if (matchCase_ == 3) {
             return (perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.AtraceMessage) match_;
          }
          return perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.AtraceMessage.getDefaultInstance();
        }

        public static final int ALLOW_FIELD_NUMBER = 2;
        private boolean allow_ = false;
        /**
         * <code>optional bool allow = 2;</code>
         * @return Whether the allow field is set.
         */
        @java.lang.Override
        public boolean hasAllow() {
          return ((bitField0_ & 0x00000001) != 0);
        }
        /**
         * <code>optional bool allow = 2;</code>
         * @return The allow.
         */
        @java.lang.Override
        public boolean getAllow() {
          return allow_;
        }

        private byte memoizedIsInitialized = -1;
        @java.lang.Override
        public final boolean isInitialized() {
          byte isInitialized = memoizedIsInitialized;
          if (isInitialized == 1) return true;
          if (isInitialized == 0) return false;

          memoizedIsInitialized = 1;
          return true;
        }

        @java.lang.Override
        public void writeTo(com.google.protobuf.CodedOutputStream output)
                            throws java.io.IOException {
          if (matchCase_ == 1) {
            com.google.protobuf.GeneratedMessage.writeString(output, 1, match_);
          }
          if (((bitField0_ & 0x00000001) != 0)) {
            output.writeBool(2, allow_);
          }
          if (matchCase_ == 3) {
            output.writeMessage(3, (perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.AtraceMessage) match_);
          }
          getUnknownFields().writeTo(output);
        }

        @java.lang.Override
        public int getSerializedSize() {
          int size = memoizedSize;
          if (size != -1) return size;

          size = 0;
          if (matchCase_ == 1) {
            size += com.google.protobuf.GeneratedMessage.computeStringSize(1, match_);
          }
          if (((bitField0_ & 0x00000001) != 0)) {
            size += com.google.protobuf.CodedOutputStream
              .computeBoolSize(2, allow_);
          }
          if (matchCase_ == 3) {
            size += com.google.protobuf.CodedOutputStream
              .computeMessageSize(3, (perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.AtraceMessage) match_);
          }
          size += getUnknownFields().getSerializedSize();
          memoizedSize = size;
          return size;
        }

        @java.lang.Override
        public boolean equals(final java.lang.Object obj) {
          if (obj == this) {
           return true;
          }
          if (!(obj instanceof perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule)) {
            return super.equals(obj);
          }
          perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule other = (perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule) obj;

          if (hasAllow() != other.hasAllow()) return false;
          if (hasAllow()) {
            if (getAllow()
                != other.getAllow()) return false;
          }
          if (!getMatchCase().equals(other.getMatchCase())) return false;
          switch (matchCase_) {
            case 1:
              if (!getPrefix()
                  .equals(other.getPrefix())) return false;
              break;
            case 3:
              if (!getAtraceMsg()
                  .equals(other.getAtraceMsg())) return false;
              break;
            case 0:
            default:
          }
          if (!getUnknownFields().equals(other.getUnknownFields())) return false;
          return true;
        }

        @java.lang.Override
        public int hashCode() {
          if (memoizedHashCode != 0) {
            return memoizedHashCode;
          }
          int hash = 41;
          hash = (19 * hash) + getDescriptor().hashCode();
          if (hasAllow()) {
            hash = (37 * hash) + ALLOW_FIELD_NUMBER;
            hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
                getAllow());
          }
          switch (matchCase_) {
            case 1:
              hash = (37 * hash) + PREFIX_FIELD_NUMBER;
              hash = (53 * hash) + getPrefix().hashCode();
              break;
            case 3:
              hash = (37 * hash) + ATRACE_MSG_FIELD_NUMBER;
              hash = (53 * hash) + getAtraceMsg().hashCode();
              break;
            case 0:
            default:
          }
          hash = (29 * hash) + getUnknownFields().hashCode();
          memoizedHashCode = hash;
          return hash;
        }

        public static perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule parseFrom(
            java.nio.ByteBuffer data)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return PARSER.parseFrom(data);
        }
        public static perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule parseFrom(
            java.nio.ByteBuffer data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return PARSER.parseFrom(data, extensionRegistry);
        }
        public static perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule parseFrom(
            com.google.protobuf.ByteString data)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return PARSER.parseFrom(data);
        }
        public static perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule parseFrom(
            com.google.protobuf.ByteString data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return PARSER.parseFrom(data, extensionRegistry);
        }
        public static perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule parseFrom(byte[] data)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return PARSER.parseFrom(data);
        }
        public static perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule parseFrom(
            byte[] data,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          return PARSER.parseFrom(data, extensionRegistry);
        }
        public static perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule parseFrom(java.io.InputStream input)
            throws java.io.IOException {
          return com.google.protobuf.GeneratedMessage
              .parseWithIOException(PARSER, input);
        }
        public static perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule parseFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          return com.google.protobuf.GeneratedMessage
              .parseWithIOException(PARSER, input, extensionRegistry);
        }

        public static perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule parseDelimitedFrom(java.io.InputStream input)
            throws java.io.IOException {
          return com.google.protobuf.GeneratedMessage
              .parseDelimitedWithIOException(PARSER, input);
        }

        public static perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule parseDelimitedFrom(
            java.io.InputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          return com.google.protobuf.GeneratedMessage
              .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
        }
        public static perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule parseFrom(
            com.google.protobuf.CodedInputStream input)
            throws java.io.IOException {
          return com.google.protobuf.GeneratedMessage
              .parseWithIOException(PARSER, input);
        }
        public static perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule parseFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          return com.google.protobuf.GeneratedMessage
              .parseWithIOException(PARSER, input, extensionRegistry);
        }

        @java.lang.Override
        public Builder newBuilderForType() { return newBuilder(); }
        public static Builder newBuilder() {
          return DEFAULT_INSTANCE.toBuilder();
        }
        public static Builder newBuilder(perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule prototype) {
          return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
        }
        @java.lang.Override
        public Builder toBuilder() {
          return this == DEFAULT_INSTANCE
              ? new Builder() : new Builder().mergeFrom(this);
        }

        @java.lang.Override
        protected Builder newBuilderForType(
            com.google.protobuf.GeneratedMessage.BuilderParent parent) {
          Builder builder = new Builder(parent);
          return builder;
        }
        /**
         * Protobuf type {@code perfetto.protos.FtraceConfig.PrintFilter.Rule}
         */
        public static final class Builder extends
            com.google.protobuf.GeneratedMessage.Builder<Builder> implements
            // @@protoc_insertion_point(builder_implements:perfetto.protos.FtraceConfig.PrintFilter.Rule)
            perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.RuleOrBuilder {
          public static final com.google.protobuf.Descriptors.Descriptor
              getDescriptor() {
            return perfetto.protos.FtraceConfigOuterClass.internal_static_perfetto_protos_FtraceConfig_PrintFilter_Rule_descriptor;
          }

          @java.lang.Override
          protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
              internalGetFieldAccessorTable() {
            return perfetto.protos.FtraceConfigOuterClass.internal_static_perfetto_protos_FtraceConfig_PrintFilter_Rule_fieldAccessorTable
                .ensureFieldAccessorsInitialized(
                    perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.class, perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.Builder.class);
          }

          // Construct using perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.newBuilder()
          private Builder() {

          }

          private Builder(
              com.google.protobuf.GeneratedMessage.BuilderParent parent) {
            super(parent);

          }
          @java.lang.Override
          public Builder clear() {
            super.clear();
            bitField0_ = 0;
            if (atraceMsgBuilder_ != null) {
              atraceMsgBuilder_.clear();
            }
            allow_ = false;
            matchCase_ = 0;
            match_ = null;
            return this;
          }

          @java.lang.Override
          public com.google.protobuf.Descriptors.Descriptor
              getDescriptorForType() {
            return perfetto.protos.FtraceConfigOuterClass.internal_static_perfetto_protos_FtraceConfig_PrintFilter_Rule_descriptor;
          }

          @java.lang.Override
          public perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule getDefaultInstanceForType() {
            return perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.getDefaultInstance();
          }

          @java.lang.Override
          public perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule build() {
            perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule result = buildPartial();
            if (!result.isInitialized()) {
              throw newUninitializedMessageException(result);
            }
            return result;
          }

          @java.lang.Override
          public perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule buildPartial() {
            perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule result = new perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule(this);
            if (bitField0_ != 0) { buildPartial0(result); }
            buildPartialOneofs(result);
            onBuilt();
            return result;
          }

          private void buildPartial0(perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule result) {
            int from_bitField0_ = bitField0_;
            int to_bitField0_ = 0;
            if (((from_bitField0_ & 0x00000004) != 0)) {
              result.allow_ = allow_;
              to_bitField0_ |= 0x00000001;
            }
            result.bitField0_ |= to_bitField0_;
          }

          private void buildPartialOneofs(perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule result) {
            result.matchCase_ = matchCase_;
            result.match_ = this.match_;
            if (matchCase_ == 3 &&
                atraceMsgBuilder_ != null) {
              result.match_ = atraceMsgBuilder_.build();
            }
          }

          @java.lang.Override
          public Builder mergeFrom(com.google.protobuf.Message other) {
            if (other instanceof perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule) {
              return mergeFrom((perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule)other);
            } else {
              super.mergeFrom(other);
              return this;
            }
          }

          public Builder mergeFrom(perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule other) {
            if (other == perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.getDefaultInstance()) return this;
            if (other.hasAllow()) {
              setAllow(other.getAllow());
            }
            switch (other.getMatchCase()) {
              case PREFIX: {
                matchCase_ = 1;
                match_ = other.match_;
                onChanged();
                break;
              }
              case ATRACE_MSG: {
                mergeAtraceMsg(other.getAtraceMsg());
                break;
              }
              case MATCH_NOT_SET: {
                break;
              }
            }
            this.mergeUnknownFields(other.getUnknownFields());
            onChanged();
            return this;
          }

          @java.lang.Override
          public final boolean isInitialized() {
            return true;
          }

          @java.lang.Override
          public Builder mergeFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws java.io.IOException {
            if (extensionRegistry == null) {
              throw new java.lang.NullPointerException();
            }
            try {
              boolean done = false;
              while (!done) {
                int tag = input.readTag();
                switch (tag) {
                  case 0:
                    done = true;
                    break;
                  case 10: {
                    com.google.protobuf.ByteString bs = input.readBytes();
                    matchCase_ = 1;
                    match_ = bs;
                    break;
                  } // case 10
                  case 16: {
                    allow_ = input.readBool();
                    bitField0_ |= 0x00000004;
                    break;
                  } // case 16
                  case 26: {
                    input.readMessage(
                        getAtraceMsgFieldBuilder().getBuilder(),
                        extensionRegistry);
                    matchCase_ = 3;
                    break;
                  } // case 26
                  default: {
                    if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                      done = true; // was an endgroup tag
                    }
                    break;
                  } // default:
                } // switch (tag)
              } // while (!done)
            } catch (com.google.protobuf.InvalidProtocolBufferException e) {
              throw e.unwrapIOException();
            } finally {
              onChanged();
            } // finally
            return this;
          }
          private int matchCase_ = 0;
          private java.lang.Object match_;
          public MatchCase
              getMatchCase() {
            return MatchCase.forNumber(
                matchCase_);
          }

          public Builder clearMatch() {
            matchCase_ = 0;
            match_ = null;
            onChanged();
            return this;
          }

          private int bitField0_;

          /**
           * <pre>
           * This rule matches if `prefix` matches exactly with the beginning of
           * the "ftrace/print" "buf" field.
           * </pre>
           *
           * <code>string prefix = 1;</code>
           * @return Whether the prefix field is set.
           */
          @java.lang.Override
          public boolean hasPrefix() {
            return matchCase_ == 1;
          }
          /**
           * <pre>
           * This rule matches if `prefix` matches exactly with the beginning of
           * the "ftrace/print" "buf" field.
           * </pre>
           *
           * <code>string prefix = 1;</code>
           * @return The prefix.
           */
          @java.lang.Override
          public java.lang.String getPrefix() {
            java.lang.Object ref = "";
            if (matchCase_ == 1) {
              ref = match_;
            }
            if (!(ref instanceof java.lang.String)) {
              com.google.protobuf.ByteString bs =
                  (com.google.protobuf.ByteString) ref;
              java.lang.String s = bs.toStringUtf8();
              if (matchCase_ == 1) {
                if (bs.isValidUtf8()) {
                  match_ = s;
                }
              }
              return s;
            } else {
              return (java.lang.String) ref;
            }
          }
          /**
           * <pre>
           * This rule matches if `prefix` matches exactly with the beginning of
           * the "ftrace/print" "buf" field.
           * </pre>
           *
           * <code>string prefix = 1;</code>
           * @return The bytes for prefix.
           */
          @java.lang.Override
          public com.google.protobuf.ByteString
              getPrefixBytes() {
            java.lang.Object ref = "";
            if (matchCase_ == 1) {
              ref = match_;
            }
            if (ref instanceof String) {
              com.google.protobuf.ByteString b = 
                  com.google.protobuf.ByteString.copyFromUtf8(
                      (java.lang.String) ref);
              if (matchCase_ == 1) {
                match_ = b;
              }
              return b;
            } else {
              return (com.google.protobuf.ByteString) ref;
            }
          }
          /**
           * <pre>
           * This rule matches if `prefix` matches exactly with the beginning of
           * the "ftrace/print" "buf" field.
           * </pre>
           *
           * <code>string prefix = 1;</code>
           * @param value The prefix to set.
           * @return This builder for chaining.
           */
          public Builder setPrefix(
              java.lang.String value) {
            if (value == null) { throw new NullPointerException(); }
            matchCase_ = 1;
            match_ = value;
            onChanged();
            return this;
          }
          /**
           * <pre>
           * This rule matches if `prefix` matches exactly with the beginning of
           * the "ftrace/print" "buf" field.
           * </pre>
           *
           * <code>string prefix = 1;</code>
           * @return This builder for chaining.
           */
          public Builder clearPrefix() {
            if (matchCase_ == 1) {
              matchCase_ = 0;
              match_ = null;
              onChanged();
            }
            return this;
          }
          /**
           * <pre>
           * This rule matches if `prefix` matches exactly with the beginning of
           * the "ftrace/print" "buf" field.
           * </pre>
           *
           * <code>string prefix = 1;</code>
           * @param value The bytes for prefix to set.
           * @return This builder for chaining.
           */
          public Builder setPrefixBytes(
              com.google.protobuf.ByteString value) {
            if (value == null) { throw new NullPointerException(); }
            matchCase_ = 1;
            match_ = value;
            onChanged();
            return this;
          }

          private com.google.protobuf.SingleFieldBuilder<
              perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.AtraceMessage, perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.AtraceMessage.Builder, perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.AtraceMessageOrBuilder> atraceMsgBuilder_;
          /**
           * <pre>
           * This rule matches if the "buf" field contains an atrace-style print
           * message as specified in `atrace_msg`.
           * </pre>
           *
           * <code>.perfetto.protos.FtraceConfig.PrintFilter.Rule.AtraceMessage atrace_msg = 3;</code>
           * @return Whether the atraceMsg field is set.
           */
          @java.lang.Override
          public boolean hasAtraceMsg() {
            return matchCase_ == 3;
          }
          /**
           * <pre>
           * This rule matches if the "buf" field contains an atrace-style print
           * message as specified in `atrace_msg`.
           * </pre>
           *
           * <code>.perfetto.protos.FtraceConfig.PrintFilter.Rule.AtraceMessage atrace_msg = 3;</code>
           * @return The atraceMsg.
           */
          @java.lang.Override
          public perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.AtraceMessage getAtraceMsg() {
            if (atraceMsgBuilder_ == null) {
              if (matchCase_ == 3) {
                return (perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.AtraceMessage) match_;
              }
              return perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.AtraceMessage.getDefaultInstance();
            } else {
              if (matchCase_ == 3) {
                return atraceMsgBuilder_.getMessage();
              }
              return perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.AtraceMessage.getDefaultInstance();
            }
          }
          /**
           * <pre>
           * This rule matches if the "buf" field contains an atrace-style print
           * message as specified in `atrace_msg`.
           * </pre>
           *
           * <code>.perfetto.protos.FtraceConfig.PrintFilter.Rule.AtraceMessage atrace_msg = 3;</code>
           */
          public Builder setAtraceMsg(perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.AtraceMessage value) {
            if (atraceMsgBuilder_ == null) {
              if (value == null) {
                throw new NullPointerException();
              }
              match_ = value;
              onChanged();
            } else {
              atraceMsgBuilder_.setMessage(value);
            }
            matchCase_ = 3;
            return this;
          }
          /**
           * <pre>
           * This rule matches if the "buf" field contains an atrace-style print
           * message as specified in `atrace_msg`.
           * </pre>
           *
           * <code>.perfetto.protos.FtraceConfig.PrintFilter.Rule.AtraceMessage atrace_msg = 3;</code>
           */
          public Builder setAtraceMsg(
              perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.AtraceMessage.Builder builderForValue) {
            if (atraceMsgBuilder_ == null) {
              match_ = builderForValue.build();
              onChanged();
            } else {
              atraceMsgBuilder_.setMessage(builderForValue.build());
            }
            matchCase_ = 3;
            return this;
          }
          /**
           * <pre>
           * This rule matches if the "buf" field contains an atrace-style print
           * message as specified in `atrace_msg`.
           * </pre>
           *
           * <code>.perfetto.protos.FtraceConfig.PrintFilter.Rule.AtraceMessage atrace_msg = 3;</code>
           */
          public Builder mergeAtraceMsg(perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.AtraceMessage value) {
            if (atraceMsgBuilder_ == null) {
              if (matchCase_ == 3 &&
                  match_ != perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.AtraceMessage.getDefaultInstance()) {
                match_ = perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.AtraceMessage.newBuilder((perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.AtraceMessage) match_)
                    .mergeFrom(value).buildPartial();
              } else {
                match_ = value;
              }
              onChanged();
            } else {
              if (matchCase_ == 3) {
                atraceMsgBuilder_.mergeFrom(value);
              } else {
                atraceMsgBuilder_.setMessage(value);
              }
            }
            matchCase_ = 3;
            return this;
          }
          /**
           * <pre>
           * This rule matches if the "buf" field contains an atrace-style print
           * message as specified in `atrace_msg`.
           * </pre>
           *
           * <code>.perfetto.protos.FtraceConfig.PrintFilter.Rule.AtraceMessage atrace_msg = 3;</code>
           */
          public Builder clearAtraceMsg() {
            if (atraceMsgBuilder_ == null) {
              if (matchCase_ == 3) {
                matchCase_ = 0;
                match_ = null;
                onChanged();
              }
            } else {
              if (matchCase_ == 3) {
                matchCase_ = 0;
                match_ = null;
              }
              atraceMsgBuilder_.clear();
            }
            return this;
          }
          /**
           * <pre>
           * This rule matches if the "buf" field contains an atrace-style print
           * message as specified in `atrace_msg`.
           * </pre>
           *
           * <code>.perfetto.protos.FtraceConfig.PrintFilter.Rule.AtraceMessage atrace_msg = 3;</code>
           */
          public perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.AtraceMessage.Builder getAtraceMsgBuilder() {
            return getAtraceMsgFieldBuilder().getBuilder();
          }
          /**
           * <pre>
           * This rule matches if the "buf" field contains an atrace-style print
           * message as specified in `atrace_msg`.
           * </pre>
           *
           * <code>.perfetto.protos.FtraceConfig.PrintFilter.Rule.AtraceMessage atrace_msg = 3;</code>
           */
          @java.lang.Override
          public perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.AtraceMessageOrBuilder getAtraceMsgOrBuilder() {
            if ((matchCase_ == 3) && (atraceMsgBuilder_ != null)) {
              return atraceMsgBuilder_.getMessageOrBuilder();
            } else {
              if (matchCase_ == 3) {
                return (perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.AtraceMessage) match_;
              }
              return perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.AtraceMessage.getDefaultInstance();
            }
          }
          /**
           * <pre>
           * This rule matches if the "buf" field contains an atrace-style print
           * message as specified in `atrace_msg`.
           * </pre>
           *
           * <code>.perfetto.protos.FtraceConfig.PrintFilter.Rule.AtraceMessage atrace_msg = 3;</code>
           */
          private com.google.protobuf.SingleFieldBuilder<
              perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.AtraceMessage, perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.AtraceMessage.Builder, perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.AtraceMessageOrBuilder> 
              getAtraceMsgFieldBuilder() {
            if (atraceMsgBuilder_ == null) {
              if (!(matchCase_ == 3)) {
                match_ = perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.AtraceMessage.getDefaultInstance();
              }
              atraceMsgBuilder_ = new com.google.protobuf.SingleFieldBuilder<
                  perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.AtraceMessage, perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.AtraceMessage.Builder, perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.AtraceMessageOrBuilder>(
                      (perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.AtraceMessage) match_,
                      getParentForChildren(),
                      isClean());
              match_ = null;
            }
            matchCase_ = 3;
            onChanged();
            return atraceMsgBuilder_;
          }

          private boolean allow_ ;
          /**
           * <code>optional bool allow = 2;</code>
           * @return Whether the allow field is set.
           */
          @java.lang.Override
          public boolean hasAllow() {
            return ((bitField0_ & 0x00000004) != 0);
          }
          /**
           * <code>optional bool allow = 2;</code>
           * @return The allow.
           */
          @java.lang.Override
          public boolean getAllow() {
            return allow_;
          }
          /**
           * <code>optional bool allow = 2;</code>
           * @param value The allow to set.
           * @return This builder for chaining.
           */
          public Builder setAllow(boolean value) {

            allow_ = value;
            bitField0_ |= 0x00000004;
            onChanged();
            return this;
          }
          /**
           * <code>optional bool allow = 2;</code>
           * @return This builder for chaining.
           */
          public Builder clearAllow() {
            bitField0_ = (bitField0_ & ~0x00000004);
            allow_ = false;
            onChanged();
            return this;
          }

          // @@protoc_insertion_point(builder_scope:perfetto.protos.FtraceConfig.PrintFilter.Rule)
        }

        // @@protoc_insertion_point(class_scope:perfetto.protos.FtraceConfig.PrintFilter.Rule)
        private static final perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule DEFAULT_INSTANCE;
        static {
          DEFAULT_INSTANCE = new perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule();
        }

        public static perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule getDefaultInstance() {
          return DEFAULT_INSTANCE;
        }

        private static final com.google.protobuf.Parser<Rule>
            PARSER = new com.google.protobuf.AbstractParser<Rule>() {
          @java.lang.Override
          public Rule parsePartialFrom(
              com.google.protobuf.CodedInputStream input,
              com.google.protobuf.ExtensionRegistryLite extensionRegistry)
              throws com.google.protobuf.InvalidProtocolBufferException {
            Builder builder = newBuilder();
            try {
              builder.mergeFrom(input, extensionRegistry);
            } catch (com.google.protobuf.InvalidProtocolBufferException e) {
              throw e.setUnfinishedMessage(builder.buildPartial());
            } catch (com.google.protobuf.UninitializedMessageException e) {
              throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
            } catch (java.io.IOException e) {
              throw new com.google.protobuf.InvalidProtocolBufferException(e)
                  .setUnfinishedMessage(builder.buildPartial());
            }
            return builder.buildPartial();
          }
        };

        public static com.google.protobuf.Parser<Rule> parser() {
          return PARSER;
        }

        @java.lang.Override
        public com.google.protobuf.Parser<Rule> getParserForType() {
          return PARSER;
        }

        @java.lang.Override
        public perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule getDefaultInstanceForType() {
          return DEFAULT_INSTANCE;
        }

      }

      public static final int RULES_FIELD_NUMBER = 1;
      @SuppressWarnings("serial")
      private java.util.List<perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule> rules_;
      /**
       * <code>repeated .perfetto.protos.FtraceConfig.PrintFilter.Rule rules = 1;</code>
       */
      @java.lang.Override
      public java.util.List<perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule> getRulesList() {
        return rules_;
      }
      /**
       * <code>repeated .perfetto.protos.FtraceConfig.PrintFilter.Rule rules = 1;</code>
       */
      @java.lang.Override
      public java.util.List<? extends perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.RuleOrBuilder> 
          getRulesOrBuilderList() {
        return rules_;
      }
      /**
       * <code>repeated .perfetto.protos.FtraceConfig.PrintFilter.Rule rules = 1;</code>
       */
      @java.lang.Override
      public int getRulesCount() {
        return rules_.size();
      }
      /**
       * <code>repeated .perfetto.protos.FtraceConfig.PrintFilter.Rule rules = 1;</code>
       */
      @java.lang.Override
      public perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule getRules(int index) {
        return rules_.get(index);
      }
      /**
       * <code>repeated .perfetto.protos.FtraceConfig.PrintFilter.Rule rules = 1;</code>
       */
      @java.lang.Override
      public perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.RuleOrBuilder getRulesOrBuilder(
          int index) {
        return rules_.get(index);
      }

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        for (int i = 0; i < rules_.size(); i++) {
          output.writeMessage(1, rules_.get(i));
        }
        getUnknownFields().writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        for (int i = 0; i < rules_.size(); i++) {
          size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(1, rules_.get(i));
        }
        size += getUnknownFields().getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter)) {
          return super.equals(obj);
        }
        perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter other = (perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter) obj;

        if (!getRulesList()
            .equals(other.getRulesList())) return false;
        if (!getUnknownFields().equals(other.getUnknownFields())) return false;
        return true;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        if (getRulesCount() > 0) {
          hash = (37 * hash) + RULES_FIELD_NUMBER;
          hash = (53 * hash) + getRulesList().hashCode();
        }
        hash = (29 * hash) + getUnknownFields().hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input);
      }
      public static perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      public static perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseDelimitedWithIOException(PARSER, input);
      }

      public static perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input);
      }
      public static perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessage
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * <pre>
       * Optional filter for "ftrace/print" events.
       *
       * The filter consists of multiple rules. As soon as a rule matches (the rules
       * are processed in order), its `allow` field will be used as the outcome: if
       * `allow` is true, the event will be included in the trace, otherwise it will
       * be discarded. If an event does not match any rule, it will be allowed by
       * default (a rule with an empty prefix and allow=false, disallows everything
       * by default).
       * </pre>
       *
       * Protobuf type {@code perfetto.protos.FtraceConfig.PrintFilter}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessage.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:perfetto.protos.FtraceConfig.PrintFilter)
          perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilterOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return perfetto.protos.FtraceConfigOuterClass.internal_static_perfetto_protos_FtraceConfig_PrintFilter_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return perfetto.protos.FtraceConfigOuterClass.internal_static_perfetto_protos_FtraceConfig_PrintFilter_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.class, perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Builder.class);
        }

        // Construct using perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.newBuilder()
        private Builder() {

        }

        private Builder(
            com.google.protobuf.GeneratedMessage.BuilderParent parent) {
          super(parent);

        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          bitField0_ = 0;
          if (rulesBuilder_ == null) {
            rules_ = java.util.Collections.emptyList();
          } else {
            rules_ = null;
            rulesBuilder_.clear();
          }
          bitField0_ = (bitField0_ & ~0x00000001);
          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return perfetto.protos.FtraceConfigOuterClass.internal_static_perfetto_protos_FtraceConfig_PrintFilter_descriptor;
        }

        @java.lang.Override
        public perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter getDefaultInstanceForType() {
          return perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.getDefaultInstance();
        }

        @java.lang.Override
        public perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter build() {
          perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter buildPartial() {
          perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter result = new perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter(this);
          buildPartialRepeatedFields(result);
          if (bitField0_ != 0) { buildPartial0(result); }
          onBuilt();
          return result;
        }

        private void buildPartialRepeatedFields(perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter result) {
          if (rulesBuilder_ == null) {
            if (((bitField0_ & 0x00000001) != 0)) {
              rules_ = java.util.Collections.unmodifiableList(rules_);
              bitField0_ = (bitField0_ & ~0x00000001);
            }
            result.rules_ = rules_;
          } else {
            result.rules_ = rulesBuilder_.build();
          }
        }

        private void buildPartial0(perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter result) {
          int from_bitField0_ = bitField0_;
        }

        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter) {
            return mergeFrom((perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter other) {
          if (other == perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.getDefaultInstance()) return this;
          if (rulesBuilder_ == null) {
            if (!other.rules_.isEmpty()) {
              if (rules_.isEmpty()) {
                rules_ = other.rules_;
                bitField0_ = (bitField0_ & ~0x00000001);
              } else {
                ensureRulesIsMutable();
                rules_.addAll(other.rules_);
              }
              onChanged();
            }
          } else {
            if (!other.rules_.isEmpty()) {
              if (rulesBuilder_.isEmpty()) {
                rulesBuilder_.dispose();
                rulesBuilder_ = null;
                rules_ = other.rules_;
                bitField0_ = (bitField0_ & ~0x00000001);
                rulesBuilder_ = 
                  com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                     getRulesFieldBuilder() : null;
              } else {
                rulesBuilder_.addAllMessages(other.rules_);
              }
            }
          }
          this.mergeUnknownFields(other.getUnknownFields());
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          if (extensionRegistry == null) {
            throw new java.lang.NullPointerException();
          }
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                case 10: {
                  perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule m =
                      input.readMessage(
                          perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.parser(),
                          extensionRegistry);
                  if (rulesBuilder_ == null) {
                    ensureRulesIsMutable();
                    rules_.add(m);
                  } else {
                    rulesBuilder_.addMessage(m);
                  }
                  break;
                } // case 10
                default: {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
              } // switch (tag)
            } // while (!done)
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.unwrapIOException();
          } finally {
            onChanged();
          } // finally
          return this;
        }
        private int bitField0_;

        private java.util.List<perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule> rules_ =
          java.util.Collections.emptyList();
        private void ensureRulesIsMutable() {
          if (!((bitField0_ & 0x00000001) != 0)) {
            rules_ = new java.util.ArrayList<perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule>(rules_);
            bitField0_ |= 0x00000001;
           }
        }

        private com.google.protobuf.RepeatedFieldBuilder<
            perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule, perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.Builder, perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.RuleOrBuilder> rulesBuilder_;

        /**
         * <code>repeated .perfetto.protos.FtraceConfig.PrintFilter.Rule rules = 1;</code>
         */
        public java.util.List<perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule> getRulesList() {
          if (rulesBuilder_ == null) {
            return java.util.Collections.unmodifiableList(rules_);
          } else {
            return rulesBuilder_.getMessageList();
          }
        }
        /**
         * <code>repeated .perfetto.protos.FtraceConfig.PrintFilter.Rule rules = 1;</code>
         */
        public int getRulesCount() {
          if (rulesBuilder_ == null) {
            return rules_.size();
          } else {
            return rulesBuilder_.getCount();
          }
        }
        /**
         * <code>repeated .perfetto.protos.FtraceConfig.PrintFilter.Rule rules = 1;</code>
         */
        public perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule getRules(int index) {
          if (rulesBuilder_ == null) {
            return rules_.get(index);
          } else {
            return rulesBuilder_.getMessage(index);
          }
        }
        /**
         * <code>repeated .perfetto.protos.FtraceConfig.PrintFilter.Rule rules = 1;</code>
         */
        public Builder setRules(
            int index, perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule value) {
          if (rulesBuilder_ == null) {
            if (value == null) {
              throw new NullPointerException();
            }
            ensureRulesIsMutable();
            rules_.set(index, value);
            onChanged();
          } else {
            rulesBuilder_.setMessage(index, value);
          }
          return this;
        }
        /**
         * <code>repeated .perfetto.protos.FtraceConfig.PrintFilter.Rule rules = 1;</code>
         */
        public Builder setRules(
            int index, perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.Builder builderForValue) {
          if (rulesBuilder_ == null) {
            ensureRulesIsMutable();
            rules_.set(index, builderForValue.build());
            onChanged();
          } else {
            rulesBuilder_.setMessage(index, builderForValue.build());
          }
          return this;
        }
        /**
         * <code>repeated .perfetto.protos.FtraceConfig.PrintFilter.Rule rules = 1;</code>
         */
        public Builder addRules(perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule value) {
          if (rulesBuilder_ == null) {
            if (value == null) {
              throw new NullPointerException();
            }
            ensureRulesIsMutable();
            rules_.add(value);
            onChanged();
          } else {
            rulesBuilder_.addMessage(value);
          }
          return this;
        }
        /**
         * <code>repeated .perfetto.protos.FtraceConfig.PrintFilter.Rule rules = 1;</code>
         */
        public Builder addRules(
            int index, perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule value) {
          if (rulesBuilder_ == null) {
            if (value == null) {
              throw new NullPointerException();
            }
            ensureRulesIsMutable();
            rules_.add(index, value);
            onChanged();
          } else {
            rulesBuilder_.addMessage(index, value);
          }
          return this;
        }
        /**
         * <code>repeated .perfetto.protos.FtraceConfig.PrintFilter.Rule rules = 1;</code>
         */
        public Builder addRules(
            perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.Builder builderForValue) {
          if (rulesBuilder_ == null) {
            ensureRulesIsMutable();
            rules_.add(builderForValue.build());
            onChanged();
          } else {
            rulesBuilder_.addMessage(builderForValue.build());
          }
          return this;
        }
        /**
         * <code>repeated .perfetto.protos.FtraceConfig.PrintFilter.Rule rules = 1;</code>
         */
        public Builder addRules(
            int index, perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.Builder builderForValue) {
          if (rulesBuilder_ == null) {
            ensureRulesIsMutable();
            rules_.add(index, builderForValue.build());
            onChanged();
          } else {
            rulesBuilder_.addMessage(index, builderForValue.build());
          }
          return this;
        }
        /**
         * <code>repeated .perfetto.protos.FtraceConfig.PrintFilter.Rule rules = 1;</code>
         */
        public Builder addAllRules(
            java.lang.Iterable<? extends perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule> values) {
          if (rulesBuilder_ == null) {
            ensureRulesIsMutable();
            com.google.protobuf.AbstractMessageLite.Builder.addAll(
                values, rules_);
            onChanged();
          } else {
            rulesBuilder_.addAllMessages(values);
          }
          return this;
        }
        /**
         * <code>repeated .perfetto.protos.FtraceConfig.PrintFilter.Rule rules = 1;</code>
         */
        public Builder clearRules() {
          if (rulesBuilder_ == null) {
            rules_ = java.util.Collections.emptyList();
            bitField0_ = (bitField0_ & ~0x00000001);
            onChanged();
          } else {
            rulesBuilder_.clear();
          }
          return this;
        }
        /**
         * <code>repeated .perfetto.protos.FtraceConfig.PrintFilter.Rule rules = 1;</code>
         */
        public Builder removeRules(int index) {
          if (rulesBuilder_ == null) {
            ensureRulesIsMutable();
            rules_.remove(index);
            onChanged();
          } else {
            rulesBuilder_.remove(index);
          }
          return this;
        }
        /**
         * <code>repeated .perfetto.protos.FtraceConfig.PrintFilter.Rule rules = 1;</code>
         */
        public perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.Builder getRulesBuilder(
            int index) {
          return getRulesFieldBuilder().getBuilder(index);
        }
        /**
         * <code>repeated .perfetto.protos.FtraceConfig.PrintFilter.Rule rules = 1;</code>
         */
        public perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.RuleOrBuilder getRulesOrBuilder(
            int index) {
          if (rulesBuilder_ == null) {
            return rules_.get(index);  } else {
            return rulesBuilder_.getMessageOrBuilder(index);
          }
        }
        /**
         * <code>repeated .perfetto.protos.FtraceConfig.PrintFilter.Rule rules = 1;</code>
         */
        public java.util.List<? extends perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.RuleOrBuilder> 
             getRulesOrBuilderList() {
          if (rulesBuilder_ != null) {
            return rulesBuilder_.getMessageOrBuilderList();
          } else {
            return java.util.Collections.unmodifiableList(rules_);
          }
        }
        /**
         * <code>repeated .perfetto.protos.FtraceConfig.PrintFilter.Rule rules = 1;</code>
         */
        public perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.Builder addRulesBuilder() {
          return getRulesFieldBuilder().addBuilder(
              perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.getDefaultInstance());
        }
        /**
         * <code>repeated .perfetto.protos.FtraceConfig.PrintFilter.Rule rules = 1;</code>
         */
        public perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.Builder addRulesBuilder(
            int index) {
          return getRulesFieldBuilder().addBuilder(
              index, perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.getDefaultInstance());
        }
        /**
         * <code>repeated .perfetto.protos.FtraceConfig.PrintFilter.Rule rules = 1;</code>
         */
        public java.util.List<perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.Builder> 
             getRulesBuilderList() {
          return getRulesFieldBuilder().getBuilderList();
        }
        private com.google.protobuf.RepeatedFieldBuilder<
            perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule, perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.Builder, perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.RuleOrBuilder> 
            getRulesFieldBuilder() {
          if (rulesBuilder_ == null) {
            rulesBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
                perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule, perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Rule.Builder, perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.RuleOrBuilder>(
                    rules_,
                    ((bitField0_ & 0x00000001) != 0),
                    getParentForChildren(),
                    isClean());
            rules_ = null;
          }
          return rulesBuilder_;
        }

        // @@protoc_insertion_point(builder_scope:perfetto.protos.FtraceConfig.PrintFilter)
      }

      // @@protoc_insertion_point(class_scope:perfetto.protos.FtraceConfig.PrintFilter)
      private static final perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter();
      }

      public static perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      private static final com.google.protobuf.Parser<PrintFilter>
          PARSER = new com.google.protobuf.AbstractParser<PrintFilter>() {
        @java.lang.Override
        public PrintFilter parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          Builder builder = newBuilder();
          try {
            builder.mergeFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.setUnfinishedMessage(builder.buildPartial());
          } catch (com.google.protobuf.UninitializedMessageException e) {
            throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
          } catch (java.io.IOException e) {
            throw new com.google.protobuf.InvalidProtocolBufferException(e)
                .setUnfinishedMessage(builder.buildPartial());
          }
          return builder.buildPartial();
        }
      };

      public static com.google.protobuf.Parser<PrintFilter> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<PrintFilter> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    private int bitField0_;
    public static final int FTRACE_EVENTS_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private com.google.protobuf.LazyStringArrayList ftraceEvents_ =
        com.google.protobuf.LazyStringArrayList.emptyList();
    /**
     * <pre>
     * Ftrace events to record, example: "sched/sched_switch".
     * </pre>
     *
     * <code>repeated string ftrace_events = 1;</code>
     * @return A list containing the ftraceEvents.
     */
    public com.google.protobuf.ProtocolStringList
        getFtraceEventsList() {
      return ftraceEvents_;
    }
    /**
     * <pre>
     * Ftrace events to record, example: "sched/sched_switch".
     * </pre>
     *
     * <code>repeated string ftrace_events = 1;</code>
     * @return The count of ftraceEvents.
     */
    public int getFtraceEventsCount() {
      return ftraceEvents_.size();
    }
    /**
     * <pre>
     * Ftrace events to record, example: "sched/sched_switch".
     * </pre>
     *
     * <code>repeated string ftrace_events = 1;</code>
     * @param index The index of the element to return.
     * @return The ftraceEvents at the given index.
     */
    public java.lang.String getFtraceEvents(int index) {
      return ftraceEvents_.get(index);
    }
    /**
     * <pre>
     * Ftrace events to record, example: "sched/sched_switch".
     * </pre>
     *
     * <code>repeated string ftrace_events = 1;</code>
     * @param index The index of the value to return.
     * @return The bytes of the ftraceEvents at the given index.
     */
    public com.google.protobuf.ByteString
        getFtraceEventsBytes(int index) {
      return ftraceEvents_.getByteString(index);
    }

    public static final int ATRACE_CATEGORIES_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private com.google.protobuf.LazyStringArrayList atraceCategories_ =
        com.google.protobuf.LazyStringArrayList.emptyList();
    /**
     * <pre>
     * Android-specific event categories:
     * </pre>
     *
     * <code>repeated string atrace_categories = 2;</code>
     * @return A list containing the atraceCategories.
     */
    public com.google.protobuf.ProtocolStringList
        getAtraceCategoriesList() {
      return atraceCategories_;
    }
    /**
     * <pre>
     * Android-specific event categories:
     * </pre>
     *
     * <code>repeated string atrace_categories = 2;</code>
     * @return The count of atraceCategories.
     */
    public int getAtraceCategoriesCount() {
      return atraceCategories_.size();
    }
    /**
     * <pre>
     * Android-specific event categories:
     * </pre>
     *
     * <code>repeated string atrace_categories = 2;</code>
     * @param index The index of the element to return.
     * @return The atraceCategories at the given index.
     */
    public java.lang.String getAtraceCategories(int index) {
      return atraceCategories_.get(index);
    }
    /**
     * <pre>
     * Android-specific event categories:
     * </pre>
     *
     * <code>repeated string atrace_categories = 2;</code>
     * @param index The index of the value to return.
     * @return The bytes of the atraceCategories at the given index.
     */
    public com.google.protobuf.ByteString
        getAtraceCategoriesBytes(int index) {
      return atraceCategories_.getByteString(index);
    }

    public static final int ATRACE_APPS_FIELD_NUMBER = 3;
    @SuppressWarnings("serial")
    private com.google.protobuf.LazyStringArrayList atraceApps_ =
        com.google.protobuf.LazyStringArrayList.emptyList();
    /**
     * <code>repeated string atrace_apps = 3;</code>
     * @return A list containing the atraceApps.
     */
    public com.google.protobuf.ProtocolStringList
        getAtraceAppsList() {
      return atraceApps_;
    }
    /**
     * <code>repeated string atrace_apps = 3;</code>
     * @return The count of atraceApps.
     */
    public int getAtraceAppsCount() {
      return atraceApps_.size();
    }
    /**
     * <code>repeated string atrace_apps = 3;</code>
     * @param index The index of the element to return.
     * @return The atraceApps at the given index.
     */
    public java.lang.String getAtraceApps(int index) {
      return atraceApps_.get(index);
    }
    /**
     * <code>repeated string atrace_apps = 3;</code>
     * @param index The index of the value to return.
     * @return The bytes of the atraceApps at the given index.
     */
    public com.google.protobuf.ByteString
        getAtraceAppsBytes(int index) {
      return atraceApps_.getByteString(index);
    }

    public static final int ATRACE_CATEGORIES_PREFER_SDK_FIELD_NUMBER = 28;
    @SuppressWarnings("serial")
    private com.google.protobuf.LazyStringArrayList atraceCategoriesPreferSdk_ =
        com.google.protobuf.LazyStringArrayList.emptyList();
    /**
     * <pre>
     * Some processes can emit data through atrace or through the perfetto SDK via
     * the "track_event" data source. For these categories, the SDK will be
     * preferred, if possible, for this config.
     * </pre>
     *
     * <code>repeated string atrace_categories_prefer_sdk = 28;</code>
     * @return A list containing the atraceCategoriesPreferSdk.
     */
    public com.google.protobuf.ProtocolStringList
        getAtraceCategoriesPreferSdkList() {
      return atraceCategoriesPreferSdk_;
    }
    /**
     * <pre>
     * Some processes can emit data through atrace or through the perfetto SDK via
     * the "track_event" data source. For these categories, the SDK will be
     * preferred, if possible, for this config.
     * </pre>
     *
     * <code>repeated string atrace_categories_prefer_sdk = 28;</code>
     * @return The count of atraceCategoriesPreferSdk.
     */
    public int getAtraceCategoriesPreferSdkCount() {
      return atraceCategoriesPreferSdk_.size();
    }
    /**
     * <pre>
     * Some processes can emit data through atrace or through the perfetto SDK via
     * the "track_event" data source. For these categories, the SDK will be
     * preferred, if possible, for this config.
     * </pre>
     *
     * <code>repeated string atrace_categories_prefer_sdk = 28;</code>
     * @param index The index of the element to return.
     * @return The atraceCategoriesPreferSdk at the given index.
     */
    public java.lang.String getAtraceCategoriesPreferSdk(int index) {
      return atraceCategoriesPreferSdk_.get(index);
    }
    /**
     * <pre>
     * Some processes can emit data through atrace or through the perfetto SDK via
     * the "track_event" data source. For these categories, the SDK will be
     * preferred, if possible, for this config.
     * </pre>
     *
     * <code>repeated string atrace_categories_prefer_sdk = 28;</code>
     * @param index The index of the value to return.
     * @return The bytes of the atraceCategoriesPreferSdk at the given index.
     */
    public com.google.protobuf.ByteString
        getAtraceCategoriesPreferSdkBytes(int index) {
      return atraceCategoriesPreferSdk_.getByteString(index);
    }

    public static final int BUFFER_SIZE_KB_FIELD_NUMBER = 10;
    private int bufferSizeKb_ = 0;
    /**
     * <pre>
     * Size of each per-cpu kernel ftrace ring buffer.
     * Not guaranteed if there are multiple concurrent tracing sessions, as the
     * buffers cannot be resized without pausing recording in the kernel.
     * </pre>
     *
     * <code>optional uint32 buffer_size_kb = 10;</code>
     * @return Whether the bufferSizeKb field is set.
     */
    @java.lang.Override
    public boolean hasBufferSizeKb() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Size of each per-cpu kernel ftrace ring buffer.
     * Not guaranteed if there are multiple concurrent tracing sessions, as the
     * buffers cannot be resized without pausing recording in the kernel.
     * </pre>
     *
     * <code>optional uint32 buffer_size_kb = 10;</code>
     * @return The bufferSizeKb.
     */
    @java.lang.Override
    public int getBufferSizeKb() {
      return bufferSizeKb_;
    }

    public static final int DRAIN_PERIOD_MS_FIELD_NUMBER = 11;
    private int drainPeriodMs_ = 0;
    /**
     * <pre>
     * If set, specifies how often the tracing daemon reads from the kernel ring
     * buffer. Not guaranteed if there are multiple concurrent tracing sessions.
     * Leave unset unless you're fine-tuning a local config.
     * </pre>
     *
     * <code>optional uint32 drain_period_ms = 11;</code>
     * @return Whether the drainPeriodMs field is set.
     */
    @java.lang.Override
    public boolean hasDrainPeriodMs() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * If set, specifies how often the tracing daemon reads from the kernel ring
     * buffer. Not guaranteed if there are multiple concurrent tracing sessions.
     * Leave unset unless you're fine-tuning a local config.
     * </pre>
     *
     * <code>optional uint32 drain_period_ms = 11;</code>
     * @return The drainPeriodMs.
     */
    @java.lang.Override
    public int getDrainPeriodMs() {
      return drainPeriodMs_;
    }

    public static final int DRAIN_BUFFER_PERCENT_FIELD_NUMBER = 29;
    private int drainBufferPercent_ = 0;
    /**
     * <pre>
     * If set, the tracing daemon will read kernel ring buffers as soon as
     * they're filled past this percentage of occupancy. In other words, a value
     * of 50 means that a read pass is triggered as soon as any per-cpu buffer is
     * half-full. Not guaranteed if there are multiple concurrent tracing
     * sessions.
     * Currently does nothing on Linux kernels below v6.9.
     * Introduced in: perfetto v48.
     * </pre>
     *
     * <code>optional uint32 drain_buffer_percent = 29;</code>
     * @return Whether the drainBufferPercent field is set.
     */
    @java.lang.Override
    public boolean hasDrainBufferPercent() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * If set, the tracing daemon will read kernel ring buffers as soon as
     * they're filled past this percentage of occupancy. In other words, a value
     * of 50 means that a read pass is triggered as soon as any per-cpu buffer is
     * half-full. Not guaranteed if there are multiple concurrent tracing
     * sessions.
     * Currently does nothing on Linux kernels below v6.9.
     * Introduced in: perfetto v48.
     * </pre>
     *
     * <code>optional uint32 drain_buffer_percent = 29;</code>
     * @return The drainBufferPercent.
     */
    @java.lang.Override
    public int getDrainBufferPercent() {
      return drainBufferPercent_;
    }

    public static final int COMPACT_SCHED_FIELD_NUMBER = 12;
    private perfetto.protos.FtraceConfigOuterClass.FtraceConfig.CompactSchedConfig compactSched_;
    /**
     * <code>optional .perfetto.protos.FtraceConfig.CompactSchedConfig compact_sched = 12;</code>
     * @return Whether the compactSched field is set.
     */
    @java.lang.Override
    public boolean hasCompactSched() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <code>optional .perfetto.protos.FtraceConfig.CompactSchedConfig compact_sched = 12;</code>
     * @return The compactSched.
     */
    @java.lang.Override
    public perfetto.protos.FtraceConfigOuterClass.FtraceConfig.CompactSchedConfig getCompactSched() {
      return compactSched_ == null ? perfetto.protos.FtraceConfigOuterClass.FtraceConfig.CompactSchedConfig.getDefaultInstance() : compactSched_;
    }
    /**
     * <code>optional .perfetto.protos.FtraceConfig.CompactSchedConfig compact_sched = 12;</code>
     */
    @java.lang.Override
    public perfetto.protos.FtraceConfigOuterClass.FtraceConfig.CompactSchedConfigOrBuilder getCompactSchedOrBuilder() {
      return compactSched_ == null ? perfetto.protos.FtraceConfigOuterClass.FtraceConfig.CompactSchedConfig.getDefaultInstance() : compactSched_;
    }

    public static final int PRINT_FILTER_FIELD_NUMBER = 22;
    private perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter printFilter_;
    /**
     * <code>optional .perfetto.protos.FtraceConfig.PrintFilter print_filter = 22;</code>
     * @return Whether the printFilter field is set.
     */
    @java.lang.Override
    public boolean hasPrintFilter() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <code>optional .perfetto.protos.FtraceConfig.PrintFilter print_filter = 22;</code>
     * @return The printFilter.
     */
    @java.lang.Override
    public perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter getPrintFilter() {
      return printFilter_ == null ? perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.getDefaultInstance() : printFilter_;
    }
    /**
     * <code>optional .perfetto.protos.FtraceConfig.PrintFilter print_filter = 22;</code>
     */
    @java.lang.Override
    public perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilterOrBuilder getPrintFilterOrBuilder() {
      return printFilter_ == null ? perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.getDefaultInstance() : printFilter_;
    }

    public static final int SYMBOLIZE_KSYMS_FIELD_NUMBER = 13;
    private boolean symbolizeKsyms_ = false;
    /**
     * <pre>
     * Enables symbol name resolution against /proc/kallsyms.
     * It requires that either traced_probes is running as root or that
     * kptr_restrict has been manually lowered.
     * It does not disclose KASLR, symbol addresses are mangled.
     * </pre>
     *
     * <code>optional bool symbolize_ksyms = 13;</code>
     * @return Whether the symbolizeKsyms field is set.
     */
    @java.lang.Override
    public boolean hasSymbolizeKsyms() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * Enables symbol name resolution against /proc/kallsyms.
     * It requires that either traced_probes is running as root or that
     * kptr_restrict has been manually lowered.
     * It does not disclose KASLR, symbol addresses are mangled.
     * </pre>
     *
     * <code>optional bool symbolize_ksyms = 13;</code>
     * @return The symbolizeKsyms.
     */
    @java.lang.Override
    public boolean getSymbolizeKsyms() {
      return symbolizeKsyms_;
    }

    public static final int KSYMS_MEM_POLICY_FIELD_NUMBER = 17;
    private int ksymsMemPolicy_ = 0;
    /**
     * <code>optional .perfetto.protos.FtraceConfig.KsymsMemPolicy ksyms_mem_policy = 17;</code>
     * @return Whether the ksymsMemPolicy field is set.
     */
    @java.lang.Override public boolean hasKsymsMemPolicy() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <code>optional .perfetto.protos.FtraceConfig.KsymsMemPolicy ksyms_mem_policy = 17;</code>
     * @return The ksymsMemPolicy.
     */
    @java.lang.Override public perfetto.protos.FtraceConfigOuterClass.FtraceConfig.KsymsMemPolicy getKsymsMemPolicy() {
      perfetto.protos.FtraceConfigOuterClass.FtraceConfig.KsymsMemPolicy result = perfetto.protos.FtraceConfigOuterClass.FtraceConfig.KsymsMemPolicy.forNumber(ksymsMemPolicy_);
      return result == null ? perfetto.protos.FtraceConfigOuterClass.FtraceConfig.KsymsMemPolicy.KSYMS_UNSPECIFIED : result;
    }

    public static final int INITIALIZE_KSYMS_SYNCHRONOUSLY_FOR_TESTING_FIELD_NUMBER = 14;
    private boolean initializeKsymsSynchronouslyForTesting_ = false;
    /**
     * <pre>
     * By default the kernel symbolizer is lazily initialized on a deferred task
     * to reduce ftrace's time-to-start-recording. Unfortunately that makes
     * ksyms integration tests hard. This flag forces the kernel symbolizer to be
     * initialized synchronously on the data source start and hence avoiding
     * timing races in tests.
     * DEPRECATED in v28 / Android U. This is now the default behavior, setting it
     * to true is a no-op.
     * </pre>
     *
     * <code>optional bool initialize_ksyms_synchronously_for_testing = 14 [deprecated = true];</code>
     * @deprecated perfetto.protos.FtraceConfig.initialize_ksyms_synchronously_for_testing is deprecated.
     *     See protos/perfetto/config/ftrace/ftrace_config.proto;l=123
     * @return Whether the initializeKsymsSynchronouslyForTesting field is set.
     */
    @java.lang.Override
    @java.lang.Deprecated public boolean hasInitializeKsymsSynchronouslyForTesting() {
      return ((bitField0_ & 0x00000080) != 0);
    }
    /**
     * <pre>
     * By default the kernel symbolizer is lazily initialized on a deferred task
     * to reduce ftrace's time-to-start-recording. Unfortunately that makes
     * ksyms integration tests hard. This flag forces the kernel symbolizer to be
     * initialized synchronously on the data source start and hence avoiding
     * timing races in tests.
     * DEPRECATED in v28 / Android U. This is now the default behavior, setting it
     * to true is a no-op.
     * </pre>
     *
     * <code>optional bool initialize_ksyms_synchronously_for_testing = 14 [deprecated = true];</code>
     * @deprecated perfetto.protos.FtraceConfig.initialize_ksyms_synchronously_for_testing is deprecated.
     *     See protos/perfetto/config/ftrace/ftrace_config.proto;l=123
     * @return The initializeKsymsSynchronouslyForTesting.
     */
    @java.lang.Override
    @java.lang.Deprecated public boolean getInitializeKsymsSynchronouslyForTesting() {
      return initializeKsymsSynchronouslyForTesting_;
    }

    public static final int THROTTLE_RSS_STAT_FIELD_NUMBER = 15;
    private boolean throttleRssStat_ = false;
    /**
     * <pre>
     * When this boolean is true AND the ftrace_events contains "kmem/rss_stat",
     * this option causes traced_probes to enable the "kmem/rss_stat_throttled"
     * event instead if present, and fall back to "kmem/rss_stat" if not present.
     * The historical context for this is the following:
     * - Up to Android S (12), the rss_stat was internally throttled in its
     * kernel implementation.
     * - A change introduced in the kernels after S has introduced a new
     * "rss_stat_throttled" making the original "rss_stat" event unthrottled
     * (hence very spammy).
     * - Not all Android T/13 devices will receive a new kernel though, hence we
     * need to deal with both cases.
     * For more context: go/rss-stat-throttled.
     * </pre>
     *
     * <code>optional bool throttle_rss_stat = 15;</code>
     * @return Whether the throttleRssStat field is set.
     */
    @java.lang.Override
    public boolean hasThrottleRssStat() {
      return ((bitField0_ & 0x00000100) != 0);
    }
    /**
     * <pre>
     * When this boolean is true AND the ftrace_events contains "kmem/rss_stat",
     * this option causes traced_probes to enable the "kmem/rss_stat_throttled"
     * event instead if present, and fall back to "kmem/rss_stat" if not present.
     * The historical context for this is the following:
     * - Up to Android S (12), the rss_stat was internally throttled in its
     * kernel implementation.
     * - A change introduced in the kernels after S has introduced a new
     * "rss_stat_throttled" making the original "rss_stat" event unthrottled
     * (hence very spammy).
     * - Not all Android T/13 devices will receive a new kernel though, hence we
     * need to deal with both cases.
     * For more context: go/rss-stat-throttled.
     * </pre>
     *
     * <code>optional bool throttle_rss_stat = 15;</code>
     * @return The throttleRssStat.
     */
    @java.lang.Override
    public boolean getThrottleRssStat() {
      return throttleRssStat_;
    }

    public static final int DISABLE_GENERIC_EVENTS_FIELD_NUMBER = 16;
    private boolean disableGenericEvents_ = false;
    /**
     * <pre>
     * If true, avoid enabling events that aren't statically known by
     * traced_probes. Otherwise, the default is to emit such events as
     * GenericFtraceEvent protos.
     * Prefer to keep this flag at its default. This was added for Android
     * tracing, where atrace categories and/or atrace HAL requested events can
     * expand to events that aren't of interest to the tracing user.
     * Introduced in: Android T.
     * </pre>
     *
     * <code>optional bool disable_generic_events = 16;</code>
     * @return Whether the disableGenericEvents field is set.
     */
    @java.lang.Override
    public boolean hasDisableGenericEvents() {
      return ((bitField0_ & 0x00000200) != 0);
    }
    /**
     * <pre>
     * If true, avoid enabling events that aren't statically known by
     * traced_probes. Otherwise, the default is to emit such events as
     * GenericFtraceEvent protos.
     * Prefer to keep this flag at its default. This was added for Android
     * tracing, where atrace categories and/or atrace HAL requested events can
     * expand to events that aren't of interest to the tracing user.
     * Introduced in: Android T.
     * </pre>
     *
     * <code>optional bool disable_generic_events = 16;</code>
     * @return The disableGenericEvents.
     */
    @java.lang.Override
    public boolean getDisableGenericEvents() {
      return disableGenericEvents_;
    }

    public static final int SYSCALL_EVENTS_FIELD_NUMBER = 18;
    @SuppressWarnings("serial")
    private com.google.protobuf.LazyStringArrayList syscallEvents_ =
        com.google.protobuf.LazyStringArrayList.emptyList();
    /**
     * <pre>
     * The subset of syscalls to record. To record all syscalls, leave this unset
     * and add "ftrace_events: raw_syscalls/sys_{enter,exit}" to the config.
     * * before perfetto v43, requires the config to also enable
     * raw_syscalls/sys_{enter,exit}.
     * * perfetto v43+ does the right thing if you set only this field.
     * Example: ["sys_read", "sys_open"].
     * Introduced in: Android U.
     * </pre>
     *
     * <code>repeated string syscall_events = 18;</code>
     * @return A list containing the syscallEvents.
     */
    public com.google.protobuf.ProtocolStringList
        getSyscallEventsList() {
      return syscallEvents_;
    }
    /**
     * <pre>
     * The subset of syscalls to record. To record all syscalls, leave this unset
     * and add "ftrace_events: raw_syscalls/sys_{enter,exit}" to the config.
     * * before perfetto v43, requires the config to also enable
     * raw_syscalls/sys_{enter,exit}.
     * * perfetto v43+ does the right thing if you set only this field.
     * Example: ["sys_read", "sys_open"].
     * Introduced in: Android U.
     * </pre>
     *
     * <code>repeated string syscall_events = 18;</code>
     * @return The count of syscallEvents.
     */
    public int getSyscallEventsCount() {
      return syscallEvents_.size();
    }
    /**
     * <pre>
     * The subset of syscalls to record. To record all syscalls, leave this unset
     * and add "ftrace_events: raw_syscalls/sys_{enter,exit}" to the config.
     * * before perfetto v43, requires the config to also enable
     * raw_syscalls/sys_{enter,exit}.
     * * perfetto v43+ does the right thing if you set only this field.
     * Example: ["sys_read", "sys_open"].
     * Introduced in: Android U.
     * </pre>
     *
     * <code>repeated string syscall_events = 18;</code>
     * @param index The index of the element to return.
     * @return The syscallEvents at the given index.
     */
    public java.lang.String getSyscallEvents(int index) {
      return syscallEvents_.get(index);
    }
    /**
     * <pre>
     * The subset of syscalls to record. To record all syscalls, leave this unset
     * and add "ftrace_events: raw_syscalls/sys_{enter,exit}" to the config.
     * * before perfetto v43, requires the config to also enable
     * raw_syscalls/sys_{enter,exit}.
     * * perfetto v43+ does the right thing if you set only this field.
     * Example: ["sys_read", "sys_open"].
     * Introduced in: Android U.
     * </pre>
     *
     * <code>repeated string syscall_events = 18;</code>
     * @param index The index of the value to return.
     * @return The bytes of the syscallEvents at the given index.
     */
    public com.google.protobuf.ByteString
        getSyscallEventsBytes(int index) {
      return syscallEvents_.getByteString(index);
    }

    public static final int ENABLE_FUNCTION_GRAPH_FIELD_NUMBER = 19;
    private boolean enableFunctionGraph_ = false;
    /**
     * <pre>
     * If true, enable the "function_graph" kernel tracer that emits events
     * whenever a kernel function is entered and exited
     * (funcgraph_entry/funcgraph_exit).
     * Notes on use:
     * * Requires |symbolize_ksyms| for function name resolution.
     * * Use |function_filters| or |function_graph_roots| to constrain the traced
     * set of functions, otherwise the event bandwidth will be too high for
     * practical use.
     * * The data source might be rejected if there is already a concurrent
     * ftrace data source that does not use function graph itself, as we do not
     * support switching kernel tracers mid-trace.
     * * Requires a kernel compiled with CONFIG_FUNCTION_GRAPH_TRACER. This is
     * enabled if "cat /sys/kernel/tracing/available_tracers" includes
     * "function_graph".
     * Android:
     * * Available only on debuggable builds.
     * * Introduced in: Android U.
     * </pre>
     *
     * <code>optional bool enable_function_graph = 19;</code>
     * @return Whether the enableFunctionGraph field is set.
     */
    @java.lang.Override
    public boolean hasEnableFunctionGraph() {
      return ((bitField0_ & 0x00000400) != 0);
    }
    /**
     * <pre>
     * If true, enable the "function_graph" kernel tracer that emits events
     * whenever a kernel function is entered and exited
     * (funcgraph_entry/funcgraph_exit).
     * Notes on use:
     * * Requires |symbolize_ksyms| for function name resolution.
     * * Use |function_filters| or |function_graph_roots| to constrain the traced
     * set of functions, otherwise the event bandwidth will be too high for
     * practical use.
     * * The data source might be rejected if there is already a concurrent
     * ftrace data source that does not use function graph itself, as we do not
     * support switching kernel tracers mid-trace.
     * * Requires a kernel compiled with CONFIG_FUNCTION_GRAPH_TRACER. This is
     * enabled if "cat /sys/kernel/tracing/available_tracers" includes
     * "function_graph".
     * Android:
     * * Available only on debuggable builds.
     * * Introduced in: Android U.
     * </pre>
     *
     * <code>optional bool enable_function_graph = 19;</code>
     * @return The enableFunctionGraph.
     */
    @java.lang.Override
    public boolean getEnableFunctionGraph() {
      return enableFunctionGraph_;
    }

    public static final int FUNCTION_FILTERS_FIELD_NUMBER = 20;
    @SuppressWarnings("serial")
    private com.google.protobuf.LazyStringArrayList functionFilters_ =
        com.google.protobuf.LazyStringArrayList.emptyList();
    /**
     * <pre>
     * Constrains the set of functions traced when |enable_function_graph| is
     * true. Supports globs, e.g. "sched*". You can specify multiple filters,
     * in which case all matching functions will be traced. See kernel
     * documentation on ftrace "set_ftrace_filter" file for more details.
     * Android:
     * * Available only on debuggable builds.
     * * Introduced in: Android U.
     * </pre>
     *
     * <code>repeated string function_filters = 20;</code>
     * @return A list containing the functionFilters.
     */
    public com.google.protobuf.ProtocolStringList
        getFunctionFiltersList() {
      return functionFilters_;
    }
    /**
     * <pre>
     * Constrains the set of functions traced when |enable_function_graph| is
     * true. Supports globs, e.g. "sched*". You can specify multiple filters,
     * in which case all matching functions will be traced. See kernel
     * documentation on ftrace "set_ftrace_filter" file for more details.
     * Android:
     * * Available only on debuggable builds.
     * * Introduced in: Android U.
     * </pre>
     *
     * <code>repeated string function_filters = 20;</code>
     * @return The count of functionFilters.
     */
    public int getFunctionFiltersCount() {
      return functionFilters_.size();
    }
    /**
     * <pre>
     * Constrains the set of functions traced when |enable_function_graph| is
     * true. Supports globs, e.g. "sched*". You can specify multiple filters,
     * in which case all matching functions will be traced. See kernel
     * documentation on ftrace "set_ftrace_filter" file for more details.
     * Android:
     * * Available only on debuggable builds.
     * * Introduced in: Android U.
     * </pre>
     *
     * <code>repeated string function_filters = 20;</code>
     * @param index The index of the element to return.
     * @return The functionFilters at the given index.
     */
    public java.lang.String getFunctionFilters(int index) {
      return functionFilters_.get(index);
    }
    /**
     * <pre>
     * Constrains the set of functions traced when |enable_function_graph| is
     * true. Supports globs, e.g. "sched*". You can specify multiple filters,
     * in which case all matching functions will be traced. See kernel
     * documentation on ftrace "set_ftrace_filter" file for more details.
     * Android:
     * * Available only on debuggable builds.
     * * Introduced in: Android U.
     * </pre>
     *
     * <code>repeated string function_filters = 20;</code>
     * @param index The index of the value to return.
     * @return The bytes of the functionFilters at the given index.
     */
    public com.google.protobuf.ByteString
        getFunctionFiltersBytes(int index) {
      return functionFilters_.getByteString(index);
    }

    public static final int FUNCTION_GRAPH_ROOTS_FIELD_NUMBER = 21;
    @SuppressWarnings("serial")
    private com.google.protobuf.LazyStringArrayList functionGraphRoots_ =
        com.google.protobuf.LazyStringArrayList.emptyList();
    /**
     * <pre>
     * If |enable_function_graph| is true, trace this set of functions *and* all
     * of its callees. Supports globs. Can be set together with
     * |function_filters|, in which case only callees matching the filter will be
     * traced. If setting both, you most likely want all roots to also be
     * included in |function_filters|.
     * Android:
     * * Available only on debuggable builds.
     * * Introduced in: Android U.
     * </pre>
     *
     * <code>repeated string function_graph_roots = 21;</code>
     * @return A list containing the functionGraphRoots.
     */
    public com.google.protobuf.ProtocolStringList
        getFunctionGraphRootsList() {
      return functionGraphRoots_;
    }
    /**
     * <pre>
     * If |enable_function_graph| is true, trace this set of functions *and* all
     * of its callees. Supports globs. Can be set together with
     * |function_filters|, in which case only callees matching the filter will be
     * traced. If setting both, you most likely want all roots to also be
     * included in |function_filters|.
     * Android:
     * * Available only on debuggable builds.
     * * Introduced in: Android U.
     * </pre>
     *
     * <code>repeated string function_graph_roots = 21;</code>
     * @return The count of functionGraphRoots.
     */
    public int getFunctionGraphRootsCount() {
      return functionGraphRoots_.size();
    }
    /**
     * <pre>
     * If |enable_function_graph| is true, trace this set of functions *and* all
     * of its callees. Supports globs. Can be set together with
     * |function_filters|, in which case only callees matching the filter will be
     * traced. If setting both, you most likely want all roots to also be
     * included in |function_filters|.
     * Android:
     * * Available only on debuggable builds.
     * * Introduced in: Android U.
     * </pre>
     *
     * <code>repeated string function_graph_roots = 21;</code>
     * @param index The index of the element to return.
     * @return The functionGraphRoots at the given index.
     */
    public java.lang.String getFunctionGraphRoots(int index) {
      return functionGraphRoots_.get(index);
    }
    /**
     * <pre>
     * If |enable_function_graph| is true, trace this set of functions *and* all
     * of its callees. Supports globs. Can be set together with
     * |function_filters|, in which case only callees matching the filter will be
     * traced. If setting both, you most likely want all roots to also be
     * included in |function_filters|.
     * Android:
     * * Available only on debuggable builds.
     * * Introduced in: Android U.
     * </pre>
     *
     * <code>repeated string function_graph_roots = 21;</code>
     * @param index The index of the value to return.
     * @return The bytes of the functionGraphRoots at the given index.
     */
    public com.google.protobuf.ByteString
        getFunctionGraphRootsBytes(int index) {
      return functionGraphRoots_.getByteString(index);
    }

    public static final int PRESERVE_FTRACE_BUFFER_FIELD_NUMBER = 23;
    private boolean preserveFtraceBuffer_ = false;
    /**
     * <pre>
     * If true, does not clear ftrace buffers before the start of the program.
     * This makes sense only if this is the first ftrace data source instance
     * created after the daemon has been started. Can be useful for gathering boot
     * traces, if ftrace has been separately configured (e.g. via kernel
     * commandline).
     * </pre>
     *
     * <code>optional bool preserve_ftrace_buffer = 23;</code>
     * @return Whether the preserveFtraceBuffer field is set.
     */
    @java.lang.Override
    public boolean hasPreserveFtraceBuffer() {
      return ((bitField0_ & 0x00000800) != 0);
    }
    /**
     * <pre>
     * If true, does not clear ftrace buffers before the start of the program.
     * This makes sense only if this is the first ftrace data source instance
     * created after the daemon has been started. Can be useful for gathering boot
     * traces, if ftrace has been separately configured (e.g. via kernel
     * commandline).
     * </pre>
     *
     * <code>optional bool preserve_ftrace_buffer = 23;</code>
     * @return The preserveFtraceBuffer.
     */
    @java.lang.Override
    public boolean getPreserveFtraceBuffer() {
      return preserveFtraceBuffer_;
    }

    public static final int USE_MONOTONIC_RAW_CLOCK_FIELD_NUMBER = 24;
    private boolean useMonotonicRawClock_ = false;
    /**
     * <pre>
     * If true, overrides the default timestamp clock and uses a raw hardware
     * based monotonic clock for getting timestamps.
     * * Introduced in: Android U.
     * </pre>
     *
     * <code>optional bool use_monotonic_raw_clock = 24;</code>
     * @return Whether the useMonotonicRawClock field is set.
     */
    @java.lang.Override
    public boolean hasUseMonotonicRawClock() {
      return ((bitField0_ & 0x00001000) != 0);
    }
    /**
     * <pre>
     * If true, overrides the default timestamp clock and uses a raw hardware
     * based monotonic clock for getting timestamps.
     * * Introduced in: Android U.
     * </pre>
     *
     * <code>optional bool use_monotonic_raw_clock = 24;</code>
     * @return The useMonotonicRawClock.
     */
    @java.lang.Override
    public boolean getUseMonotonicRawClock() {
      return useMonotonicRawClock_;
    }

    public static final int INSTANCE_NAME_FIELD_NUMBER = 25;
    @SuppressWarnings("serial")
    private volatile java.lang.Object instanceName_ = "";
    /**
     * <pre>
     * If |instance_name| is not empty, then attempt to use that tracefs instance
     * for event recording. Normally, this means
     * `/sys/kernel/tracing/instances/$instance_name`.
     *
     * The name "hyp" is reserved.
     *
     * The instance must already exist, the tracing daemon *will not* create it
     * for you as it typically doesn't have such permissions.
     * Only a subset of features is guaranteed to work with non-default instances,
     * at the time of writing:
     * * ftrace_events
     * * buffer_size_kb
     * </pre>
     *
     * <code>optional string instance_name = 25;</code>
     * @return Whether the instanceName field is set.
     */
    @java.lang.Override
    public boolean hasInstanceName() {
      return ((bitField0_ & 0x00002000) != 0);
    }
    /**
     * <pre>
     * If |instance_name| is not empty, then attempt to use that tracefs instance
     * for event recording. Normally, this means
     * `/sys/kernel/tracing/instances/$instance_name`.
     *
     * The name "hyp" is reserved.
     *
     * The instance must already exist, the tracing daemon *will not* create it
     * for you as it typically doesn't have such permissions.
     * Only a subset of features is guaranteed to work with non-default instances,
     * at the time of writing:
     * * ftrace_events
     * * buffer_size_kb
     * </pre>
     *
     * <code>optional string instance_name = 25;</code>
     * @return The instanceName.
     */
    @java.lang.Override
    public java.lang.String getInstanceName() {
      java.lang.Object ref = instanceName_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          instanceName_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * If |instance_name| is not empty, then attempt to use that tracefs instance
     * for event recording. Normally, this means
     * `/sys/kernel/tracing/instances/$instance_name`.
     *
     * The name "hyp" is reserved.
     *
     * The instance must already exist, the tracing daemon *will not* create it
     * for you as it typically doesn't have such permissions.
     * Only a subset of features is guaranteed to work with non-default instances,
     * at the time of writing:
     * * ftrace_events
     * * buffer_size_kb
     * </pre>
     *
     * <code>optional string instance_name = 25;</code>
     * @return The bytes for instanceName.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getInstanceNameBytes() {
      java.lang.Object ref = instanceName_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        instanceName_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int BUFFER_SIZE_LOWER_BOUND_FIELD_NUMBER = 27;
    private boolean bufferSizeLowerBound_ = false;
    /**
     * <pre>
     * If true, |buffer_size_kb| is interpreted as a lower bound, allowing the
     * implementation to choose a bigger buffer size.
     *
     * Most configs for perfetto v43+ should simply leave both fields unset.
     *
     * If you need a config compatible with a range of perfetto builds and you
     * used to set a non-default buffer_size_kb, consider setting both fields.
     * Example:
     * buffer_size_kb: 4096
     * buffer_size_lower_bound: true
     * On older builds, the per-cpu buffers will be exactly 4 MB.
     * On v43+, buffers will be at least 4 MB.
     * In both cases, neither is guaranteed if there are other concurrent
     * perfetto ftrace sessions, as the buffers cannot be resized without pausing
     * the recording in the kernel.
     * Introduced in: perfetto v43.
     * </pre>
     *
     * <code>optional bool buffer_size_lower_bound = 27;</code>
     * @return Whether the bufferSizeLowerBound field is set.
     */
    @java.lang.Override
    public boolean hasBufferSizeLowerBound() {
      return ((bitField0_ & 0x00004000) != 0);
    }
    /**
     * <pre>
     * If true, |buffer_size_kb| is interpreted as a lower bound, allowing the
     * implementation to choose a bigger buffer size.
     *
     * Most configs for perfetto v43+ should simply leave both fields unset.
     *
     * If you need a config compatible with a range of perfetto builds and you
     * used to set a non-default buffer_size_kb, consider setting both fields.
     * Example:
     * buffer_size_kb: 4096
     * buffer_size_lower_bound: true
     * On older builds, the per-cpu buffers will be exactly 4 MB.
     * On v43+, buffers will be at least 4 MB.
     * In both cases, neither is guaranteed if there are other concurrent
     * perfetto ftrace sessions, as the buffers cannot be resized without pausing
     * the recording in the kernel.
     * Introduced in: perfetto v43.
     * </pre>
     *
     * <code>optional bool buffer_size_lower_bound = 27;</code>
     * @return The bufferSizeLowerBound.
     */
    @java.lang.Override
    public boolean getBufferSizeLowerBound() {
      return bufferSizeLowerBound_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < ftraceEvents_.size(); i++) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, ftraceEvents_.getRaw(i));
      }
      for (int i = 0; i < atraceCategories_.size(); i++) {
        com.google.protobuf.GeneratedMessage.writeString(output, 2, atraceCategories_.getRaw(i));
      }
      for (int i = 0; i < atraceApps_.size(); i++) {
        com.google.protobuf.GeneratedMessage.writeString(output, 3, atraceApps_.getRaw(i));
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeUInt32(10, bufferSizeKb_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeUInt32(11, drainPeriodMs_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        output.writeMessage(12, getCompactSched());
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        output.writeBool(13, symbolizeKsyms_);
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        output.writeBool(14, initializeKsymsSynchronouslyForTesting_);
      }
      if (((bitField0_ & 0x00000100) != 0)) {
        output.writeBool(15, throttleRssStat_);
      }
      if (((bitField0_ & 0x00000200) != 0)) {
        output.writeBool(16, disableGenericEvents_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        output.writeEnum(17, ksymsMemPolicy_);
      }
      for (int i = 0; i < syscallEvents_.size(); i++) {
        com.google.protobuf.GeneratedMessage.writeString(output, 18, syscallEvents_.getRaw(i));
      }
      if (((bitField0_ & 0x00000400) != 0)) {
        output.writeBool(19, enableFunctionGraph_);
      }
      for (int i = 0; i < functionFilters_.size(); i++) {
        com.google.protobuf.GeneratedMessage.writeString(output, 20, functionFilters_.getRaw(i));
      }
      for (int i = 0; i < functionGraphRoots_.size(); i++) {
        com.google.protobuf.GeneratedMessage.writeString(output, 21, functionGraphRoots_.getRaw(i));
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        output.writeMessage(22, getPrintFilter());
      }
      if (((bitField0_ & 0x00000800) != 0)) {
        output.writeBool(23, preserveFtraceBuffer_);
      }
      if (((bitField0_ & 0x00001000) != 0)) {
        output.writeBool(24, useMonotonicRawClock_);
      }
      if (((bitField0_ & 0x00002000) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 25, instanceName_);
      }
      if (((bitField0_ & 0x00004000) != 0)) {
        output.writeBool(27, bufferSizeLowerBound_);
      }
      for (int i = 0; i < atraceCategoriesPreferSdk_.size(); i++) {
        com.google.protobuf.GeneratedMessage.writeString(output, 28, atraceCategoriesPreferSdk_.getRaw(i));
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeUInt32(29, drainBufferPercent_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      {
        int dataSize = 0;
        for (int i = 0; i < ftraceEvents_.size(); i++) {
          dataSize += computeStringSizeNoTag(ftraceEvents_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getFtraceEventsList().size();
      }
      {
        int dataSize = 0;
        for (int i = 0; i < atraceCategories_.size(); i++) {
          dataSize += computeStringSizeNoTag(atraceCategories_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getAtraceCategoriesList().size();
      }
      {
        int dataSize = 0;
        for (int i = 0; i < atraceApps_.size(); i++) {
          dataSize += computeStringSizeNoTag(atraceApps_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getAtraceAppsList().size();
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(10, bufferSizeKb_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(11, drainPeriodMs_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(12, getCompactSched());
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(13, symbolizeKsyms_);
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(14, initializeKsymsSynchronouslyForTesting_);
      }
      if (((bitField0_ & 0x00000100) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(15, throttleRssStat_);
      }
      if (((bitField0_ & 0x00000200) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(16, disableGenericEvents_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(17, ksymsMemPolicy_);
      }
      {
        int dataSize = 0;
        for (int i = 0; i < syscallEvents_.size(); i++) {
          dataSize += computeStringSizeNoTag(syscallEvents_.getRaw(i));
        }
        size += dataSize;
        size += 2 * getSyscallEventsList().size();
      }
      if (((bitField0_ & 0x00000400) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(19, enableFunctionGraph_);
      }
      {
        int dataSize = 0;
        for (int i = 0; i < functionFilters_.size(); i++) {
          dataSize += computeStringSizeNoTag(functionFilters_.getRaw(i));
        }
        size += dataSize;
        size += 2 * getFunctionFiltersList().size();
      }
      {
        int dataSize = 0;
        for (int i = 0; i < functionGraphRoots_.size(); i++) {
          dataSize += computeStringSizeNoTag(functionGraphRoots_.getRaw(i));
        }
        size += dataSize;
        size += 2 * getFunctionGraphRootsList().size();
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(22, getPrintFilter());
      }
      if (((bitField0_ & 0x00000800) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(23, preserveFtraceBuffer_);
      }
      if (((bitField0_ & 0x00001000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(24, useMonotonicRawClock_);
      }
      if (((bitField0_ & 0x00002000) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(25, instanceName_);
      }
      if (((bitField0_ & 0x00004000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(27, bufferSizeLowerBound_);
      }
      {
        int dataSize = 0;
        for (int i = 0; i < atraceCategoriesPreferSdk_.size(); i++) {
          dataSize += computeStringSizeNoTag(atraceCategoriesPreferSdk_.getRaw(i));
        }
        size += dataSize;
        size += 2 * getAtraceCategoriesPreferSdkList().size();
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(29, drainBufferPercent_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof perfetto.protos.FtraceConfigOuterClass.FtraceConfig)) {
        return super.equals(obj);
      }
      perfetto.protos.FtraceConfigOuterClass.FtraceConfig other = (perfetto.protos.FtraceConfigOuterClass.FtraceConfig) obj;

      if (!getFtraceEventsList()
          .equals(other.getFtraceEventsList())) return false;
      if (!getAtraceCategoriesList()
          .equals(other.getAtraceCategoriesList())) return false;
      if (!getAtraceAppsList()
          .equals(other.getAtraceAppsList())) return false;
      if (!getAtraceCategoriesPreferSdkList()
          .equals(other.getAtraceCategoriesPreferSdkList())) return false;
      if (hasBufferSizeKb() != other.hasBufferSizeKb()) return false;
      if (hasBufferSizeKb()) {
        if (getBufferSizeKb()
            != other.getBufferSizeKb()) return false;
      }
      if (hasDrainPeriodMs() != other.hasDrainPeriodMs()) return false;
      if (hasDrainPeriodMs()) {
        if (getDrainPeriodMs()
            != other.getDrainPeriodMs()) return false;
      }
      if (hasDrainBufferPercent() != other.hasDrainBufferPercent()) return false;
      if (hasDrainBufferPercent()) {
        if (getDrainBufferPercent()
            != other.getDrainBufferPercent()) return false;
      }
      if (hasCompactSched() != other.hasCompactSched()) return false;
      if (hasCompactSched()) {
        if (!getCompactSched()
            .equals(other.getCompactSched())) return false;
      }
      if (hasPrintFilter() != other.hasPrintFilter()) return false;
      if (hasPrintFilter()) {
        if (!getPrintFilter()
            .equals(other.getPrintFilter())) return false;
      }
      if (hasSymbolizeKsyms() != other.hasSymbolizeKsyms()) return false;
      if (hasSymbolizeKsyms()) {
        if (getSymbolizeKsyms()
            != other.getSymbolizeKsyms()) return false;
      }
      if (hasKsymsMemPolicy() != other.hasKsymsMemPolicy()) return false;
      if (hasKsymsMemPolicy()) {
        if (ksymsMemPolicy_ != other.ksymsMemPolicy_) return false;
      }
      if (hasInitializeKsymsSynchronouslyForTesting() != other.hasInitializeKsymsSynchronouslyForTesting()) return false;
      if (hasInitializeKsymsSynchronouslyForTesting()) {
        if (getInitializeKsymsSynchronouslyForTesting()
            != other.getInitializeKsymsSynchronouslyForTesting()) return false;
      }
      if (hasThrottleRssStat() != other.hasThrottleRssStat()) return false;
      if (hasThrottleRssStat()) {
        if (getThrottleRssStat()
            != other.getThrottleRssStat()) return false;
      }
      if (hasDisableGenericEvents() != other.hasDisableGenericEvents()) return false;
      if (hasDisableGenericEvents()) {
        if (getDisableGenericEvents()
            != other.getDisableGenericEvents()) return false;
      }
      if (!getSyscallEventsList()
          .equals(other.getSyscallEventsList())) return false;
      if (hasEnableFunctionGraph() != other.hasEnableFunctionGraph()) return false;
      if (hasEnableFunctionGraph()) {
        if (getEnableFunctionGraph()
            != other.getEnableFunctionGraph()) return false;
      }
      if (!getFunctionFiltersList()
          .equals(other.getFunctionFiltersList())) return false;
      if (!getFunctionGraphRootsList()
          .equals(other.getFunctionGraphRootsList())) return false;
      if (hasPreserveFtraceBuffer() != other.hasPreserveFtraceBuffer()) return false;
      if (hasPreserveFtraceBuffer()) {
        if (getPreserveFtraceBuffer()
            != other.getPreserveFtraceBuffer()) return false;
      }
      if (hasUseMonotonicRawClock() != other.hasUseMonotonicRawClock()) return false;
      if (hasUseMonotonicRawClock()) {
        if (getUseMonotonicRawClock()
            != other.getUseMonotonicRawClock()) return false;
      }
      if (hasInstanceName() != other.hasInstanceName()) return false;
      if (hasInstanceName()) {
        if (!getInstanceName()
            .equals(other.getInstanceName())) return false;
      }
      if (hasBufferSizeLowerBound() != other.hasBufferSizeLowerBound()) return false;
      if (hasBufferSizeLowerBound()) {
        if (getBufferSizeLowerBound()
            != other.getBufferSizeLowerBound()) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getFtraceEventsCount() > 0) {
        hash = (37 * hash) + FTRACE_EVENTS_FIELD_NUMBER;
        hash = (53 * hash) + getFtraceEventsList().hashCode();
      }
      if (getAtraceCategoriesCount() > 0) {
        hash = (37 * hash) + ATRACE_CATEGORIES_FIELD_NUMBER;
        hash = (53 * hash) + getAtraceCategoriesList().hashCode();
      }
      if (getAtraceAppsCount() > 0) {
        hash = (37 * hash) + ATRACE_APPS_FIELD_NUMBER;
        hash = (53 * hash) + getAtraceAppsList().hashCode();
      }
      if (getAtraceCategoriesPreferSdkCount() > 0) {
        hash = (37 * hash) + ATRACE_CATEGORIES_PREFER_SDK_FIELD_NUMBER;
        hash = (53 * hash) + getAtraceCategoriesPreferSdkList().hashCode();
      }
      if (hasBufferSizeKb()) {
        hash = (37 * hash) + BUFFER_SIZE_KB_FIELD_NUMBER;
        hash = (53 * hash) + getBufferSizeKb();
      }
      if (hasDrainPeriodMs()) {
        hash = (37 * hash) + DRAIN_PERIOD_MS_FIELD_NUMBER;
        hash = (53 * hash) + getDrainPeriodMs();
      }
      if (hasDrainBufferPercent()) {
        hash = (37 * hash) + DRAIN_BUFFER_PERCENT_FIELD_NUMBER;
        hash = (53 * hash) + getDrainBufferPercent();
      }
      if (hasCompactSched()) {
        hash = (37 * hash) + COMPACT_SCHED_FIELD_NUMBER;
        hash = (53 * hash) + getCompactSched().hashCode();
      }
      if (hasPrintFilter()) {
        hash = (37 * hash) + PRINT_FILTER_FIELD_NUMBER;
        hash = (53 * hash) + getPrintFilter().hashCode();
      }
      if (hasSymbolizeKsyms()) {
        hash = (37 * hash) + SYMBOLIZE_KSYMS_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getSymbolizeKsyms());
      }
      if (hasKsymsMemPolicy()) {
        hash = (37 * hash) + KSYMS_MEM_POLICY_FIELD_NUMBER;
        hash = (53 * hash) + ksymsMemPolicy_;
      }
      if (hasInitializeKsymsSynchronouslyForTesting()) {
        hash = (37 * hash) + INITIALIZE_KSYMS_SYNCHRONOUSLY_FOR_TESTING_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getInitializeKsymsSynchronouslyForTesting());
      }
      if (hasThrottleRssStat()) {
        hash = (37 * hash) + THROTTLE_RSS_STAT_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getThrottleRssStat());
      }
      if (hasDisableGenericEvents()) {
        hash = (37 * hash) + DISABLE_GENERIC_EVENTS_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getDisableGenericEvents());
      }
      if (getSyscallEventsCount() > 0) {
        hash = (37 * hash) + SYSCALL_EVENTS_FIELD_NUMBER;
        hash = (53 * hash) + getSyscallEventsList().hashCode();
      }
      if (hasEnableFunctionGraph()) {
        hash = (37 * hash) + ENABLE_FUNCTION_GRAPH_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getEnableFunctionGraph());
      }
      if (getFunctionFiltersCount() > 0) {
        hash = (37 * hash) + FUNCTION_FILTERS_FIELD_NUMBER;
        hash = (53 * hash) + getFunctionFiltersList().hashCode();
      }
      if (getFunctionGraphRootsCount() > 0) {
        hash = (37 * hash) + FUNCTION_GRAPH_ROOTS_FIELD_NUMBER;
        hash = (53 * hash) + getFunctionGraphRootsList().hashCode();
      }
      if (hasPreserveFtraceBuffer()) {
        hash = (37 * hash) + PRESERVE_FTRACE_BUFFER_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getPreserveFtraceBuffer());
      }
      if (hasUseMonotonicRawClock()) {
        hash = (37 * hash) + USE_MONOTONIC_RAW_CLOCK_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getUseMonotonicRawClock());
      }
      if (hasInstanceName()) {
        hash = (37 * hash) + INSTANCE_NAME_FIELD_NUMBER;
        hash = (53 * hash) + getInstanceName().hashCode();
      }
      if (hasBufferSizeLowerBound()) {
        hash = (37 * hash) + BUFFER_SIZE_LOWER_BOUND_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getBufferSizeLowerBound());
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static perfetto.protos.FtraceConfigOuterClass.FtraceConfig parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static perfetto.protos.FtraceConfigOuterClass.FtraceConfig parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static perfetto.protos.FtraceConfigOuterClass.FtraceConfig parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static perfetto.protos.FtraceConfigOuterClass.FtraceConfig parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static perfetto.protos.FtraceConfigOuterClass.FtraceConfig parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static perfetto.protos.FtraceConfigOuterClass.FtraceConfig parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static perfetto.protos.FtraceConfigOuterClass.FtraceConfig parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static perfetto.protos.FtraceConfigOuterClass.FtraceConfig parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static perfetto.protos.FtraceConfigOuterClass.FtraceConfig parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static perfetto.protos.FtraceConfigOuterClass.FtraceConfig parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static perfetto.protos.FtraceConfigOuterClass.FtraceConfig parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static perfetto.protos.FtraceConfigOuterClass.FtraceConfig parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(perfetto.protos.FtraceConfigOuterClass.FtraceConfig prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Next id: 30
     * </pre>
     *
     * Protobuf type {@code perfetto.protos.FtraceConfig}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:perfetto.protos.FtraceConfig)
        perfetto.protos.FtraceConfigOuterClass.FtraceConfigOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return perfetto.protos.FtraceConfigOuterClass.internal_static_perfetto_protos_FtraceConfig_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return perfetto.protos.FtraceConfigOuterClass.internal_static_perfetto_protos_FtraceConfig_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                perfetto.protos.FtraceConfigOuterClass.FtraceConfig.class, perfetto.protos.FtraceConfigOuterClass.FtraceConfig.Builder.class);
      }

      // Construct using perfetto.protos.FtraceConfigOuterClass.FtraceConfig.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getCompactSchedFieldBuilder();
          getPrintFilterFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        ftraceEvents_ =
            com.google.protobuf.LazyStringArrayList.emptyList();
        atraceCategories_ =
            com.google.protobuf.LazyStringArrayList.emptyList();
        atraceApps_ =
            com.google.protobuf.LazyStringArrayList.emptyList();
        atraceCategoriesPreferSdk_ =
            com.google.protobuf.LazyStringArrayList.emptyList();
        bufferSizeKb_ = 0;
        drainPeriodMs_ = 0;
        drainBufferPercent_ = 0;
        compactSched_ = null;
        if (compactSchedBuilder_ != null) {
          compactSchedBuilder_.dispose();
          compactSchedBuilder_ = null;
        }
        printFilter_ = null;
        if (printFilterBuilder_ != null) {
          printFilterBuilder_.dispose();
          printFilterBuilder_ = null;
        }
        symbolizeKsyms_ = false;
        ksymsMemPolicy_ = 0;
        initializeKsymsSynchronouslyForTesting_ = false;
        throttleRssStat_ = false;
        disableGenericEvents_ = false;
        syscallEvents_ =
            com.google.protobuf.LazyStringArrayList.emptyList();
        enableFunctionGraph_ = false;
        functionFilters_ =
            com.google.protobuf.LazyStringArrayList.emptyList();
        functionGraphRoots_ =
            com.google.protobuf.LazyStringArrayList.emptyList();
        preserveFtraceBuffer_ = false;
        useMonotonicRawClock_ = false;
        instanceName_ = "";
        bufferSizeLowerBound_ = false;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return perfetto.protos.FtraceConfigOuterClass.internal_static_perfetto_protos_FtraceConfig_descriptor;
      }

      @java.lang.Override
      public perfetto.protos.FtraceConfigOuterClass.FtraceConfig getDefaultInstanceForType() {
        return perfetto.protos.FtraceConfigOuterClass.FtraceConfig.getDefaultInstance();
      }

      @java.lang.Override
      public perfetto.protos.FtraceConfigOuterClass.FtraceConfig build() {
        perfetto.protos.FtraceConfigOuterClass.FtraceConfig result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public perfetto.protos.FtraceConfigOuterClass.FtraceConfig buildPartial() {
        perfetto.protos.FtraceConfigOuterClass.FtraceConfig result = new perfetto.protos.FtraceConfigOuterClass.FtraceConfig(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(perfetto.protos.FtraceConfigOuterClass.FtraceConfig result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          ftraceEvents_.makeImmutable();
          result.ftraceEvents_ = ftraceEvents_;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          atraceCategories_.makeImmutable();
          result.atraceCategories_ = atraceCategories_;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          atraceApps_.makeImmutable();
          result.atraceApps_ = atraceApps_;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          atraceCategoriesPreferSdk_.makeImmutable();
          result.atraceCategoriesPreferSdk_ = atraceCategoriesPreferSdk_;
        }
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.bufferSizeKb_ = bufferSizeKb_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          result.drainPeriodMs_ = drainPeriodMs_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000040) != 0)) {
          result.drainBufferPercent_ = drainBufferPercent_;
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000080) != 0)) {
          result.compactSched_ = compactSchedBuilder_ == null
              ? compactSched_
              : compactSchedBuilder_.build();
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000100) != 0)) {
          result.printFilter_ = printFilterBuilder_ == null
              ? printFilter_
              : printFilterBuilder_.build();
          to_bitField0_ |= 0x00000010;
        }
        if (((from_bitField0_ & 0x00000200) != 0)) {
          result.symbolizeKsyms_ = symbolizeKsyms_;
          to_bitField0_ |= 0x00000020;
        }
        if (((from_bitField0_ & 0x00000400) != 0)) {
          result.ksymsMemPolicy_ = ksymsMemPolicy_;
          to_bitField0_ |= 0x00000040;
        }
        if (((from_bitField0_ & 0x00000800) != 0)) {
          result.initializeKsymsSynchronouslyForTesting_ = initializeKsymsSynchronouslyForTesting_;
          to_bitField0_ |= 0x00000080;
        }
        if (((from_bitField0_ & 0x00001000) != 0)) {
          result.throttleRssStat_ = throttleRssStat_;
          to_bitField0_ |= 0x00000100;
        }
        if (((from_bitField0_ & 0x00002000) != 0)) {
          result.disableGenericEvents_ = disableGenericEvents_;
          to_bitField0_ |= 0x00000200;
        }
        if (((from_bitField0_ & 0x00004000) != 0)) {
          syscallEvents_.makeImmutable();
          result.syscallEvents_ = syscallEvents_;
        }
        if (((from_bitField0_ & 0x00008000) != 0)) {
          result.enableFunctionGraph_ = enableFunctionGraph_;
          to_bitField0_ |= 0x00000400;
        }
        if (((from_bitField0_ & 0x00010000) != 0)) {
          functionFilters_.makeImmutable();
          result.functionFilters_ = functionFilters_;
        }
        if (((from_bitField0_ & 0x00020000) != 0)) {
          functionGraphRoots_.makeImmutable();
          result.functionGraphRoots_ = functionGraphRoots_;
        }
        if (((from_bitField0_ & 0x00040000) != 0)) {
          result.preserveFtraceBuffer_ = preserveFtraceBuffer_;
          to_bitField0_ |= 0x00000800;
        }
        if (((from_bitField0_ & 0x00080000) != 0)) {
          result.useMonotonicRawClock_ = useMonotonicRawClock_;
          to_bitField0_ |= 0x00001000;
        }
        if (((from_bitField0_ & 0x00100000) != 0)) {
          result.instanceName_ = instanceName_;
          to_bitField0_ |= 0x00002000;
        }
        if (((from_bitField0_ & 0x00200000) != 0)) {
          result.bufferSizeLowerBound_ = bufferSizeLowerBound_;
          to_bitField0_ |= 0x00004000;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof perfetto.protos.FtraceConfigOuterClass.FtraceConfig) {
          return mergeFrom((perfetto.protos.FtraceConfigOuterClass.FtraceConfig)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(perfetto.protos.FtraceConfigOuterClass.FtraceConfig other) {
        if (other == perfetto.protos.FtraceConfigOuterClass.FtraceConfig.getDefaultInstance()) return this;
        if (!other.ftraceEvents_.isEmpty()) {
          if (ftraceEvents_.isEmpty()) {
            ftraceEvents_ = other.ftraceEvents_;
            bitField0_ |= 0x00000001;
          } else {
            ensureFtraceEventsIsMutable();
            ftraceEvents_.addAll(other.ftraceEvents_);
          }
          onChanged();
        }
        if (!other.atraceCategories_.isEmpty()) {
          if (atraceCategories_.isEmpty()) {
            atraceCategories_ = other.atraceCategories_;
            bitField0_ |= 0x00000002;
          } else {
            ensureAtraceCategoriesIsMutable();
            atraceCategories_.addAll(other.atraceCategories_);
          }
          onChanged();
        }
        if (!other.atraceApps_.isEmpty()) {
          if (atraceApps_.isEmpty()) {
            atraceApps_ = other.atraceApps_;
            bitField0_ |= 0x00000004;
          } else {
            ensureAtraceAppsIsMutable();
            atraceApps_.addAll(other.atraceApps_);
          }
          onChanged();
        }
        if (!other.atraceCategoriesPreferSdk_.isEmpty()) {
          if (atraceCategoriesPreferSdk_.isEmpty()) {
            atraceCategoriesPreferSdk_ = other.atraceCategoriesPreferSdk_;
            bitField0_ |= 0x00000008;
          } else {
            ensureAtraceCategoriesPreferSdkIsMutable();
            atraceCategoriesPreferSdk_.addAll(other.atraceCategoriesPreferSdk_);
          }
          onChanged();
        }
        if (other.hasBufferSizeKb()) {
          setBufferSizeKb(other.getBufferSizeKb());
        }
        if (other.hasDrainPeriodMs()) {
          setDrainPeriodMs(other.getDrainPeriodMs());
        }
        if (other.hasDrainBufferPercent()) {
          setDrainBufferPercent(other.getDrainBufferPercent());
        }
        if (other.hasCompactSched()) {
          mergeCompactSched(other.getCompactSched());
        }
        if (other.hasPrintFilter()) {
          mergePrintFilter(other.getPrintFilter());
        }
        if (other.hasSymbolizeKsyms()) {
          setSymbolizeKsyms(other.getSymbolizeKsyms());
        }
        if (other.hasKsymsMemPolicy()) {
          setKsymsMemPolicy(other.getKsymsMemPolicy());
        }
        if (other.hasInitializeKsymsSynchronouslyForTesting()) {
          setInitializeKsymsSynchronouslyForTesting(other.getInitializeKsymsSynchronouslyForTesting());
        }
        if (other.hasThrottleRssStat()) {
          setThrottleRssStat(other.getThrottleRssStat());
        }
        if (other.hasDisableGenericEvents()) {
          setDisableGenericEvents(other.getDisableGenericEvents());
        }
        if (!other.syscallEvents_.isEmpty()) {
          if (syscallEvents_.isEmpty()) {
            syscallEvents_ = other.syscallEvents_;
            bitField0_ |= 0x00004000;
          } else {
            ensureSyscallEventsIsMutable();
            syscallEvents_.addAll(other.syscallEvents_);
          }
          onChanged();
        }
        if (other.hasEnableFunctionGraph()) {
          setEnableFunctionGraph(other.getEnableFunctionGraph());
        }
        if (!other.functionFilters_.isEmpty()) {
          if (functionFilters_.isEmpty()) {
            functionFilters_ = other.functionFilters_;
            bitField0_ |= 0x00010000;
          } else {
            ensureFunctionFiltersIsMutable();
            functionFilters_.addAll(other.functionFilters_);
          }
          onChanged();
        }
        if (!other.functionGraphRoots_.isEmpty()) {
          if (functionGraphRoots_.isEmpty()) {
            functionGraphRoots_ = other.functionGraphRoots_;
            bitField0_ |= 0x00020000;
          } else {
            ensureFunctionGraphRootsIsMutable();
            functionGraphRoots_.addAll(other.functionGraphRoots_);
          }
          onChanged();
        }
        if (other.hasPreserveFtraceBuffer()) {
          setPreserveFtraceBuffer(other.getPreserveFtraceBuffer());
        }
        if (other.hasUseMonotonicRawClock()) {
          setUseMonotonicRawClock(other.getUseMonotonicRawClock());
        }
        if (other.hasInstanceName()) {
          instanceName_ = other.instanceName_;
          bitField0_ |= 0x00100000;
          onChanged();
        }
        if (other.hasBufferSizeLowerBound()) {
          setBufferSizeLowerBound(other.getBufferSizeLowerBound());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                com.google.protobuf.ByteString bs = input.readBytes();
                ensureFtraceEventsIsMutable();
                ftraceEvents_.add(bs);
                break;
              } // case 10
              case 18: {
                com.google.protobuf.ByteString bs = input.readBytes();
                ensureAtraceCategoriesIsMutable();
                atraceCategories_.add(bs);
                break;
              } // case 18
              case 26: {
                com.google.protobuf.ByteString bs = input.readBytes();
                ensureAtraceAppsIsMutable();
                atraceApps_.add(bs);
                break;
              } // case 26
              case 80: {
                bufferSizeKb_ = input.readUInt32();
                bitField0_ |= 0x00000010;
                break;
              } // case 80
              case 88: {
                drainPeriodMs_ = input.readUInt32();
                bitField0_ |= 0x00000020;
                break;
              } // case 88
              case 98: {
                input.readMessage(
                    getCompactSchedFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000080;
                break;
              } // case 98
              case 104: {
                symbolizeKsyms_ = input.readBool();
                bitField0_ |= 0x00000200;
                break;
              } // case 104
              case 112: {
                initializeKsymsSynchronouslyForTesting_ = input.readBool();
                bitField0_ |= 0x00000800;
                break;
              } // case 112
              case 120: {
                throttleRssStat_ = input.readBool();
                bitField0_ |= 0x00001000;
                break;
              } // case 120
              case 128: {
                disableGenericEvents_ = input.readBool();
                bitField0_ |= 0x00002000;
                break;
              } // case 128
              case 136: {
                int tmpRaw = input.readEnum();
                perfetto.protos.FtraceConfigOuterClass.FtraceConfig.KsymsMemPolicy tmpValue =
                    perfetto.protos.FtraceConfigOuterClass.FtraceConfig.KsymsMemPolicy.forNumber(tmpRaw);
                if (tmpValue == null) {
                  mergeUnknownVarintField(17, tmpRaw);
                } else {
                  ksymsMemPolicy_ = tmpRaw;
                  bitField0_ |= 0x00000400;
                }
                break;
              } // case 136
              case 146: {
                com.google.protobuf.ByteString bs = input.readBytes();
                ensureSyscallEventsIsMutable();
                syscallEvents_.add(bs);
                break;
              } // case 146
              case 152: {
                enableFunctionGraph_ = input.readBool();
                bitField0_ |= 0x00008000;
                break;
              } // case 152
              case 162: {
                com.google.protobuf.ByteString bs = input.readBytes();
                ensureFunctionFiltersIsMutable();
                functionFilters_.add(bs);
                break;
              } // case 162
              case 170: {
                com.google.protobuf.ByteString bs = input.readBytes();
                ensureFunctionGraphRootsIsMutable();
                functionGraphRoots_.add(bs);
                break;
              } // case 170
              case 178: {
                input.readMessage(
                    getPrintFilterFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000100;
                break;
              } // case 178
              case 184: {
                preserveFtraceBuffer_ = input.readBool();
                bitField0_ |= 0x00040000;
                break;
              } // case 184
              case 192: {
                useMonotonicRawClock_ = input.readBool();
                bitField0_ |= 0x00080000;
                break;
              } // case 192
              case 202: {
                instanceName_ = input.readBytes();
                bitField0_ |= 0x00100000;
                break;
              } // case 202
              case 216: {
                bufferSizeLowerBound_ = input.readBool();
                bitField0_ |= 0x00200000;
                break;
              } // case 216
              case 226: {
                com.google.protobuf.ByteString bs = input.readBytes();
                ensureAtraceCategoriesPreferSdkIsMutable();
                atraceCategoriesPreferSdk_.add(bs);
                break;
              } // case 226
              case 232: {
                drainBufferPercent_ = input.readUInt32();
                bitField0_ |= 0x00000040;
                break;
              } // case 232
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private com.google.protobuf.LazyStringArrayList ftraceEvents_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
      private void ensureFtraceEventsIsMutable() {
        if (!ftraceEvents_.isModifiable()) {
          ftraceEvents_ = new com.google.protobuf.LazyStringArrayList(ftraceEvents_);
        }
        bitField0_ |= 0x00000001;
      }
      /**
       * <pre>
       * Ftrace events to record, example: "sched/sched_switch".
       * </pre>
       *
       * <code>repeated string ftrace_events = 1;</code>
       * @return A list containing the ftraceEvents.
       */
      public com.google.protobuf.ProtocolStringList
          getFtraceEventsList() {
        ftraceEvents_.makeImmutable();
        return ftraceEvents_;
      }
      /**
       * <pre>
       * Ftrace events to record, example: "sched/sched_switch".
       * </pre>
       *
       * <code>repeated string ftrace_events = 1;</code>
       * @return The count of ftraceEvents.
       */
      public int getFtraceEventsCount() {
        return ftraceEvents_.size();
      }
      /**
       * <pre>
       * Ftrace events to record, example: "sched/sched_switch".
       * </pre>
       *
       * <code>repeated string ftrace_events = 1;</code>
       * @param index The index of the element to return.
       * @return The ftraceEvents at the given index.
       */
      public java.lang.String getFtraceEvents(int index) {
        return ftraceEvents_.get(index);
      }
      /**
       * <pre>
       * Ftrace events to record, example: "sched/sched_switch".
       * </pre>
       *
       * <code>repeated string ftrace_events = 1;</code>
       * @param index The index of the value to return.
       * @return The bytes of the ftraceEvents at the given index.
       */
      public com.google.protobuf.ByteString
          getFtraceEventsBytes(int index) {
        return ftraceEvents_.getByteString(index);
      }
      /**
       * <pre>
       * Ftrace events to record, example: "sched/sched_switch".
       * </pre>
       *
       * <code>repeated string ftrace_events = 1;</code>
       * @param index The index to set the value at.
       * @param value The ftraceEvents to set.
       * @return This builder for chaining.
       */
      public Builder setFtraceEvents(
          int index, java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureFtraceEventsIsMutable();
        ftraceEvents_.set(index, value);
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Ftrace events to record, example: "sched/sched_switch".
       * </pre>
       *
       * <code>repeated string ftrace_events = 1;</code>
       * @param value The ftraceEvents to add.
       * @return This builder for chaining.
       */
      public Builder addFtraceEvents(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureFtraceEventsIsMutable();
        ftraceEvents_.add(value);
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Ftrace events to record, example: "sched/sched_switch".
       * </pre>
       *
       * <code>repeated string ftrace_events = 1;</code>
       * @param values The ftraceEvents to add.
       * @return This builder for chaining.
       */
      public Builder addAllFtraceEvents(
          java.lang.Iterable<java.lang.String> values) {
        ensureFtraceEventsIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, ftraceEvents_);
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Ftrace events to record, example: "sched/sched_switch".
       * </pre>
       *
       * <code>repeated string ftrace_events = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearFtraceEvents() {
        ftraceEvents_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
        bitField0_ = (bitField0_ & ~0x00000001);;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Ftrace events to record, example: "sched/sched_switch".
       * </pre>
       *
       * <code>repeated string ftrace_events = 1;</code>
       * @param value The bytes of the ftraceEvents to add.
       * @return This builder for chaining.
       */
      public Builder addFtraceEventsBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        ensureFtraceEventsIsMutable();
        ftraceEvents_.add(value);
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private com.google.protobuf.LazyStringArrayList atraceCategories_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
      private void ensureAtraceCategoriesIsMutable() {
        if (!atraceCategories_.isModifiable()) {
          atraceCategories_ = new com.google.protobuf.LazyStringArrayList(atraceCategories_);
        }
        bitField0_ |= 0x00000002;
      }
      /**
       * <pre>
       * Android-specific event categories:
       * </pre>
       *
       * <code>repeated string atrace_categories = 2;</code>
       * @return A list containing the atraceCategories.
       */
      public com.google.protobuf.ProtocolStringList
          getAtraceCategoriesList() {
        atraceCategories_.makeImmutable();
        return atraceCategories_;
      }
      /**
       * <pre>
       * Android-specific event categories:
       * </pre>
       *
       * <code>repeated string atrace_categories = 2;</code>
       * @return The count of atraceCategories.
       */
      public int getAtraceCategoriesCount() {
        return atraceCategories_.size();
      }
      /**
       * <pre>
       * Android-specific event categories:
       * </pre>
       *
       * <code>repeated string atrace_categories = 2;</code>
       * @param index The index of the element to return.
       * @return The atraceCategories at the given index.
       */
      public java.lang.String getAtraceCategories(int index) {
        return atraceCategories_.get(index);
      }
      /**
       * <pre>
       * Android-specific event categories:
       * </pre>
       *
       * <code>repeated string atrace_categories = 2;</code>
       * @param index The index of the value to return.
       * @return The bytes of the atraceCategories at the given index.
       */
      public com.google.protobuf.ByteString
          getAtraceCategoriesBytes(int index) {
        return atraceCategories_.getByteString(index);
      }
      /**
       * <pre>
       * Android-specific event categories:
       * </pre>
       *
       * <code>repeated string atrace_categories = 2;</code>
       * @param index The index to set the value at.
       * @param value The atraceCategories to set.
       * @return This builder for chaining.
       */
      public Builder setAtraceCategories(
          int index, java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureAtraceCategoriesIsMutable();
        atraceCategories_.set(index, value);
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Android-specific event categories:
       * </pre>
       *
       * <code>repeated string atrace_categories = 2;</code>
       * @param value The atraceCategories to add.
       * @return This builder for chaining.
       */
      public Builder addAtraceCategories(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureAtraceCategoriesIsMutable();
        atraceCategories_.add(value);
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Android-specific event categories:
       * </pre>
       *
       * <code>repeated string atrace_categories = 2;</code>
       * @param values The atraceCategories to add.
       * @return This builder for chaining.
       */
      public Builder addAllAtraceCategories(
          java.lang.Iterable<java.lang.String> values) {
        ensureAtraceCategoriesIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, atraceCategories_);
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Android-specific event categories:
       * </pre>
       *
       * <code>repeated string atrace_categories = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearAtraceCategories() {
        atraceCategories_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
        bitField0_ = (bitField0_ & ~0x00000002);;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Android-specific event categories:
       * </pre>
       *
       * <code>repeated string atrace_categories = 2;</code>
       * @param value The bytes of the atraceCategories to add.
       * @return This builder for chaining.
       */
      public Builder addAtraceCategoriesBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        ensureAtraceCategoriesIsMutable();
        atraceCategories_.add(value);
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }

      private com.google.protobuf.LazyStringArrayList atraceApps_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
      private void ensureAtraceAppsIsMutable() {
        if (!atraceApps_.isModifiable()) {
          atraceApps_ = new com.google.protobuf.LazyStringArrayList(atraceApps_);
        }
        bitField0_ |= 0x00000004;
      }
      /**
       * <code>repeated string atrace_apps = 3;</code>
       * @return A list containing the atraceApps.
       */
      public com.google.protobuf.ProtocolStringList
          getAtraceAppsList() {
        atraceApps_.makeImmutable();
        return atraceApps_;
      }
      /**
       * <code>repeated string atrace_apps = 3;</code>
       * @return The count of atraceApps.
       */
      public int getAtraceAppsCount() {
        return atraceApps_.size();
      }
      /**
       * <code>repeated string atrace_apps = 3;</code>
       * @param index The index of the element to return.
       * @return The atraceApps at the given index.
       */
      public java.lang.String getAtraceApps(int index) {
        return atraceApps_.get(index);
      }
      /**
       * <code>repeated string atrace_apps = 3;</code>
       * @param index The index of the value to return.
       * @return The bytes of the atraceApps at the given index.
       */
      public com.google.protobuf.ByteString
          getAtraceAppsBytes(int index) {
        return atraceApps_.getByteString(index);
      }
      /**
       * <code>repeated string atrace_apps = 3;</code>
       * @param index The index to set the value at.
       * @param value The atraceApps to set.
       * @return This builder for chaining.
       */
      public Builder setAtraceApps(
          int index, java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureAtraceAppsIsMutable();
        atraceApps_.set(index, value);
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <code>repeated string atrace_apps = 3;</code>
       * @param value The atraceApps to add.
       * @return This builder for chaining.
       */
      public Builder addAtraceApps(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureAtraceAppsIsMutable();
        atraceApps_.add(value);
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <code>repeated string atrace_apps = 3;</code>
       * @param values The atraceApps to add.
       * @return This builder for chaining.
       */
      public Builder addAllAtraceApps(
          java.lang.Iterable<java.lang.String> values) {
        ensureAtraceAppsIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, atraceApps_);
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <code>repeated string atrace_apps = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearAtraceApps() {
        atraceApps_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
        bitField0_ = (bitField0_ & ~0x00000004);;
        onChanged();
        return this;
      }
      /**
       * <code>repeated string atrace_apps = 3;</code>
       * @param value The bytes of the atraceApps to add.
       * @return This builder for chaining.
       */
      public Builder addAtraceAppsBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        ensureAtraceAppsIsMutable();
        atraceApps_.add(value);
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }

      private com.google.protobuf.LazyStringArrayList atraceCategoriesPreferSdk_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
      private void ensureAtraceCategoriesPreferSdkIsMutable() {
        if (!atraceCategoriesPreferSdk_.isModifiable()) {
          atraceCategoriesPreferSdk_ = new com.google.protobuf.LazyStringArrayList(atraceCategoriesPreferSdk_);
        }
        bitField0_ |= 0x00000008;
      }
      /**
       * <pre>
       * Some processes can emit data through atrace or through the perfetto SDK via
       * the "track_event" data source. For these categories, the SDK will be
       * preferred, if possible, for this config.
       * </pre>
       *
       * <code>repeated string atrace_categories_prefer_sdk = 28;</code>
       * @return A list containing the atraceCategoriesPreferSdk.
       */
      public com.google.protobuf.ProtocolStringList
          getAtraceCategoriesPreferSdkList() {
        atraceCategoriesPreferSdk_.makeImmutable();
        return atraceCategoriesPreferSdk_;
      }
      /**
       * <pre>
       * Some processes can emit data through atrace or through the perfetto SDK via
       * the "track_event" data source. For these categories, the SDK will be
       * preferred, if possible, for this config.
       * </pre>
       *
       * <code>repeated string atrace_categories_prefer_sdk = 28;</code>
       * @return The count of atraceCategoriesPreferSdk.
       */
      public int getAtraceCategoriesPreferSdkCount() {
        return atraceCategoriesPreferSdk_.size();
      }
      /**
       * <pre>
       * Some processes can emit data through atrace or through the perfetto SDK via
       * the "track_event" data source. For these categories, the SDK will be
       * preferred, if possible, for this config.
       * </pre>
       *
       * <code>repeated string atrace_categories_prefer_sdk = 28;</code>
       * @param index The index of the element to return.
       * @return The atraceCategoriesPreferSdk at the given index.
       */
      public java.lang.String getAtraceCategoriesPreferSdk(int index) {
        return atraceCategoriesPreferSdk_.get(index);
      }
      /**
       * <pre>
       * Some processes can emit data through atrace or through the perfetto SDK via
       * the "track_event" data source. For these categories, the SDK will be
       * preferred, if possible, for this config.
       * </pre>
       *
       * <code>repeated string atrace_categories_prefer_sdk = 28;</code>
       * @param index The index of the value to return.
       * @return The bytes of the atraceCategoriesPreferSdk at the given index.
       */
      public com.google.protobuf.ByteString
          getAtraceCategoriesPreferSdkBytes(int index) {
        return atraceCategoriesPreferSdk_.getByteString(index);
      }
      /**
       * <pre>
       * Some processes can emit data through atrace or through the perfetto SDK via
       * the "track_event" data source. For these categories, the SDK will be
       * preferred, if possible, for this config.
       * </pre>
       *
       * <code>repeated string atrace_categories_prefer_sdk = 28;</code>
       * @param index The index to set the value at.
       * @param value The atraceCategoriesPreferSdk to set.
       * @return This builder for chaining.
       */
      public Builder setAtraceCategoriesPreferSdk(
          int index, java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureAtraceCategoriesPreferSdkIsMutable();
        atraceCategoriesPreferSdk_.set(index, value);
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Some processes can emit data through atrace or through the perfetto SDK via
       * the "track_event" data source. For these categories, the SDK will be
       * preferred, if possible, for this config.
       * </pre>
       *
       * <code>repeated string atrace_categories_prefer_sdk = 28;</code>
       * @param value The atraceCategoriesPreferSdk to add.
       * @return This builder for chaining.
       */
      public Builder addAtraceCategoriesPreferSdk(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureAtraceCategoriesPreferSdkIsMutable();
        atraceCategoriesPreferSdk_.add(value);
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Some processes can emit data through atrace or through the perfetto SDK via
       * the "track_event" data source. For these categories, the SDK will be
       * preferred, if possible, for this config.
       * </pre>
       *
       * <code>repeated string atrace_categories_prefer_sdk = 28;</code>
       * @param values The atraceCategoriesPreferSdk to add.
       * @return This builder for chaining.
       */
      public Builder addAllAtraceCategoriesPreferSdk(
          java.lang.Iterable<java.lang.String> values) {
        ensureAtraceCategoriesPreferSdkIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, atraceCategoriesPreferSdk_);
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Some processes can emit data through atrace or through the perfetto SDK via
       * the "track_event" data source. For these categories, the SDK will be
       * preferred, if possible, for this config.
       * </pre>
       *
       * <code>repeated string atrace_categories_prefer_sdk = 28;</code>
       * @return This builder for chaining.
       */
      public Builder clearAtraceCategoriesPreferSdk() {
        atraceCategoriesPreferSdk_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
        bitField0_ = (bitField0_ & ~0x00000008);;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Some processes can emit data through atrace or through the perfetto SDK via
       * the "track_event" data source. For these categories, the SDK will be
       * preferred, if possible, for this config.
       * </pre>
       *
       * <code>repeated string atrace_categories_prefer_sdk = 28;</code>
       * @param value The bytes of the atraceCategoriesPreferSdk to add.
       * @return This builder for chaining.
       */
      public Builder addAtraceCategoriesPreferSdkBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        ensureAtraceCategoriesPreferSdkIsMutable();
        atraceCategoriesPreferSdk_.add(value);
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }

      private int bufferSizeKb_ ;
      /**
       * <pre>
       * Size of each per-cpu kernel ftrace ring buffer.
       * Not guaranteed if there are multiple concurrent tracing sessions, as the
       * buffers cannot be resized without pausing recording in the kernel.
       * </pre>
       *
       * <code>optional uint32 buffer_size_kb = 10;</code>
       * @return Whether the bufferSizeKb field is set.
       */
      @java.lang.Override
      public boolean hasBufferSizeKb() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * Size of each per-cpu kernel ftrace ring buffer.
       * Not guaranteed if there are multiple concurrent tracing sessions, as the
       * buffers cannot be resized without pausing recording in the kernel.
       * </pre>
       *
       * <code>optional uint32 buffer_size_kb = 10;</code>
       * @return The bufferSizeKb.
       */
      @java.lang.Override
      public int getBufferSizeKb() {
        return bufferSizeKb_;
      }
      /**
       * <pre>
       * Size of each per-cpu kernel ftrace ring buffer.
       * Not guaranteed if there are multiple concurrent tracing sessions, as the
       * buffers cannot be resized without pausing recording in the kernel.
       * </pre>
       *
       * <code>optional uint32 buffer_size_kb = 10;</code>
       * @param value The bufferSizeKb to set.
       * @return This builder for chaining.
       */
      public Builder setBufferSizeKb(int value) {

        bufferSizeKb_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Size of each per-cpu kernel ftrace ring buffer.
       * Not guaranteed if there are multiple concurrent tracing sessions, as the
       * buffers cannot be resized without pausing recording in the kernel.
       * </pre>
       *
       * <code>optional uint32 buffer_size_kb = 10;</code>
       * @return This builder for chaining.
       */
      public Builder clearBufferSizeKb() {
        bitField0_ = (bitField0_ & ~0x00000010);
        bufferSizeKb_ = 0;
        onChanged();
        return this;
      }

      private int drainPeriodMs_ ;
      /**
       * <pre>
       * If set, specifies how often the tracing daemon reads from the kernel ring
       * buffer. Not guaranteed if there are multiple concurrent tracing sessions.
       * Leave unset unless you're fine-tuning a local config.
       * </pre>
       *
       * <code>optional uint32 drain_period_ms = 11;</code>
       * @return Whether the drainPeriodMs field is set.
       */
      @java.lang.Override
      public boolean hasDrainPeriodMs() {
        return ((bitField0_ & 0x00000020) != 0);
      }
      /**
       * <pre>
       * If set, specifies how often the tracing daemon reads from the kernel ring
       * buffer. Not guaranteed if there are multiple concurrent tracing sessions.
       * Leave unset unless you're fine-tuning a local config.
       * </pre>
       *
       * <code>optional uint32 drain_period_ms = 11;</code>
       * @return The drainPeriodMs.
       */
      @java.lang.Override
      public int getDrainPeriodMs() {
        return drainPeriodMs_;
      }
      /**
       * <pre>
       * If set, specifies how often the tracing daemon reads from the kernel ring
       * buffer. Not guaranteed if there are multiple concurrent tracing sessions.
       * Leave unset unless you're fine-tuning a local config.
       * </pre>
       *
       * <code>optional uint32 drain_period_ms = 11;</code>
       * @param value The drainPeriodMs to set.
       * @return This builder for chaining.
       */
      public Builder setDrainPeriodMs(int value) {

        drainPeriodMs_ = value;
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If set, specifies how often the tracing daemon reads from the kernel ring
       * buffer. Not guaranteed if there are multiple concurrent tracing sessions.
       * Leave unset unless you're fine-tuning a local config.
       * </pre>
       *
       * <code>optional uint32 drain_period_ms = 11;</code>
       * @return This builder for chaining.
       */
      public Builder clearDrainPeriodMs() {
        bitField0_ = (bitField0_ & ~0x00000020);
        drainPeriodMs_ = 0;
        onChanged();
        return this;
      }

      private int drainBufferPercent_ ;
      /**
       * <pre>
       * If set, the tracing daemon will read kernel ring buffers as soon as
       * they're filled past this percentage of occupancy. In other words, a value
       * of 50 means that a read pass is triggered as soon as any per-cpu buffer is
       * half-full. Not guaranteed if there are multiple concurrent tracing
       * sessions.
       * Currently does nothing on Linux kernels below v6.9.
       * Introduced in: perfetto v48.
       * </pre>
       *
       * <code>optional uint32 drain_buffer_percent = 29;</code>
       * @return Whether the drainBufferPercent field is set.
       */
      @java.lang.Override
      public boolean hasDrainBufferPercent() {
        return ((bitField0_ & 0x00000040) != 0);
      }
      /**
       * <pre>
       * If set, the tracing daemon will read kernel ring buffers as soon as
       * they're filled past this percentage of occupancy. In other words, a value
       * of 50 means that a read pass is triggered as soon as any per-cpu buffer is
       * half-full. Not guaranteed if there are multiple concurrent tracing
       * sessions.
       * Currently does nothing on Linux kernels below v6.9.
       * Introduced in: perfetto v48.
       * </pre>
       *
       * <code>optional uint32 drain_buffer_percent = 29;</code>
       * @return The drainBufferPercent.
       */
      @java.lang.Override
      public int getDrainBufferPercent() {
        return drainBufferPercent_;
      }
      /**
       * <pre>
       * If set, the tracing daemon will read kernel ring buffers as soon as
       * they're filled past this percentage of occupancy. In other words, a value
       * of 50 means that a read pass is triggered as soon as any per-cpu buffer is
       * half-full. Not guaranteed if there are multiple concurrent tracing
       * sessions.
       * Currently does nothing on Linux kernels below v6.9.
       * Introduced in: perfetto v48.
       * </pre>
       *
       * <code>optional uint32 drain_buffer_percent = 29;</code>
       * @param value The drainBufferPercent to set.
       * @return This builder for chaining.
       */
      public Builder setDrainBufferPercent(int value) {

        drainBufferPercent_ = value;
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If set, the tracing daemon will read kernel ring buffers as soon as
       * they're filled past this percentage of occupancy. In other words, a value
       * of 50 means that a read pass is triggered as soon as any per-cpu buffer is
       * half-full. Not guaranteed if there are multiple concurrent tracing
       * sessions.
       * Currently does nothing on Linux kernels below v6.9.
       * Introduced in: perfetto v48.
       * </pre>
       *
       * <code>optional uint32 drain_buffer_percent = 29;</code>
       * @return This builder for chaining.
       */
      public Builder clearDrainBufferPercent() {
        bitField0_ = (bitField0_ & ~0x00000040);
        drainBufferPercent_ = 0;
        onChanged();
        return this;
      }

      private perfetto.protos.FtraceConfigOuterClass.FtraceConfig.CompactSchedConfig compactSched_;
      private com.google.protobuf.SingleFieldBuilder<
          perfetto.protos.FtraceConfigOuterClass.FtraceConfig.CompactSchedConfig, perfetto.protos.FtraceConfigOuterClass.FtraceConfig.CompactSchedConfig.Builder, perfetto.protos.FtraceConfigOuterClass.FtraceConfig.CompactSchedConfigOrBuilder> compactSchedBuilder_;
      /**
       * <code>optional .perfetto.protos.FtraceConfig.CompactSchedConfig compact_sched = 12;</code>
       * @return Whether the compactSched field is set.
       */
      public boolean hasCompactSched() {
        return ((bitField0_ & 0x00000080) != 0);
      }
      /**
       * <code>optional .perfetto.protos.FtraceConfig.CompactSchedConfig compact_sched = 12;</code>
       * @return The compactSched.
       */
      public perfetto.protos.FtraceConfigOuterClass.FtraceConfig.CompactSchedConfig getCompactSched() {
        if (compactSchedBuilder_ == null) {
          return compactSched_ == null ? perfetto.protos.FtraceConfigOuterClass.FtraceConfig.CompactSchedConfig.getDefaultInstance() : compactSched_;
        } else {
          return compactSchedBuilder_.getMessage();
        }
      }
      /**
       * <code>optional .perfetto.protos.FtraceConfig.CompactSchedConfig compact_sched = 12;</code>
       */
      public Builder setCompactSched(perfetto.protos.FtraceConfigOuterClass.FtraceConfig.CompactSchedConfig value) {
        if (compactSchedBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          compactSched_ = value;
        } else {
          compactSchedBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }
      /**
       * <code>optional .perfetto.protos.FtraceConfig.CompactSchedConfig compact_sched = 12;</code>
       */
      public Builder setCompactSched(
          perfetto.protos.FtraceConfigOuterClass.FtraceConfig.CompactSchedConfig.Builder builderForValue) {
        if (compactSchedBuilder_ == null) {
          compactSched_ = builderForValue.build();
        } else {
          compactSchedBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }
      /**
       * <code>optional .perfetto.protos.FtraceConfig.CompactSchedConfig compact_sched = 12;</code>
       */
      public Builder mergeCompactSched(perfetto.protos.FtraceConfigOuterClass.FtraceConfig.CompactSchedConfig value) {
        if (compactSchedBuilder_ == null) {
          if (((bitField0_ & 0x00000080) != 0) &&
            compactSched_ != null &&
            compactSched_ != perfetto.protos.FtraceConfigOuterClass.FtraceConfig.CompactSchedConfig.getDefaultInstance()) {
            getCompactSchedBuilder().mergeFrom(value);
          } else {
            compactSched_ = value;
          }
        } else {
          compactSchedBuilder_.mergeFrom(value);
        }
        if (compactSched_ != null) {
          bitField0_ |= 0x00000080;
          onChanged();
        }
        return this;
      }
      /**
       * <code>optional .perfetto.protos.FtraceConfig.CompactSchedConfig compact_sched = 12;</code>
       */
      public Builder clearCompactSched() {
        bitField0_ = (bitField0_ & ~0x00000080);
        compactSched_ = null;
        if (compactSchedBuilder_ != null) {
          compactSchedBuilder_.dispose();
          compactSchedBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <code>optional .perfetto.protos.FtraceConfig.CompactSchedConfig compact_sched = 12;</code>
       */
      public perfetto.protos.FtraceConfigOuterClass.FtraceConfig.CompactSchedConfig.Builder getCompactSchedBuilder() {
        bitField0_ |= 0x00000080;
        onChanged();
        return getCompactSchedFieldBuilder().getBuilder();
      }
      /**
       * <code>optional .perfetto.protos.FtraceConfig.CompactSchedConfig compact_sched = 12;</code>
       */
      public perfetto.protos.FtraceConfigOuterClass.FtraceConfig.CompactSchedConfigOrBuilder getCompactSchedOrBuilder() {
        if (compactSchedBuilder_ != null) {
          return compactSchedBuilder_.getMessageOrBuilder();
        } else {
          return compactSched_ == null ?
              perfetto.protos.FtraceConfigOuterClass.FtraceConfig.CompactSchedConfig.getDefaultInstance() : compactSched_;
        }
      }
      /**
       * <code>optional .perfetto.protos.FtraceConfig.CompactSchedConfig compact_sched = 12;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          perfetto.protos.FtraceConfigOuterClass.FtraceConfig.CompactSchedConfig, perfetto.protos.FtraceConfigOuterClass.FtraceConfig.CompactSchedConfig.Builder, perfetto.protos.FtraceConfigOuterClass.FtraceConfig.CompactSchedConfigOrBuilder> 
          getCompactSchedFieldBuilder() {
        if (compactSchedBuilder_ == null) {
          compactSchedBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              perfetto.protos.FtraceConfigOuterClass.FtraceConfig.CompactSchedConfig, perfetto.protos.FtraceConfigOuterClass.FtraceConfig.CompactSchedConfig.Builder, perfetto.protos.FtraceConfigOuterClass.FtraceConfig.CompactSchedConfigOrBuilder>(
                  getCompactSched(),
                  getParentForChildren(),
                  isClean());
          compactSched_ = null;
        }
        return compactSchedBuilder_;
      }

      private perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter printFilter_;
      private com.google.protobuf.SingleFieldBuilder<
          perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter, perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Builder, perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilterOrBuilder> printFilterBuilder_;
      /**
       * <code>optional .perfetto.protos.FtraceConfig.PrintFilter print_filter = 22;</code>
       * @return Whether the printFilter field is set.
       */
      public boolean hasPrintFilter() {
        return ((bitField0_ & 0x00000100) != 0);
      }
      /**
       * <code>optional .perfetto.protos.FtraceConfig.PrintFilter print_filter = 22;</code>
       * @return The printFilter.
       */
      public perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter getPrintFilter() {
        if (printFilterBuilder_ == null) {
          return printFilter_ == null ? perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.getDefaultInstance() : printFilter_;
        } else {
          return printFilterBuilder_.getMessage();
        }
      }
      /**
       * <code>optional .perfetto.protos.FtraceConfig.PrintFilter print_filter = 22;</code>
       */
      public Builder setPrintFilter(perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter value) {
        if (printFilterBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          printFilter_ = value;
        } else {
          printFilterBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000100;
        onChanged();
        return this;
      }
      /**
       * <code>optional .perfetto.protos.FtraceConfig.PrintFilter print_filter = 22;</code>
       */
      public Builder setPrintFilter(
          perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Builder builderForValue) {
        if (printFilterBuilder_ == null) {
          printFilter_ = builderForValue.build();
        } else {
          printFilterBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000100;
        onChanged();
        return this;
      }
      /**
       * <code>optional .perfetto.protos.FtraceConfig.PrintFilter print_filter = 22;</code>
       */
      public Builder mergePrintFilter(perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter value) {
        if (printFilterBuilder_ == null) {
          if (((bitField0_ & 0x00000100) != 0) &&
            printFilter_ != null &&
            printFilter_ != perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.getDefaultInstance()) {
            getPrintFilterBuilder().mergeFrom(value);
          } else {
            printFilter_ = value;
          }
        } else {
          printFilterBuilder_.mergeFrom(value);
        }
        if (printFilter_ != null) {
          bitField0_ |= 0x00000100;
          onChanged();
        }
        return this;
      }
      /**
       * <code>optional .perfetto.protos.FtraceConfig.PrintFilter print_filter = 22;</code>
       */
      public Builder clearPrintFilter() {
        bitField0_ = (bitField0_ & ~0x00000100);
        printFilter_ = null;
        if (printFilterBuilder_ != null) {
          printFilterBuilder_.dispose();
          printFilterBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <code>optional .perfetto.protos.FtraceConfig.PrintFilter print_filter = 22;</code>
       */
      public perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Builder getPrintFilterBuilder() {
        bitField0_ |= 0x00000100;
        onChanged();
        return getPrintFilterFieldBuilder().getBuilder();
      }
      /**
       * <code>optional .perfetto.protos.FtraceConfig.PrintFilter print_filter = 22;</code>
       */
      public perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilterOrBuilder getPrintFilterOrBuilder() {
        if (printFilterBuilder_ != null) {
          return printFilterBuilder_.getMessageOrBuilder();
        } else {
          return printFilter_ == null ?
              perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.getDefaultInstance() : printFilter_;
        }
      }
      /**
       * <code>optional .perfetto.protos.FtraceConfig.PrintFilter print_filter = 22;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter, perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Builder, perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilterOrBuilder> 
          getPrintFilterFieldBuilder() {
        if (printFilterBuilder_ == null) {
          printFilterBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter, perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilter.Builder, perfetto.protos.FtraceConfigOuterClass.FtraceConfig.PrintFilterOrBuilder>(
                  getPrintFilter(),
                  getParentForChildren(),
                  isClean());
          printFilter_ = null;
        }
        return printFilterBuilder_;
      }

      private boolean symbolizeKsyms_ ;
      /**
       * <pre>
       * Enables symbol name resolution against /proc/kallsyms.
       * It requires that either traced_probes is running as root or that
       * kptr_restrict has been manually lowered.
       * It does not disclose KASLR, symbol addresses are mangled.
       * </pre>
       *
       * <code>optional bool symbolize_ksyms = 13;</code>
       * @return Whether the symbolizeKsyms field is set.
       */
      @java.lang.Override
      public boolean hasSymbolizeKsyms() {
        return ((bitField0_ & 0x00000200) != 0);
      }
      /**
       * <pre>
       * Enables symbol name resolution against /proc/kallsyms.
       * It requires that either traced_probes is running as root or that
       * kptr_restrict has been manually lowered.
       * It does not disclose KASLR, symbol addresses are mangled.
       * </pre>
       *
       * <code>optional bool symbolize_ksyms = 13;</code>
       * @return The symbolizeKsyms.
       */
      @java.lang.Override
      public boolean getSymbolizeKsyms() {
        return symbolizeKsyms_;
      }
      /**
       * <pre>
       * Enables symbol name resolution against /proc/kallsyms.
       * It requires that either traced_probes is running as root or that
       * kptr_restrict has been manually lowered.
       * It does not disclose KASLR, symbol addresses are mangled.
       * </pre>
       *
       * <code>optional bool symbolize_ksyms = 13;</code>
       * @param value The symbolizeKsyms to set.
       * @return This builder for chaining.
       */
      public Builder setSymbolizeKsyms(boolean value) {

        symbolizeKsyms_ = value;
        bitField0_ |= 0x00000200;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Enables symbol name resolution against /proc/kallsyms.
       * It requires that either traced_probes is running as root or that
       * kptr_restrict has been manually lowered.
       * It does not disclose KASLR, symbol addresses are mangled.
       * </pre>
       *
       * <code>optional bool symbolize_ksyms = 13;</code>
       * @return This builder for chaining.
       */
      public Builder clearSymbolizeKsyms() {
        bitField0_ = (bitField0_ & ~0x00000200);
        symbolizeKsyms_ = false;
        onChanged();
        return this;
      }

      private int ksymsMemPolicy_ = 0;
      /**
       * <code>optional .perfetto.protos.FtraceConfig.KsymsMemPolicy ksyms_mem_policy = 17;</code>
       * @return Whether the ksymsMemPolicy field is set.
       */
      @java.lang.Override public boolean hasKsymsMemPolicy() {
        return ((bitField0_ & 0x00000400) != 0);
      }
      /**
       * <code>optional .perfetto.protos.FtraceConfig.KsymsMemPolicy ksyms_mem_policy = 17;</code>
       * @return The ksymsMemPolicy.
       */
      @java.lang.Override
      public perfetto.protos.FtraceConfigOuterClass.FtraceConfig.KsymsMemPolicy getKsymsMemPolicy() {
        perfetto.protos.FtraceConfigOuterClass.FtraceConfig.KsymsMemPolicy result = perfetto.protos.FtraceConfigOuterClass.FtraceConfig.KsymsMemPolicy.forNumber(ksymsMemPolicy_);
        return result == null ? perfetto.protos.FtraceConfigOuterClass.FtraceConfig.KsymsMemPolicy.KSYMS_UNSPECIFIED : result;
      }
      /**
       * <code>optional .perfetto.protos.FtraceConfig.KsymsMemPolicy ksyms_mem_policy = 17;</code>
       * @param value The ksymsMemPolicy to set.
       * @return This builder for chaining.
       */
      public Builder setKsymsMemPolicy(perfetto.protos.FtraceConfigOuterClass.FtraceConfig.KsymsMemPolicy value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000400;
        ksymsMemPolicy_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <code>optional .perfetto.protos.FtraceConfig.KsymsMemPolicy ksyms_mem_policy = 17;</code>
       * @return This builder for chaining.
       */
      public Builder clearKsymsMemPolicy() {
        bitField0_ = (bitField0_ & ~0x00000400);
        ksymsMemPolicy_ = 0;
        onChanged();
        return this;
      }

      private boolean initializeKsymsSynchronouslyForTesting_ ;
      /**
       * <pre>
       * By default the kernel symbolizer is lazily initialized on a deferred task
       * to reduce ftrace's time-to-start-recording. Unfortunately that makes
       * ksyms integration tests hard. This flag forces the kernel symbolizer to be
       * initialized synchronously on the data source start and hence avoiding
       * timing races in tests.
       * DEPRECATED in v28 / Android U. This is now the default behavior, setting it
       * to true is a no-op.
       * </pre>
       *
       * <code>optional bool initialize_ksyms_synchronously_for_testing = 14 [deprecated = true];</code>
       * @deprecated perfetto.protos.FtraceConfig.initialize_ksyms_synchronously_for_testing is deprecated.
       *     See protos/perfetto/config/ftrace/ftrace_config.proto;l=123
       * @return Whether the initializeKsymsSynchronouslyForTesting field is set.
       */
      @java.lang.Override
      @java.lang.Deprecated public boolean hasInitializeKsymsSynchronouslyForTesting() {
        return ((bitField0_ & 0x00000800) != 0);
      }
      /**
       * <pre>
       * By default the kernel symbolizer is lazily initialized on a deferred task
       * to reduce ftrace's time-to-start-recording. Unfortunately that makes
       * ksyms integration tests hard. This flag forces the kernel symbolizer to be
       * initialized synchronously on the data source start and hence avoiding
       * timing races in tests.
       * DEPRECATED in v28 / Android U. This is now the default behavior, setting it
       * to true is a no-op.
       * </pre>
       *
       * <code>optional bool initialize_ksyms_synchronously_for_testing = 14 [deprecated = true];</code>
       * @deprecated perfetto.protos.FtraceConfig.initialize_ksyms_synchronously_for_testing is deprecated.
       *     See protos/perfetto/config/ftrace/ftrace_config.proto;l=123
       * @return The initializeKsymsSynchronouslyForTesting.
       */
      @java.lang.Override
      @java.lang.Deprecated public boolean getInitializeKsymsSynchronouslyForTesting() {
        return initializeKsymsSynchronouslyForTesting_;
      }
      /**
       * <pre>
       * By default the kernel symbolizer is lazily initialized on a deferred task
       * to reduce ftrace's time-to-start-recording. Unfortunately that makes
       * ksyms integration tests hard. This flag forces the kernel symbolizer to be
       * initialized synchronously on the data source start and hence avoiding
       * timing races in tests.
       * DEPRECATED in v28 / Android U. This is now the default behavior, setting it
       * to true is a no-op.
       * </pre>
       *
       * <code>optional bool initialize_ksyms_synchronously_for_testing = 14 [deprecated = true];</code>
       * @deprecated perfetto.protos.FtraceConfig.initialize_ksyms_synchronously_for_testing is deprecated.
       *     See protos/perfetto/config/ftrace/ftrace_config.proto;l=123
       * @param value The initializeKsymsSynchronouslyForTesting to set.
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder setInitializeKsymsSynchronouslyForTesting(boolean value) {

        initializeKsymsSynchronouslyForTesting_ = value;
        bitField0_ |= 0x00000800;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * By default the kernel symbolizer is lazily initialized on a deferred task
       * to reduce ftrace's time-to-start-recording. Unfortunately that makes
       * ksyms integration tests hard. This flag forces the kernel symbolizer to be
       * initialized synchronously on the data source start and hence avoiding
       * timing races in tests.
       * DEPRECATED in v28 / Android U. This is now the default behavior, setting it
       * to true is a no-op.
       * </pre>
       *
       * <code>optional bool initialize_ksyms_synchronously_for_testing = 14 [deprecated = true];</code>
       * @deprecated perfetto.protos.FtraceConfig.initialize_ksyms_synchronously_for_testing is deprecated.
       *     See protos/perfetto/config/ftrace/ftrace_config.proto;l=123
       * @return This builder for chaining.
       */
      @java.lang.Deprecated public Builder clearInitializeKsymsSynchronouslyForTesting() {
        bitField0_ = (bitField0_ & ~0x00000800);
        initializeKsymsSynchronouslyForTesting_ = false;
        onChanged();
        return this;
      }

      private boolean throttleRssStat_ ;
      /**
       * <pre>
       * When this boolean is true AND the ftrace_events contains "kmem/rss_stat",
       * this option causes traced_probes to enable the "kmem/rss_stat_throttled"
       * event instead if present, and fall back to "kmem/rss_stat" if not present.
       * The historical context for this is the following:
       * - Up to Android S (12), the rss_stat was internally throttled in its
       * kernel implementation.
       * - A change introduced in the kernels after S has introduced a new
       * "rss_stat_throttled" making the original "rss_stat" event unthrottled
       * (hence very spammy).
       * - Not all Android T/13 devices will receive a new kernel though, hence we
       * need to deal with both cases.
       * For more context: go/rss-stat-throttled.
       * </pre>
       *
       * <code>optional bool throttle_rss_stat = 15;</code>
       * @return Whether the throttleRssStat field is set.
       */
      @java.lang.Override
      public boolean hasThrottleRssStat() {
        return ((bitField0_ & 0x00001000) != 0);
      }
      /**
       * <pre>
       * When this boolean is true AND the ftrace_events contains "kmem/rss_stat",
       * this option causes traced_probes to enable the "kmem/rss_stat_throttled"
       * event instead if present, and fall back to "kmem/rss_stat" if not present.
       * The historical context for this is the following:
       * - Up to Android S (12), the rss_stat was internally throttled in its
       * kernel implementation.
       * - A change introduced in the kernels after S has introduced a new
       * "rss_stat_throttled" making the original "rss_stat" event unthrottled
       * (hence very spammy).
       * - Not all Android T/13 devices will receive a new kernel though, hence we
       * need to deal with both cases.
       * For more context: go/rss-stat-throttled.
       * </pre>
       *
       * <code>optional bool throttle_rss_stat = 15;</code>
       * @return The throttleRssStat.
       */
      @java.lang.Override
      public boolean getThrottleRssStat() {
        return throttleRssStat_;
      }
      /**
       * <pre>
       * When this boolean is true AND the ftrace_events contains "kmem/rss_stat",
       * this option causes traced_probes to enable the "kmem/rss_stat_throttled"
       * event instead if present, and fall back to "kmem/rss_stat" if not present.
       * The historical context for this is the following:
       * - Up to Android S (12), the rss_stat was internally throttled in its
       * kernel implementation.
       * - A change introduced in the kernels after S has introduced a new
       * "rss_stat_throttled" making the original "rss_stat" event unthrottled
       * (hence very spammy).
       * - Not all Android T/13 devices will receive a new kernel though, hence we
       * need to deal with both cases.
       * For more context: go/rss-stat-throttled.
       * </pre>
       *
       * <code>optional bool throttle_rss_stat = 15;</code>
       * @param value The throttleRssStat to set.
       * @return This builder for chaining.
       */
      public Builder setThrottleRssStat(boolean value) {

        throttleRssStat_ = value;
        bitField0_ |= 0x00001000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * When this boolean is true AND the ftrace_events contains "kmem/rss_stat",
       * this option causes traced_probes to enable the "kmem/rss_stat_throttled"
       * event instead if present, and fall back to "kmem/rss_stat" if not present.
       * The historical context for this is the following:
       * - Up to Android S (12), the rss_stat was internally throttled in its
       * kernel implementation.
       * - A change introduced in the kernels after S has introduced a new
       * "rss_stat_throttled" making the original "rss_stat" event unthrottled
       * (hence very spammy).
       * - Not all Android T/13 devices will receive a new kernel though, hence we
       * need to deal with both cases.
       * For more context: go/rss-stat-throttled.
       * </pre>
       *
       * <code>optional bool throttle_rss_stat = 15;</code>
       * @return This builder for chaining.
       */
      public Builder clearThrottleRssStat() {
        bitField0_ = (bitField0_ & ~0x00001000);
        throttleRssStat_ = false;
        onChanged();
        return this;
      }

      private boolean disableGenericEvents_ ;
      /**
       * <pre>
       * If true, avoid enabling events that aren't statically known by
       * traced_probes. Otherwise, the default is to emit such events as
       * GenericFtraceEvent protos.
       * Prefer to keep this flag at its default. This was added for Android
       * tracing, where atrace categories and/or atrace HAL requested events can
       * expand to events that aren't of interest to the tracing user.
       * Introduced in: Android T.
       * </pre>
       *
       * <code>optional bool disable_generic_events = 16;</code>
       * @return Whether the disableGenericEvents field is set.
       */
      @java.lang.Override
      public boolean hasDisableGenericEvents() {
        return ((bitField0_ & 0x00002000) != 0);
      }
      /**
       * <pre>
       * If true, avoid enabling events that aren't statically known by
       * traced_probes. Otherwise, the default is to emit such events as
       * GenericFtraceEvent protos.
       * Prefer to keep this flag at its default. This was added for Android
       * tracing, where atrace categories and/or atrace HAL requested events can
       * expand to events that aren't of interest to the tracing user.
       * Introduced in: Android T.
       * </pre>
       *
       * <code>optional bool disable_generic_events = 16;</code>
       * @return The disableGenericEvents.
       */
      @java.lang.Override
      public boolean getDisableGenericEvents() {
        return disableGenericEvents_;
      }
      /**
       * <pre>
       * If true, avoid enabling events that aren't statically known by
       * traced_probes. Otherwise, the default is to emit such events as
       * GenericFtraceEvent protos.
       * Prefer to keep this flag at its default. This was added for Android
       * tracing, where atrace categories and/or atrace HAL requested events can
       * expand to events that aren't of interest to the tracing user.
       * Introduced in: Android T.
       * </pre>
       *
       * <code>optional bool disable_generic_events = 16;</code>
       * @param value The disableGenericEvents to set.
       * @return This builder for chaining.
       */
      public Builder setDisableGenericEvents(boolean value) {

        disableGenericEvents_ = value;
        bitField0_ |= 0x00002000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If true, avoid enabling events that aren't statically known by
       * traced_probes. Otherwise, the default is to emit such events as
       * GenericFtraceEvent protos.
       * Prefer to keep this flag at its default. This was added for Android
       * tracing, where atrace categories and/or atrace HAL requested events can
       * expand to events that aren't of interest to the tracing user.
       * Introduced in: Android T.
       * </pre>
       *
       * <code>optional bool disable_generic_events = 16;</code>
       * @return This builder for chaining.
       */
      public Builder clearDisableGenericEvents() {
        bitField0_ = (bitField0_ & ~0x00002000);
        disableGenericEvents_ = false;
        onChanged();
        return this;
      }

      private com.google.protobuf.LazyStringArrayList syscallEvents_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
      private void ensureSyscallEventsIsMutable() {
        if (!syscallEvents_.isModifiable()) {
          syscallEvents_ = new com.google.protobuf.LazyStringArrayList(syscallEvents_);
        }
        bitField0_ |= 0x00004000;
      }
      /**
       * <pre>
       * The subset of syscalls to record. To record all syscalls, leave this unset
       * and add "ftrace_events: raw_syscalls/sys_{enter,exit}" to the config.
       * * before perfetto v43, requires the config to also enable
       * raw_syscalls/sys_{enter,exit}.
       * * perfetto v43+ does the right thing if you set only this field.
       * Example: ["sys_read", "sys_open"].
       * Introduced in: Android U.
       * </pre>
       *
       * <code>repeated string syscall_events = 18;</code>
       * @return A list containing the syscallEvents.
       */
      public com.google.protobuf.ProtocolStringList
          getSyscallEventsList() {
        syscallEvents_.makeImmutable();
        return syscallEvents_;
      }
      /**
       * <pre>
       * The subset of syscalls to record. To record all syscalls, leave this unset
       * and add "ftrace_events: raw_syscalls/sys_{enter,exit}" to the config.
       * * before perfetto v43, requires the config to also enable
       * raw_syscalls/sys_{enter,exit}.
       * * perfetto v43+ does the right thing if you set only this field.
       * Example: ["sys_read", "sys_open"].
       * Introduced in: Android U.
       * </pre>
       *
       * <code>repeated string syscall_events = 18;</code>
       * @return The count of syscallEvents.
       */
      public int getSyscallEventsCount() {
        return syscallEvents_.size();
      }
      /**
       * <pre>
       * The subset of syscalls to record. To record all syscalls, leave this unset
       * and add "ftrace_events: raw_syscalls/sys_{enter,exit}" to the config.
       * * before perfetto v43, requires the config to also enable
       * raw_syscalls/sys_{enter,exit}.
       * * perfetto v43+ does the right thing if you set only this field.
       * Example: ["sys_read", "sys_open"].
       * Introduced in: Android U.
       * </pre>
       *
       * <code>repeated string syscall_events = 18;</code>
       * @param index The index of the element to return.
       * @return The syscallEvents at the given index.
       */
      public java.lang.String getSyscallEvents(int index) {
        return syscallEvents_.get(index);
      }
      /**
       * <pre>
       * The subset of syscalls to record. To record all syscalls, leave this unset
       * and add "ftrace_events: raw_syscalls/sys_{enter,exit}" to the config.
       * * before perfetto v43, requires the config to also enable
       * raw_syscalls/sys_{enter,exit}.
       * * perfetto v43+ does the right thing if you set only this field.
       * Example: ["sys_read", "sys_open"].
       * Introduced in: Android U.
       * </pre>
       *
       * <code>repeated string syscall_events = 18;</code>
       * @param index The index of the value to return.
       * @return The bytes of the syscallEvents at the given index.
       */
      public com.google.protobuf.ByteString
          getSyscallEventsBytes(int index) {
        return syscallEvents_.getByteString(index);
      }
      /**
       * <pre>
       * The subset of syscalls to record. To record all syscalls, leave this unset
       * and add "ftrace_events: raw_syscalls/sys_{enter,exit}" to the config.
       * * before perfetto v43, requires the config to also enable
       * raw_syscalls/sys_{enter,exit}.
       * * perfetto v43+ does the right thing if you set only this field.
       * Example: ["sys_read", "sys_open"].
       * Introduced in: Android U.
       * </pre>
       *
       * <code>repeated string syscall_events = 18;</code>
       * @param index The index to set the value at.
       * @param value The syscallEvents to set.
       * @return This builder for chaining.
       */
      public Builder setSyscallEvents(
          int index, java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureSyscallEventsIsMutable();
        syscallEvents_.set(index, value);
        bitField0_ |= 0x00004000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The subset of syscalls to record. To record all syscalls, leave this unset
       * and add "ftrace_events: raw_syscalls/sys_{enter,exit}" to the config.
       * * before perfetto v43, requires the config to also enable
       * raw_syscalls/sys_{enter,exit}.
       * * perfetto v43+ does the right thing if you set only this field.
       * Example: ["sys_read", "sys_open"].
       * Introduced in: Android U.
       * </pre>
       *
       * <code>repeated string syscall_events = 18;</code>
       * @param value The syscallEvents to add.
       * @return This builder for chaining.
       */
      public Builder addSyscallEvents(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureSyscallEventsIsMutable();
        syscallEvents_.add(value);
        bitField0_ |= 0x00004000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The subset of syscalls to record. To record all syscalls, leave this unset
       * and add "ftrace_events: raw_syscalls/sys_{enter,exit}" to the config.
       * * before perfetto v43, requires the config to also enable
       * raw_syscalls/sys_{enter,exit}.
       * * perfetto v43+ does the right thing if you set only this field.
       * Example: ["sys_read", "sys_open"].
       * Introduced in: Android U.
       * </pre>
       *
       * <code>repeated string syscall_events = 18;</code>
       * @param values The syscallEvents to add.
       * @return This builder for chaining.
       */
      public Builder addAllSyscallEvents(
          java.lang.Iterable<java.lang.String> values) {
        ensureSyscallEventsIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, syscallEvents_);
        bitField0_ |= 0x00004000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The subset of syscalls to record. To record all syscalls, leave this unset
       * and add "ftrace_events: raw_syscalls/sys_{enter,exit}" to the config.
       * * before perfetto v43, requires the config to also enable
       * raw_syscalls/sys_{enter,exit}.
       * * perfetto v43+ does the right thing if you set only this field.
       * Example: ["sys_read", "sys_open"].
       * Introduced in: Android U.
       * </pre>
       *
       * <code>repeated string syscall_events = 18;</code>
       * @return This builder for chaining.
       */
      public Builder clearSyscallEvents() {
        syscallEvents_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
        bitField0_ = (bitField0_ & ~0x00004000);;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The subset of syscalls to record. To record all syscalls, leave this unset
       * and add "ftrace_events: raw_syscalls/sys_{enter,exit}" to the config.
       * * before perfetto v43, requires the config to also enable
       * raw_syscalls/sys_{enter,exit}.
       * * perfetto v43+ does the right thing if you set only this field.
       * Example: ["sys_read", "sys_open"].
       * Introduced in: Android U.
       * </pre>
       *
       * <code>repeated string syscall_events = 18;</code>
       * @param value The bytes of the syscallEvents to add.
       * @return This builder for chaining.
       */
      public Builder addSyscallEventsBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        ensureSyscallEventsIsMutable();
        syscallEvents_.add(value);
        bitField0_ |= 0x00004000;
        onChanged();
        return this;
      }

      private boolean enableFunctionGraph_ ;
      /**
       * <pre>
       * If true, enable the "function_graph" kernel tracer that emits events
       * whenever a kernel function is entered and exited
       * (funcgraph_entry/funcgraph_exit).
       * Notes on use:
       * * Requires |symbolize_ksyms| for function name resolution.
       * * Use |function_filters| or |function_graph_roots| to constrain the traced
       * set of functions, otherwise the event bandwidth will be too high for
       * practical use.
       * * The data source might be rejected if there is already a concurrent
       * ftrace data source that does not use function graph itself, as we do not
       * support switching kernel tracers mid-trace.
       * * Requires a kernel compiled with CONFIG_FUNCTION_GRAPH_TRACER. This is
       * enabled if "cat /sys/kernel/tracing/available_tracers" includes
       * "function_graph".
       * Android:
       * * Available only on debuggable builds.
       * * Introduced in: Android U.
       * </pre>
       *
       * <code>optional bool enable_function_graph = 19;</code>
       * @return Whether the enableFunctionGraph field is set.
       */
      @java.lang.Override
      public boolean hasEnableFunctionGraph() {
        return ((bitField0_ & 0x00008000) != 0);
      }
      /**
       * <pre>
       * If true, enable the "function_graph" kernel tracer that emits events
       * whenever a kernel function is entered and exited
       * (funcgraph_entry/funcgraph_exit).
       * Notes on use:
       * * Requires |symbolize_ksyms| for function name resolution.
       * * Use |function_filters| or |function_graph_roots| to constrain the traced
       * set of functions, otherwise the event bandwidth will be too high for
       * practical use.
       * * The data source might be rejected if there is already a concurrent
       * ftrace data source that does not use function graph itself, as we do not
       * support switching kernel tracers mid-trace.
       * * Requires a kernel compiled with CONFIG_FUNCTION_GRAPH_TRACER. This is
       * enabled if "cat /sys/kernel/tracing/available_tracers" includes
       * "function_graph".
       * Android:
       * * Available only on debuggable builds.
       * * Introduced in: Android U.
       * </pre>
       *
       * <code>optional bool enable_function_graph = 19;</code>
       * @return The enableFunctionGraph.
       */
      @java.lang.Override
      public boolean getEnableFunctionGraph() {
        return enableFunctionGraph_;
      }
      /**
       * <pre>
       * If true, enable the "function_graph" kernel tracer that emits events
       * whenever a kernel function is entered and exited
       * (funcgraph_entry/funcgraph_exit).
       * Notes on use:
       * * Requires |symbolize_ksyms| for function name resolution.
       * * Use |function_filters| or |function_graph_roots| to constrain the traced
       * set of functions, otherwise the event bandwidth will be too high for
       * practical use.
       * * The data source might be rejected if there is already a concurrent
       * ftrace data source that does not use function graph itself, as we do not
       * support switching kernel tracers mid-trace.
       * * Requires a kernel compiled with CONFIG_FUNCTION_GRAPH_TRACER. This is
       * enabled if "cat /sys/kernel/tracing/available_tracers" includes
       * "function_graph".
       * Android:
       * * Available only on debuggable builds.
       * * Introduced in: Android U.
       * </pre>
       *
       * <code>optional bool enable_function_graph = 19;</code>
       * @param value The enableFunctionGraph to set.
       * @return This builder for chaining.
       */
      public Builder setEnableFunctionGraph(boolean value) {

        enableFunctionGraph_ = value;
        bitField0_ |= 0x00008000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If true, enable the "function_graph" kernel tracer that emits events
       * whenever a kernel function is entered and exited
       * (funcgraph_entry/funcgraph_exit).
       * Notes on use:
       * * Requires |symbolize_ksyms| for function name resolution.
       * * Use |function_filters| or |function_graph_roots| to constrain the traced
       * set of functions, otherwise the event bandwidth will be too high for
       * practical use.
       * * The data source might be rejected if there is already a concurrent
       * ftrace data source that does not use function graph itself, as we do not
       * support switching kernel tracers mid-trace.
       * * Requires a kernel compiled with CONFIG_FUNCTION_GRAPH_TRACER. This is
       * enabled if "cat /sys/kernel/tracing/available_tracers" includes
       * "function_graph".
       * Android:
       * * Available only on debuggable builds.
       * * Introduced in: Android U.
       * </pre>
       *
       * <code>optional bool enable_function_graph = 19;</code>
       * @return This builder for chaining.
       */
      public Builder clearEnableFunctionGraph() {
        bitField0_ = (bitField0_ & ~0x00008000);
        enableFunctionGraph_ = false;
        onChanged();
        return this;
      }

      private com.google.protobuf.LazyStringArrayList functionFilters_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
      private void ensureFunctionFiltersIsMutable() {
        if (!functionFilters_.isModifiable()) {
          functionFilters_ = new com.google.protobuf.LazyStringArrayList(functionFilters_);
        }
        bitField0_ |= 0x00010000;
      }
      /**
       * <pre>
       * Constrains the set of functions traced when |enable_function_graph| is
       * true. Supports globs, e.g. "sched*". You can specify multiple filters,
       * in which case all matching functions will be traced. See kernel
       * documentation on ftrace "set_ftrace_filter" file for more details.
       * Android:
       * * Available only on debuggable builds.
       * * Introduced in: Android U.
       * </pre>
       *
       * <code>repeated string function_filters = 20;</code>
       * @return A list containing the functionFilters.
       */
      public com.google.protobuf.ProtocolStringList
          getFunctionFiltersList() {
        functionFilters_.makeImmutable();
        return functionFilters_;
      }
      /**
       * <pre>
       * Constrains the set of functions traced when |enable_function_graph| is
       * true. Supports globs, e.g. "sched*". You can specify multiple filters,
       * in which case all matching functions will be traced. See kernel
       * documentation on ftrace "set_ftrace_filter" file for more details.
       * Android:
       * * Available only on debuggable builds.
       * * Introduced in: Android U.
       * </pre>
       *
       * <code>repeated string function_filters = 20;</code>
       * @return The count of functionFilters.
       */
      public int getFunctionFiltersCount() {
        return functionFilters_.size();
      }
      /**
       * <pre>
       * Constrains the set of functions traced when |enable_function_graph| is
       * true. Supports globs, e.g. "sched*". You can specify multiple filters,
       * in which case all matching functions will be traced. See kernel
       * documentation on ftrace "set_ftrace_filter" file for more details.
       * Android:
       * * Available only on debuggable builds.
       * * Introduced in: Android U.
       * </pre>
       *
       * <code>repeated string function_filters = 20;</code>
       * @param index The index of the element to return.
       * @return The functionFilters at the given index.
       */
      public java.lang.String getFunctionFilters(int index) {
        return functionFilters_.get(index);
      }
      /**
       * <pre>
       * Constrains the set of functions traced when |enable_function_graph| is
       * true. Supports globs, e.g. "sched*". You can specify multiple filters,
       * in which case all matching functions will be traced. See kernel
       * documentation on ftrace "set_ftrace_filter" file for more details.
       * Android:
       * * Available only on debuggable builds.
       * * Introduced in: Android U.
       * </pre>
       *
       * <code>repeated string function_filters = 20;</code>
       * @param index The index of the value to return.
       * @return The bytes of the functionFilters at the given index.
       */
      public com.google.protobuf.ByteString
          getFunctionFiltersBytes(int index) {
        return functionFilters_.getByteString(index);
      }
      /**
       * <pre>
       * Constrains the set of functions traced when |enable_function_graph| is
       * true. Supports globs, e.g. "sched*". You can specify multiple filters,
       * in which case all matching functions will be traced. See kernel
       * documentation on ftrace "set_ftrace_filter" file for more details.
       * Android:
       * * Available only on debuggable builds.
       * * Introduced in: Android U.
       * </pre>
       *
       * <code>repeated string function_filters = 20;</code>
       * @param index The index to set the value at.
       * @param value The functionFilters to set.
       * @return This builder for chaining.
       */
      public Builder setFunctionFilters(
          int index, java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureFunctionFiltersIsMutable();
        functionFilters_.set(index, value);
        bitField0_ |= 0x00010000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Constrains the set of functions traced when |enable_function_graph| is
       * true. Supports globs, e.g. "sched*". You can specify multiple filters,
       * in which case all matching functions will be traced. See kernel
       * documentation on ftrace "set_ftrace_filter" file for more details.
       * Android:
       * * Available only on debuggable builds.
       * * Introduced in: Android U.
       * </pre>
       *
       * <code>repeated string function_filters = 20;</code>
       * @param value The functionFilters to add.
       * @return This builder for chaining.
       */
      public Builder addFunctionFilters(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureFunctionFiltersIsMutable();
        functionFilters_.add(value);
        bitField0_ |= 0x00010000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Constrains the set of functions traced when |enable_function_graph| is
       * true. Supports globs, e.g. "sched*". You can specify multiple filters,
       * in which case all matching functions will be traced. See kernel
       * documentation on ftrace "set_ftrace_filter" file for more details.
       * Android:
       * * Available only on debuggable builds.
       * * Introduced in: Android U.
       * </pre>
       *
       * <code>repeated string function_filters = 20;</code>
       * @param values The functionFilters to add.
       * @return This builder for chaining.
       */
      public Builder addAllFunctionFilters(
          java.lang.Iterable<java.lang.String> values) {
        ensureFunctionFiltersIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, functionFilters_);
        bitField0_ |= 0x00010000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Constrains the set of functions traced when |enable_function_graph| is
       * true. Supports globs, e.g. "sched*". You can specify multiple filters,
       * in which case all matching functions will be traced. See kernel
       * documentation on ftrace "set_ftrace_filter" file for more details.
       * Android:
       * * Available only on debuggable builds.
       * * Introduced in: Android U.
       * </pre>
       *
       * <code>repeated string function_filters = 20;</code>
       * @return This builder for chaining.
       */
      public Builder clearFunctionFilters() {
        functionFilters_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
        bitField0_ = (bitField0_ & ~0x00010000);;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Constrains the set of functions traced when |enable_function_graph| is
       * true. Supports globs, e.g. "sched*". You can specify multiple filters,
       * in which case all matching functions will be traced. See kernel
       * documentation on ftrace "set_ftrace_filter" file for more details.
       * Android:
       * * Available only on debuggable builds.
       * * Introduced in: Android U.
       * </pre>
       *
       * <code>repeated string function_filters = 20;</code>
       * @param value The bytes of the functionFilters to add.
       * @return This builder for chaining.
       */
      public Builder addFunctionFiltersBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        ensureFunctionFiltersIsMutable();
        functionFilters_.add(value);
        bitField0_ |= 0x00010000;
        onChanged();
        return this;
      }

      private com.google.protobuf.LazyStringArrayList functionGraphRoots_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
      private void ensureFunctionGraphRootsIsMutable() {
        if (!functionGraphRoots_.isModifiable()) {
          functionGraphRoots_ = new com.google.protobuf.LazyStringArrayList(functionGraphRoots_);
        }
        bitField0_ |= 0x00020000;
      }
      /**
       * <pre>
       * If |enable_function_graph| is true, trace this set of functions *and* all
       * of its callees. Supports globs. Can be set together with
       * |function_filters|, in which case only callees matching the filter will be
       * traced. If setting both, you most likely want all roots to also be
       * included in |function_filters|.
       * Android:
       * * Available only on debuggable builds.
       * * Introduced in: Android U.
       * </pre>
       *
       * <code>repeated string function_graph_roots = 21;</code>
       * @return A list containing the functionGraphRoots.
       */
      public com.google.protobuf.ProtocolStringList
          getFunctionGraphRootsList() {
        functionGraphRoots_.makeImmutable();
        return functionGraphRoots_;
      }
      /**
       * <pre>
       * If |enable_function_graph| is true, trace this set of functions *and* all
       * of its callees. Supports globs. Can be set together with
       * |function_filters|, in which case only callees matching the filter will be
       * traced. If setting both, you most likely want all roots to also be
       * included in |function_filters|.
       * Android:
       * * Available only on debuggable builds.
       * * Introduced in: Android U.
       * </pre>
       *
       * <code>repeated string function_graph_roots = 21;</code>
       * @return The count of functionGraphRoots.
       */
      public int getFunctionGraphRootsCount() {
        return functionGraphRoots_.size();
      }
      /**
       * <pre>
       * If |enable_function_graph| is true, trace this set of functions *and* all
       * of its callees. Supports globs. Can be set together with
       * |function_filters|, in which case only callees matching the filter will be
       * traced. If setting both, you most likely want all roots to also be
       * included in |function_filters|.
       * Android:
       * * Available only on debuggable builds.
       * * Introduced in: Android U.
       * </pre>
       *
       * <code>repeated string function_graph_roots = 21;</code>
       * @param index The index of the element to return.
       * @return The functionGraphRoots at the given index.
       */
      public java.lang.String getFunctionGraphRoots(int index) {
        return functionGraphRoots_.get(index);
      }
      /**
       * <pre>
       * If |enable_function_graph| is true, trace this set of functions *and* all
       * of its callees. Supports globs. Can be set together with
       * |function_filters|, in which case only callees matching the filter will be
       * traced. If setting both, you most likely want all roots to also be
       * included in |function_filters|.
       * Android:
       * * Available only on debuggable builds.
       * * Introduced in: Android U.
       * </pre>
       *
       * <code>repeated string function_graph_roots = 21;</code>
       * @param index The index of the value to return.
       * @return The bytes of the functionGraphRoots at the given index.
       */
      public com.google.protobuf.ByteString
          getFunctionGraphRootsBytes(int index) {
        return functionGraphRoots_.getByteString(index);
      }
      /**
       * <pre>
       * If |enable_function_graph| is true, trace this set of functions *and* all
       * of its callees. Supports globs. Can be set together with
       * |function_filters|, in which case only callees matching the filter will be
       * traced. If setting both, you most likely want all roots to also be
       * included in |function_filters|.
       * Android:
       * * Available only on debuggable builds.
       * * Introduced in: Android U.
       * </pre>
       *
       * <code>repeated string function_graph_roots = 21;</code>
       * @param index The index to set the value at.
       * @param value The functionGraphRoots to set.
       * @return This builder for chaining.
       */
      public Builder setFunctionGraphRoots(
          int index, java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureFunctionGraphRootsIsMutable();
        functionGraphRoots_.set(index, value);
        bitField0_ |= 0x00020000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If |enable_function_graph| is true, trace this set of functions *and* all
       * of its callees. Supports globs. Can be set together with
       * |function_filters|, in which case only callees matching the filter will be
       * traced. If setting both, you most likely want all roots to also be
       * included in |function_filters|.
       * Android:
       * * Available only on debuggable builds.
       * * Introduced in: Android U.
       * </pre>
       *
       * <code>repeated string function_graph_roots = 21;</code>
       * @param value The functionGraphRoots to add.
       * @return This builder for chaining.
       */
      public Builder addFunctionGraphRoots(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureFunctionGraphRootsIsMutable();
        functionGraphRoots_.add(value);
        bitField0_ |= 0x00020000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If |enable_function_graph| is true, trace this set of functions *and* all
       * of its callees. Supports globs. Can be set together with
       * |function_filters|, in which case only callees matching the filter will be
       * traced. If setting both, you most likely want all roots to also be
       * included in |function_filters|.
       * Android:
       * * Available only on debuggable builds.
       * * Introduced in: Android U.
       * </pre>
       *
       * <code>repeated string function_graph_roots = 21;</code>
       * @param values The functionGraphRoots to add.
       * @return This builder for chaining.
       */
      public Builder addAllFunctionGraphRoots(
          java.lang.Iterable<java.lang.String> values) {
        ensureFunctionGraphRootsIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, functionGraphRoots_);
        bitField0_ |= 0x00020000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If |enable_function_graph| is true, trace this set of functions *and* all
       * of its callees. Supports globs. Can be set together with
       * |function_filters|, in which case only callees matching the filter will be
       * traced. If setting both, you most likely want all roots to also be
       * included in |function_filters|.
       * Android:
       * * Available only on debuggable builds.
       * * Introduced in: Android U.
       * </pre>
       *
       * <code>repeated string function_graph_roots = 21;</code>
       * @return This builder for chaining.
       */
      public Builder clearFunctionGraphRoots() {
        functionGraphRoots_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
        bitField0_ = (bitField0_ & ~0x00020000);;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If |enable_function_graph| is true, trace this set of functions *and* all
       * of its callees. Supports globs. Can be set together with
       * |function_filters|, in which case only callees matching the filter will be
       * traced. If setting both, you most likely want all roots to also be
       * included in |function_filters|.
       * Android:
       * * Available only on debuggable builds.
       * * Introduced in: Android U.
       * </pre>
       *
       * <code>repeated string function_graph_roots = 21;</code>
       * @param value The bytes of the functionGraphRoots to add.
       * @return This builder for chaining.
       */
      public Builder addFunctionGraphRootsBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        ensureFunctionGraphRootsIsMutable();
        functionGraphRoots_.add(value);
        bitField0_ |= 0x00020000;
        onChanged();
        return this;
      }

      private boolean preserveFtraceBuffer_ ;
      /**
       * <pre>
       * If true, does not clear ftrace buffers before the start of the program.
       * This makes sense only if this is the first ftrace data source instance
       * created after the daemon has been started. Can be useful for gathering boot
       * traces, if ftrace has been separately configured (e.g. via kernel
       * commandline).
       * </pre>
       *
       * <code>optional bool preserve_ftrace_buffer = 23;</code>
       * @return Whether the preserveFtraceBuffer field is set.
       */
      @java.lang.Override
      public boolean hasPreserveFtraceBuffer() {
        return ((bitField0_ & 0x00040000) != 0);
      }
      /**
       * <pre>
       * If true, does not clear ftrace buffers before the start of the program.
       * This makes sense only if this is the first ftrace data source instance
       * created after the daemon has been started. Can be useful for gathering boot
       * traces, if ftrace has been separately configured (e.g. via kernel
       * commandline).
       * </pre>
       *
       * <code>optional bool preserve_ftrace_buffer = 23;</code>
       * @return The preserveFtraceBuffer.
       */
      @java.lang.Override
      public boolean getPreserveFtraceBuffer() {
        return preserveFtraceBuffer_;
      }
      /**
       * <pre>
       * If true, does not clear ftrace buffers before the start of the program.
       * This makes sense only if this is the first ftrace data source instance
       * created after the daemon has been started. Can be useful for gathering boot
       * traces, if ftrace has been separately configured (e.g. via kernel
       * commandline).
       * </pre>
       *
       * <code>optional bool preserve_ftrace_buffer = 23;</code>
       * @param value The preserveFtraceBuffer to set.
       * @return This builder for chaining.
       */
      public Builder setPreserveFtraceBuffer(boolean value) {

        preserveFtraceBuffer_ = value;
        bitField0_ |= 0x00040000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If true, does not clear ftrace buffers before the start of the program.
       * This makes sense only if this is the first ftrace data source instance
       * created after the daemon has been started. Can be useful for gathering boot
       * traces, if ftrace has been separately configured (e.g. via kernel
       * commandline).
       * </pre>
       *
       * <code>optional bool preserve_ftrace_buffer = 23;</code>
       * @return This builder for chaining.
       */
      public Builder clearPreserveFtraceBuffer() {
        bitField0_ = (bitField0_ & ~0x00040000);
        preserveFtraceBuffer_ = false;
        onChanged();
        return this;
      }

      private boolean useMonotonicRawClock_ ;
      /**
       * <pre>
       * If true, overrides the default timestamp clock and uses a raw hardware
       * based monotonic clock for getting timestamps.
       * * Introduced in: Android U.
       * </pre>
       *
       * <code>optional bool use_monotonic_raw_clock = 24;</code>
       * @return Whether the useMonotonicRawClock field is set.
       */
      @java.lang.Override
      public boolean hasUseMonotonicRawClock() {
        return ((bitField0_ & 0x00080000) != 0);
      }
      /**
       * <pre>
       * If true, overrides the default timestamp clock and uses a raw hardware
       * based monotonic clock for getting timestamps.
       * * Introduced in: Android U.
       * </pre>
       *
       * <code>optional bool use_monotonic_raw_clock = 24;</code>
       * @return The useMonotonicRawClock.
       */
      @java.lang.Override
      public boolean getUseMonotonicRawClock() {
        return useMonotonicRawClock_;
      }
      /**
       * <pre>
       * If true, overrides the default timestamp clock and uses a raw hardware
       * based monotonic clock for getting timestamps.
       * * Introduced in: Android U.
       * </pre>
       *
       * <code>optional bool use_monotonic_raw_clock = 24;</code>
       * @param value The useMonotonicRawClock to set.
       * @return This builder for chaining.
       */
      public Builder setUseMonotonicRawClock(boolean value) {

        useMonotonicRawClock_ = value;
        bitField0_ |= 0x00080000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If true, overrides the default timestamp clock and uses a raw hardware
       * based monotonic clock for getting timestamps.
       * * Introduced in: Android U.
       * </pre>
       *
       * <code>optional bool use_monotonic_raw_clock = 24;</code>
       * @return This builder for chaining.
       */
      public Builder clearUseMonotonicRawClock() {
        bitField0_ = (bitField0_ & ~0x00080000);
        useMonotonicRawClock_ = false;
        onChanged();
        return this;
      }

      private java.lang.Object instanceName_ = "";
      /**
       * <pre>
       * If |instance_name| is not empty, then attempt to use that tracefs instance
       * for event recording. Normally, this means
       * `/sys/kernel/tracing/instances/$instance_name`.
       *
       * The name "hyp" is reserved.
       *
       * The instance must already exist, the tracing daemon *will not* create it
       * for you as it typically doesn't have such permissions.
       * Only a subset of features is guaranteed to work with non-default instances,
       * at the time of writing:
       * * ftrace_events
       * * buffer_size_kb
       * </pre>
       *
       * <code>optional string instance_name = 25;</code>
       * @return Whether the instanceName field is set.
       */
      public boolean hasInstanceName() {
        return ((bitField0_ & 0x00100000) != 0);
      }
      /**
       * <pre>
       * If |instance_name| is not empty, then attempt to use that tracefs instance
       * for event recording. Normally, this means
       * `/sys/kernel/tracing/instances/$instance_name`.
       *
       * The name "hyp" is reserved.
       *
       * The instance must already exist, the tracing daemon *will not* create it
       * for you as it typically doesn't have such permissions.
       * Only a subset of features is guaranteed to work with non-default instances,
       * at the time of writing:
       * * ftrace_events
       * * buffer_size_kb
       * </pre>
       *
       * <code>optional string instance_name = 25;</code>
       * @return The instanceName.
       */
      public java.lang.String getInstanceName() {
        java.lang.Object ref = instanceName_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            instanceName_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * If |instance_name| is not empty, then attempt to use that tracefs instance
       * for event recording. Normally, this means
       * `/sys/kernel/tracing/instances/$instance_name`.
       *
       * The name "hyp" is reserved.
       *
       * The instance must already exist, the tracing daemon *will not* create it
       * for you as it typically doesn't have such permissions.
       * Only a subset of features is guaranteed to work with non-default instances,
       * at the time of writing:
       * * ftrace_events
       * * buffer_size_kb
       * </pre>
       *
       * <code>optional string instance_name = 25;</code>
       * @return The bytes for instanceName.
       */
      public com.google.protobuf.ByteString
          getInstanceNameBytes() {
        java.lang.Object ref = instanceName_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          instanceName_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * If |instance_name| is not empty, then attempt to use that tracefs instance
       * for event recording. Normally, this means
       * `/sys/kernel/tracing/instances/$instance_name`.
       *
       * The name "hyp" is reserved.
       *
       * The instance must already exist, the tracing daemon *will not* create it
       * for you as it typically doesn't have such permissions.
       * Only a subset of features is guaranteed to work with non-default instances,
       * at the time of writing:
       * * ftrace_events
       * * buffer_size_kb
       * </pre>
       *
       * <code>optional string instance_name = 25;</code>
       * @param value The instanceName to set.
       * @return This builder for chaining.
       */
      public Builder setInstanceName(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        instanceName_ = value;
        bitField0_ |= 0x00100000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If |instance_name| is not empty, then attempt to use that tracefs instance
       * for event recording. Normally, this means
       * `/sys/kernel/tracing/instances/$instance_name`.
       *
       * The name "hyp" is reserved.
       *
       * The instance must already exist, the tracing daemon *will not* create it
       * for you as it typically doesn't have such permissions.
       * Only a subset of features is guaranteed to work with non-default instances,
       * at the time of writing:
       * * ftrace_events
       * * buffer_size_kb
       * </pre>
       *
       * <code>optional string instance_name = 25;</code>
       * @return This builder for chaining.
       */
      public Builder clearInstanceName() {
        instanceName_ = getDefaultInstance().getInstanceName();
        bitField0_ = (bitField0_ & ~0x00100000);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If |instance_name| is not empty, then attempt to use that tracefs instance
       * for event recording. Normally, this means
       * `/sys/kernel/tracing/instances/$instance_name`.
       *
       * The name "hyp" is reserved.
       *
       * The instance must already exist, the tracing daemon *will not* create it
       * for you as it typically doesn't have such permissions.
       * Only a subset of features is guaranteed to work with non-default instances,
       * at the time of writing:
       * * ftrace_events
       * * buffer_size_kb
       * </pre>
       *
       * <code>optional string instance_name = 25;</code>
       * @param value The bytes for instanceName to set.
       * @return This builder for chaining.
       */
      public Builder setInstanceNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        instanceName_ = value;
        bitField0_ |= 0x00100000;
        onChanged();
        return this;
      }

      private boolean bufferSizeLowerBound_ ;
      /**
       * <pre>
       * If true, |buffer_size_kb| is interpreted as a lower bound, allowing the
       * implementation to choose a bigger buffer size.
       *
       * Most configs for perfetto v43+ should simply leave both fields unset.
       *
       * If you need a config compatible with a range of perfetto builds and you
       * used to set a non-default buffer_size_kb, consider setting both fields.
       * Example:
       * buffer_size_kb: 4096
       * buffer_size_lower_bound: true
       * On older builds, the per-cpu buffers will be exactly 4 MB.
       * On v43+, buffers will be at least 4 MB.
       * In both cases, neither is guaranteed if there are other concurrent
       * perfetto ftrace sessions, as the buffers cannot be resized without pausing
       * the recording in the kernel.
       * Introduced in: perfetto v43.
       * </pre>
       *
       * <code>optional bool buffer_size_lower_bound = 27;</code>
       * @return Whether the bufferSizeLowerBound field is set.
       */
      @java.lang.Override
      public boolean hasBufferSizeLowerBound() {
        return ((bitField0_ & 0x00200000) != 0);
      }
      /**
       * <pre>
       * If true, |buffer_size_kb| is interpreted as a lower bound, allowing the
       * implementation to choose a bigger buffer size.
       *
       * Most configs for perfetto v43+ should simply leave both fields unset.
       *
       * If you need a config compatible with a range of perfetto builds and you
       * used to set a non-default buffer_size_kb, consider setting both fields.
       * Example:
       * buffer_size_kb: 4096
       * buffer_size_lower_bound: true
       * On older builds, the per-cpu buffers will be exactly 4 MB.
       * On v43+, buffers will be at least 4 MB.
       * In both cases, neither is guaranteed if there are other concurrent
       * perfetto ftrace sessions, as the buffers cannot be resized without pausing
       * the recording in the kernel.
       * Introduced in: perfetto v43.
       * </pre>
       *
       * <code>optional bool buffer_size_lower_bound = 27;</code>
       * @return The bufferSizeLowerBound.
       */
      @java.lang.Override
      public boolean getBufferSizeLowerBound() {
        return bufferSizeLowerBound_;
      }
      /**
       * <pre>
       * If true, |buffer_size_kb| is interpreted as a lower bound, allowing the
       * implementation to choose a bigger buffer size.
       *
       * Most configs for perfetto v43+ should simply leave both fields unset.
       *
       * If you need a config compatible with a range of perfetto builds and you
       * used to set a non-default buffer_size_kb, consider setting both fields.
       * Example:
       * buffer_size_kb: 4096
       * buffer_size_lower_bound: true
       * On older builds, the per-cpu buffers will be exactly 4 MB.
       * On v43+, buffers will be at least 4 MB.
       * In both cases, neither is guaranteed if there are other concurrent
       * perfetto ftrace sessions, as the buffers cannot be resized without pausing
       * the recording in the kernel.
       * Introduced in: perfetto v43.
       * </pre>
       *
       * <code>optional bool buffer_size_lower_bound = 27;</code>
       * @param value The bufferSizeLowerBound to set.
       * @return This builder for chaining.
       */
      public Builder setBufferSizeLowerBound(boolean value) {

        bufferSizeLowerBound_ = value;
        bitField0_ |= 0x00200000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If true, |buffer_size_kb| is interpreted as a lower bound, allowing the
       * implementation to choose a bigger buffer size.
       *
       * Most configs for perfetto v43+ should simply leave both fields unset.
       *
       * If you need a config compatible with a range of perfetto builds and you
       * used to set a non-default buffer_size_kb, consider setting both fields.
       * Example:
       * buffer_size_kb: 4096
       * buffer_size_lower_bound: true
       * On older builds, the per-cpu buffers will be exactly 4 MB.
       * On v43+, buffers will be at least 4 MB.
       * In both cases, neither is guaranteed if there are other concurrent
       * perfetto ftrace sessions, as the buffers cannot be resized without pausing
       * the recording in the kernel.
       * Introduced in: perfetto v43.
       * </pre>
       *
       * <code>optional bool buffer_size_lower_bound = 27;</code>
       * @return This builder for chaining.
       */
      public Builder clearBufferSizeLowerBound() {
        bitField0_ = (bitField0_ & ~0x00200000);
        bufferSizeLowerBound_ = false;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:perfetto.protos.FtraceConfig)
    }

    // @@protoc_insertion_point(class_scope:perfetto.protos.FtraceConfig)
    private static final perfetto.protos.FtraceConfigOuterClass.FtraceConfig DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new perfetto.protos.FtraceConfigOuterClass.FtraceConfig();
    }

    public static perfetto.protos.FtraceConfigOuterClass.FtraceConfig getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<FtraceConfig>
        PARSER = new com.google.protobuf.AbstractParser<FtraceConfig>() {
      @java.lang.Override
      public FtraceConfig parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<FtraceConfig> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<FtraceConfig> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public perfetto.protos.FtraceConfigOuterClass.FtraceConfig getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_perfetto_protos_FtraceConfig_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_perfetto_protos_FtraceConfig_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_perfetto_protos_FtraceConfig_CompactSchedConfig_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_perfetto_protos_FtraceConfig_CompactSchedConfig_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_perfetto_protos_FtraceConfig_PrintFilter_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_perfetto_protos_FtraceConfig_PrintFilter_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_perfetto_protos_FtraceConfig_PrintFilter_Rule_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_perfetto_protos_FtraceConfig_PrintFilter_Rule_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_perfetto_protos_FtraceConfig_PrintFilter_Rule_AtraceMessage_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_perfetto_protos_FtraceConfig_PrintFilter_Rule_AtraceMessage_fieldAccessorTable;

  public static com.google.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
    return descriptor;
  }
  private static  com.google.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
    java.lang.String[] descriptorData = {
      "\n1protos/perfetto/config/ftrace/ftrace_c" +
      "onfig.proto\022\017perfetto.protos\"\230\t\n\014FtraceC" +
      "onfig\022\025\n\rftrace_events\030\001 \003(\t\022\031\n\021atrace_c" +
      "ategories\030\002 \003(\t\022\023\n\013atrace_apps\030\003 \003(\t\022$\n\034" +
      "atrace_categories_prefer_sdk\030\034 \003(\t\022\026\n\016bu" +
      "ffer_size_kb\030\n \001(\r\022\027\n\017drain_period_ms\030\013 " +
      "\001(\r\022\034\n\024drain_buffer_percent\030\035 \001(\r\022G\n\rcom" +
      "pact_sched\030\014 \001(\01320.perfetto.protos.Ftrac" +
      "eConfig.CompactSchedConfig\022?\n\014print_filt" +
      "er\030\026 \001(\0132).perfetto.protos.FtraceConfig." +
      "PrintFilter\022\027\n\017symbolize_ksyms\030\r \001(\010\022F\n\020" +
      "ksyms_mem_policy\030\021 \001(\0162,.perfetto.protos" +
      ".FtraceConfig.KsymsMemPolicy\0226\n*initiali" +
      "ze_ksyms_synchronously_for_testing\030\016 \001(\010" +
      "B\002\030\001\022\031\n\021throttle_rss_stat\030\017 \001(\010\022\036\n\026disab" +
      "le_generic_events\030\020 \001(\010\022\026\n\016syscall_event" +
      "s\030\022 \003(\t\022\035\n\025enable_function_graph\030\023 \001(\010\022\030" +
      "\n\020function_filters\030\024 \003(\t\022\034\n\024function_gra" +
      "ph_roots\030\025 \003(\t\022\036\n\026preserve_ftrace_buffer" +
      "\030\027 \001(\010\022\037\n\027use_monotonic_raw_clock\030\030 \001(\010\022" +
      "\025\n\rinstance_name\030\031 \001(\t\022\037\n\027buffer_size_lo" +
      "wer_bound\030\033 \001(\010\032%\n\022CompactSchedConfig\022\017\n" +
      "\007enabled\030\001 \001(\010\032\202\002\n\013PrintFilter\022=\n\005rules\030" +
      "\001 \003(\0132..perfetto.protos.FtraceConfig.Pri" +
      "ntFilter.Rule\032\263\001\n\004Rule\022\020\n\006prefix\030\001 \001(\tH\000" +
      "\022R\n\natrace_msg\030\003 \001(\0132<.perfetto.protos.F" +
      "traceConfig.PrintFilter.Rule.AtraceMessa" +
      "geH\000\022\r\n\005allow\030\002 \001(\010\032-\n\rAtraceMessage\022\014\n\004" +
      "type\030\001 \001(\t\022\016\n\006prefix\030\002 \001(\tB\007\n\005match\"T\n\016K" +
      "symsMemPolicy\022\025\n\021KSYMS_UNSPECIFIED\020\000\022\031\n\025" +
      "KSYMS_CLEANUP_ON_STOP\020\001\022\020\n\014KSYMS_RETAIN\020" +
      "\002J\004\010\032\020\033"
    };
    descriptor = com.google.protobuf.Descriptors.FileDescriptor
      .internalBuildGeneratedFileFrom(descriptorData,
        new com.google.protobuf.Descriptors.FileDescriptor[] {
        });
    internal_static_perfetto_protos_FtraceConfig_descriptor =
      getDescriptor().getMessageTypes().get(0);
    internal_static_perfetto_protos_FtraceConfig_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_perfetto_protos_FtraceConfig_descriptor,
        new java.lang.String[] { "FtraceEvents", "AtraceCategories", "AtraceApps", "AtraceCategoriesPreferSdk", "BufferSizeKb", "DrainPeriodMs", "DrainBufferPercent", "CompactSched", "PrintFilter", "SymbolizeKsyms", "KsymsMemPolicy", "InitializeKsymsSynchronouslyForTesting", "ThrottleRssStat", "DisableGenericEvents", "SyscallEvents", "EnableFunctionGraph", "FunctionFilters", "FunctionGraphRoots", "PreserveFtraceBuffer", "UseMonotonicRawClock", "InstanceName", "BufferSizeLowerBound", });
    internal_static_perfetto_protos_FtraceConfig_CompactSchedConfig_descriptor =
      internal_static_perfetto_protos_FtraceConfig_descriptor.getNestedTypes().get(0);
    internal_static_perfetto_protos_FtraceConfig_CompactSchedConfig_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_perfetto_protos_FtraceConfig_CompactSchedConfig_descriptor,
        new java.lang.String[] { "Enabled", });
    internal_static_perfetto_protos_FtraceConfig_PrintFilter_descriptor =
      internal_static_perfetto_protos_FtraceConfig_descriptor.getNestedTypes().get(1);
    internal_static_perfetto_protos_FtraceConfig_PrintFilter_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_perfetto_protos_FtraceConfig_PrintFilter_descriptor,
        new java.lang.String[] { "Rules", });
    internal_static_perfetto_protos_FtraceConfig_PrintFilter_Rule_descriptor =
      internal_static_perfetto_protos_FtraceConfig_PrintFilter_descriptor.getNestedTypes().get(0);
    internal_static_perfetto_protos_FtraceConfig_PrintFilter_Rule_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_perfetto_protos_FtraceConfig_PrintFilter_Rule_descriptor,
        new java.lang.String[] { "Prefix", "AtraceMsg", "Allow", "Match", });
    internal_static_perfetto_protos_FtraceConfig_PrintFilter_Rule_AtraceMessage_descriptor =
      internal_static_perfetto_protos_FtraceConfig_PrintFilter_Rule_descriptor.getNestedTypes().get(0);
    internal_static_perfetto_protos_FtraceConfig_PrintFilter_Rule_AtraceMessage_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_perfetto_protos_FtraceConfig_PrintFilter_Rule_AtraceMessage_descriptor,
        new java.lang.String[] { "Type", "Prefix", });
    descriptor.resolveAllFeaturesImmutable();
  }

  // @@protoc_insertion_point(outer_class_scope)
}
