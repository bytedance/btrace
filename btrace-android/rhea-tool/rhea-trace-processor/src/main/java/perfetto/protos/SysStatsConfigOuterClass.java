// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: protos/perfetto/config/sys_stats/sys_stats_config.proto
// Protobuf Java Version: 4.29.3

package perfetto.protos;

public final class SysStatsConfigOuterClass {
  private SysStatsConfigOuterClass() {}
  static {
    com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
      com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
      /* major= */ 4,
      /* minor= */ 29,
      /* patch= */ 3,
      /* suffix= */ "",
      SysStatsConfigOuterClass.class.getName());
  }
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }

  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistry registry) {
    registerAllExtensions(
        (com.google.protobuf.ExtensionRegistryLite) registry);
  }
  public interface SysStatsConfigOrBuilder extends
      // @@protoc_insertion_point(interface_extends:perfetto.protos.SysStatsConfig)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Polls /proc/meminfo every X ms, if non-zero.
     * This is required to be &gt; 10ms to avoid excessive CPU usage.
     * Cost: 0.3 ms [read] + 0.07 ms [parse + trace injection]
     * </pre>
     *
     * <code>optional uint32 meminfo_period_ms = 1;</code>
     * @return Whether the meminfoPeriodMs field is set.
     */
    boolean hasMeminfoPeriodMs();
    /**
     * <pre>
     * Polls /proc/meminfo every X ms, if non-zero.
     * This is required to be &gt; 10ms to avoid excessive CPU usage.
     * Cost: 0.3 ms [read] + 0.07 ms [parse + trace injection]
     * </pre>
     *
     * <code>optional uint32 meminfo_period_ms = 1;</code>
     * @return The meminfoPeriodMs.
     */
    int getMeminfoPeriodMs();

    /**
     * <pre>
     * If empty all known counters are reported. Otherwise, only the counters
     * specified below are reported.
     * </pre>
     *
     * <code>repeated .perfetto.protos.MeminfoCounters meminfo_counters = 2;</code>
     * @return A list containing the meminfoCounters.
     */
    java.util.List<perfetto.protos.SysStatsCounters.MeminfoCounters> getMeminfoCountersList();
    /**
     * <pre>
     * If empty all known counters are reported. Otherwise, only the counters
     * specified below are reported.
     * </pre>
     *
     * <code>repeated .perfetto.protos.MeminfoCounters meminfo_counters = 2;</code>
     * @return The count of meminfoCounters.
     */
    int getMeminfoCountersCount();
    /**
     * <pre>
     * If empty all known counters are reported. Otherwise, only the counters
     * specified below are reported.
     * </pre>
     *
     * <code>repeated .perfetto.protos.MeminfoCounters meminfo_counters = 2;</code>
     * @param index The index of the element to return.
     * @return The meminfoCounters at the given index.
     */
    perfetto.protos.SysStatsCounters.MeminfoCounters getMeminfoCounters(int index);

    /**
     * <pre>
     * Polls /proc/vmstat every X ms, if non-zero.
     * This is required to be &gt; 10ms to avoid excessive CPU usage.
     * Cost: 0.2 ms [read] + 0.3 ms [parse + trace injection]
     * </pre>
     *
     * <code>optional uint32 vmstat_period_ms = 3;</code>
     * @return Whether the vmstatPeriodMs field is set.
     */
    boolean hasVmstatPeriodMs();
    /**
     * <pre>
     * Polls /proc/vmstat every X ms, if non-zero.
     * This is required to be &gt; 10ms to avoid excessive CPU usage.
     * Cost: 0.2 ms [read] + 0.3 ms [parse + trace injection]
     * </pre>
     *
     * <code>optional uint32 vmstat_period_ms = 3;</code>
     * @return The vmstatPeriodMs.
     */
    int getVmstatPeriodMs();

    /**
     * <code>repeated .perfetto.protos.VmstatCounters vmstat_counters = 4;</code>
     * @return A list containing the vmstatCounters.
     */
    java.util.List<perfetto.protos.SysStatsCounters.VmstatCounters> getVmstatCountersList();
    /**
     * <code>repeated .perfetto.protos.VmstatCounters vmstat_counters = 4;</code>
     * @return The count of vmstatCounters.
     */
    int getVmstatCountersCount();
    /**
     * <code>repeated .perfetto.protos.VmstatCounters vmstat_counters = 4;</code>
     * @param index The index of the element to return.
     * @return The vmstatCounters at the given index.
     */
    perfetto.protos.SysStatsCounters.VmstatCounters getVmstatCounters(int index);

    /**
     * <pre>
     * Pols /proc/stat every X ms, if non-zero.
     * This is required to be &gt; 10ms to avoid excessive CPU usage.
     * Cost: 4.1 ms [read] + 1.9 ms [parse + trace injection]
     * </pre>
     *
     * <code>optional uint32 stat_period_ms = 5;</code>
     * @return Whether the statPeriodMs field is set.
     */
    boolean hasStatPeriodMs();
    /**
     * <pre>
     * Pols /proc/stat every X ms, if non-zero.
     * This is required to be &gt; 10ms to avoid excessive CPU usage.
     * Cost: 4.1 ms [read] + 1.9 ms [parse + trace injection]
     * </pre>
     *
     * <code>optional uint32 stat_period_ms = 5;</code>
     * @return The statPeriodMs.
     */
    int getStatPeriodMs();

    /**
     * <code>repeated .perfetto.protos.SysStatsConfig.StatCounters stat_counters = 6;</code>
     * @return A list containing the statCounters.
     */
    java.util.List<perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig.StatCounters> getStatCountersList();
    /**
     * <code>repeated .perfetto.protos.SysStatsConfig.StatCounters stat_counters = 6;</code>
     * @return The count of statCounters.
     */
    int getStatCountersCount();
    /**
     * <code>repeated .perfetto.protos.SysStatsConfig.StatCounters stat_counters = 6;</code>
     * @param index The index of the element to return.
     * @return The statCounters at the given index.
     */
    perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig.StatCounters getStatCounters(int index);

    /**
     * <pre>
     * Polls /sys/devfreq/&#42;&#47;curfreq every X ms, if non-zero.
     * This is required to be &gt; 10ms to avoid excessive CPU usage.
     * This option can be used to record unchanging values.
     * Updates from frequency changes can come from ftrace/set_clock_rate.
     * </pre>
     *
     * <code>optional uint32 devfreq_period_ms = 7;</code>
     * @return Whether the devfreqPeriodMs field is set.
     */
    boolean hasDevfreqPeriodMs();
    /**
     * <pre>
     * Polls /sys/devfreq/&#42;&#47;curfreq every X ms, if non-zero.
     * This is required to be &gt; 10ms to avoid excessive CPU usage.
     * This option can be used to record unchanging values.
     * Updates from frequency changes can come from ftrace/set_clock_rate.
     * </pre>
     *
     * <code>optional uint32 devfreq_period_ms = 7;</code>
     * @return The devfreqPeriodMs.
     */
    int getDevfreqPeriodMs();

    /**
     * <pre>
     * Polls /sys/devices/system/cpu/cpu*&#47;cpufreq/cpuinfo_cur_freq every X ms.
     * This is required to be &gt; 10ms to avoid excessive CPU usage.
     * </pre>
     *
     * <code>optional uint32 cpufreq_period_ms = 8;</code>
     * @return Whether the cpufreqPeriodMs field is set.
     */
    boolean hasCpufreqPeriodMs();
    /**
     * <pre>
     * Polls /sys/devices/system/cpu/cpu*&#47;cpufreq/cpuinfo_cur_freq every X ms.
     * This is required to be &gt; 10ms to avoid excessive CPU usage.
     * </pre>
     *
     * <code>optional uint32 cpufreq_period_ms = 8;</code>
     * @return The cpufreqPeriodMs.
     */
    int getCpufreqPeriodMs();

    /**
     * <pre>
     * Polls /proc/buddyinfo every X ms, if non-zero.
     * This is required to be &gt; 10ms to avoid excessive CPU usage.
     * </pre>
     *
     * <code>optional uint32 buddyinfo_period_ms = 9;</code>
     * @return Whether the buddyinfoPeriodMs field is set.
     */
    boolean hasBuddyinfoPeriodMs();
    /**
     * <pre>
     * Polls /proc/buddyinfo every X ms, if non-zero.
     * This is required to be &gt; 10ms to avoid excessive CPU usage.
     * </pre>
     *
     * <code>optional uint32 buddyinfo_period_ms = 9;</code>
     * @return The buddyinfoPeriodMs.
     */
    int getBuddyinfoPeriodMs();

    /**
     * <pre>
     * Polls /proc/diskstats every X ms, if non-zero.
     * This is required to be &gt; 10ms to avoid excessive CPU usage.
     * </pre>
     *
     * <code>optional uint32 diskstat_period_ms = 10;</code>
     * @return Whether the diskstatPeriodMs field is set.
     */
    boolean hasDiskstatPeriodMs();
    /**
     * <pre>
     * Polls /proc/diskstats every X ms, if non-zero.
     * This is required to be &gt; 10ms to avoid excessive CPU usage.
     * </pre>
     *
     * <code>optional uint32 diskstat_period_ms = 10;</code>
     * @return The diskstatPeriodMs.
     */
    int getDiskstatPeriodMs();

    /**
     * <pre>
     * Polls /proc/pressure/&#42; every X ms, if non-zero.
     * This is required to be &gt; 10ms to avoid excessive CPU usage.
     * </pre>
     *
     * <code>optional uint32 psi_period_ms = 11;</code>
     * @return Whether the psiPeriodMs field is set.
     */
    boolean hasPsiPeriodMs();
    /**
     * <pre>
     * Polls /proc/pressure/&#42; every X ms, if non-zero.
     * This is required to be &gt; 10ms to avoid excessive CPU usage.
     * </pre>
     *
     * <code>optional uint32 psi_period_ms = 11;</code>
     * @return The psiPeriodMs.
     */
    int getPsiPeriodMs();

    /**
     * <pre>
     * Polls /sys/class/thermal/&#42; every X ms, if non-zero.
     * This is required to be &gt; 10ms to avoid excessive CPU usage.
     * </pre>
     *
     * <code>optional uint32 thermal_period_ms = 12;</code>
     * @return Whether the thermalPeriodMs field is set.
     */
    boolean hasThermalPeriodMs();
    /**
     * <pre>
     * Polls /sys/class/thermal/&#42; every X ms, if non-zero.
     * This is required to be &gt; 10ms to avoid excessive CPU usage.
     * </pre>
     *
     * <code>optional uint32 thermal_period_ms = 12;</code>
     * @return The thermalPeriodMs.
     */
    int getThermalPeriodMs();

    /**
     * <pre>
     * Polls /sys/devices/system/cpu/cpu*&#47;cpuidle/state* every X ms, if non-zero.
     * This is required to be &gt; 10ms to avoid excessive CPU usage.
     * </pre>
     *
     * <code>optional uint32 cpuidle_period_ms = 13;</code>
     * @return Whether the cpuidlePeriodMs field is set.
     */
    boolean hasCpuidlePeriodMs();
    /**
     * <pre>
     * Polls /sys/devices/system/cpu/cpu*&#47;cpuidle/state* every X ms, if non-zero.
     * This is required to be &gt; 10ms to avoid excessive CPU usage.
     * </pre>
     *
     * <code>optional uint32 cpuidle_period_ms = 13;</code>
     * @return The cpuidlePeriodMs.
     */
    int getCpuidlePeriodMs();

    /**
     * <pre>
     * Polls device-specific GPU frequency info every X ms, if non-zero.
     * This is required to be &gt; 10ms to avoid excessive CPU usage.
     * </pre>
     *
     * <code>optional uint32 gpufreq_period_ms = 14;</code>
     * @return Whether the gpufreqPeriodMs field is set.
     */
    boolean hasGpufreqPeriodMs();
    /**
     * <pre>
     * Polls device-specific GPU frequency info every X ms, if non-zero.
     * This is required to be &gt; 10ms to avoid excessive CPU usage.
     * </pre>
     *
     * <code>optional uint32 gpufreq_period_ms = 14;</code>
     * @return The gpufreqPeriodMs.
     */
    int getGpufreqPeriodMs();
  }
  /**
   * <pre>
   * This file defines the configuration for the Linux /proc poller data source,
   * which injects counters in the trace.
   * Counters that are needed in the trace must be explicitly listed in the
   * *_counters fields. This is to avoid spamming the trace with all counters
   * at all times.
   * The sampling rate is configurable. All polling rates (*_period_ms) need
   * to be integer multiples of each other.
   * OK:     [10ms, 10ms, 10ms],  [10ms, 20ms, 10ms],  [10ms, 20ms, 60ms]
   * Not OK: [10ms, 10ms, 11ms],  [10ms, 15ms, 20ms]
   * </pre>
   *
   * Protobuf type {@code perfetto.protos.SysStatsConfig}
   */
  public static final class SysStatsConfig extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:perfetto.protos.SysStatsConfig)
      SysStatsConfigOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 29,
        /* patch= */ 3,
        /* suffix= */ "",
        SysStatsConfig.class.getName());
    }
    // Use SysStatsConfig.newBuilder() to construct.
    private SysStatsConfig(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private SysStatsConfig() {
      meminfoCounters_ = emptyIntList();
      vmstatCounters_ = emptyIntList();
      statCounters_ = emptyIntList();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return perfetto.protos.SysStatsConfigOuterClass.internal_static_perfetto_protos_SysStatsConfig_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return perfetto.protos.SysStatsConfigOuterClass.internal_static_perfetto_protos_SysStatsConfig_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig.class, perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig.Builder.class);
    }

    /**
     * Protobuf enum {@code perfetto.protos.SysStatsConfig.StatCounters}
     */
    public enum StatCounters
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <code>STAT_UNSPECIFIED = 0;</code>
       */
      STAT_UNSPECIFIED(0),
      /**
       * <code>STAT_CPU_TIMES = 1;</code>
       */
      STAT_CPU_TIMES(1),
      /**
       * <code>STAT_IRQ_COUNTS = 2;</code>
       */
      STAT_IRQ_COUNTS(2),
      /**
       * <code>STAT_SOFTIRQ_COUNTS = 3;</code>
       */
      STAT_SOFTIRQ_COUNTS(3),
      /**
       * <code>STAT_FORK_COUNT = 4;</code>
       */
      STAT_FORK_COUNT(4),
      ;

      static {
        com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
          com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
          /* major= */ 4,
          /* minor= */ 29,
          /* patch= */ 3,
          /* suffix= */ "",
          StatCounters.class.getName());
      }
      /**
       * <code>STAT_UNSPECIFIED = 0;</code>
       */
      public static final int STAT_UNSPECIFIED_VALUE = 0;
      /**
       * <code>STAT_CPU_TIMES = 1;</code>
       */
      public static final int STAT_CPU_TIMES_VALUE = 1;
      /**
       * <code>STAT_IRQ_COUNTS = 2;</code>
       */
      public static final int STAT_IRQ_COUNTS_VALUE = 2;
      /**
       * <code>STAT_SOFTIRQ_COUNTS = 3;</code>
       */
      public static final int STAT_SOFTIRQ_COUNTS_VALUE = 3;
      /**
       * <code>STAT_FORK_COUNT = 4;</code>
       */
      public static final int STAT_FORK_COUNT_VALUE = 4;


      public final int getNumber() {
        return value;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static StatCounters valueOf(int value) {
        return forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       */
      public static StatCounters forNumber(int value) {
        switch (value) {
          case 0: return STAT_UNSPECIFIED;
          case 1: return STAT_CPU_TIMES;
          case 2: return STAT_IRQ_COUNTS;
          case 3: return STAT_SOFTIRQ_COUNTS;
          case 4: return STAT_FORK_COUNT;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<StatCounters>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          StatCounters> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<StatCounters>() {
              public StatCounters findValueByNumber(int number) {
                return StatCounters.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig.getDescriptor().getEnumTypes().get(0);
      }

      private static final StatCounters[] VALUES = values();

      public static StatCounters valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private StatCounters(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:perfetto.protos.SysStatsConfig.StatCounters)
    }

    private int bitField0_;
    public static final int MEMINFO_PERIOD_MS_FIELD_NUMBER = 1;
    private int meminfoPeriodMs_ = 0;
    /**
     * <pre>
     * Polls /proc/meminfo every X ms, if non-zero.
     * This is required to be &gt; 10ms to avoid excessive CPU usage.
     * Cost: 0.3 ms [read] + 0.07 ms [parse + trace injection]
     * </pre>
     *
     * <code>optional uint32 meminfo_period_ms = 1;</code>
     * @return Whether the meminfoPeriodMs field is set.
     */
    @java.lang.Override
    public boolean hasMeminfoPeriodMs() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Polls /proc/meminfo every X ms, if non-zero.
     * This is required to be &gt; 10ms to avoid excessive CPU usage.
     * Cost: 0.3 ms [read] + 0.07 ms [parse + trace injection]
     * </pre>
     *
     * <code>optional uint32 meminfo_period_ms = 1;</code>
     * @return The meminfoPeriodMs.
     */
    @java.lang.Override
    public int getMeminfoPeriodMs() {
      return meminfoPeriodMs_;
    }

    public static final int MEMINFO_COUNTERS_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private com.google.protobuf.Internal.IntList meminfoCounters_;
    private static final com.google.protobuf.Internal.IntListAdapter.IntConverter<
        perfetto.protos.SysStatsCounters.MeminfoCounters> meminfoCounters_converter_ =
            new com.google.protobuf.Internal.IntListAdapter.IntConverter<
                perfetto.protos.SysStatsCounters.MeminfoCounters>() {
              public perfetto.protos.SysStatsCounters.MeminfoCounters convert(int from) {
                perfetto.protos.SysStatsCounters.MeminfoCounters result = perfetto.protos.SysStatsCounters.MeminfoCounters.forNumber(from);
                return result == null ? perfetto.protos.SysStatsCounters.MeminfoCounters.MEMINFO_UNSPECIFIED : result;
              }
            };
    /**
     * <pre>
     * If empty all known counters are reported. Otherwise, only the counters
     * specified below are reported.
     * </pre>
     *
     * <code>repeated .perfetto.protos.MeminfoCounters meminfo_counters = 2;</code>
     * @return A list containing the meminfoCounters.
     */
    @java.lang.Override
    public java.util.List<perfetto.protos.SysStatsCounters.MeminfoCounters> getMeminfoCountersList() {
      return new com.google.protobuf.Internal.IntListAdapter<
          perfetto.protos.SysStatsCounters.MeminfoCounters>(meminfoCounters_, meminfoCounters_converter_);
    }
    /**
     * <pre>
     * If empty all known counters are reported. Otherwise, only the counters
     * specified below are reported.
     * </pre>
     *
     * <code>repeated .perfetto.protos.MeminfoCounters meminfo_counters = 2;</code>
     * @return The count of meminfoCounters.
     */
    @java.lang.Override
    public int getMeminfoCountersCount() {
      return meminfoCounters_.size();
    }
    /**
     * <pre>
     * If empty all known counters are reported. Otherwise, only the counters
     * specified below are reported.
     * </pre>
     *
     * <code>repeated .perfetto.protos.MeminfoCounters meminfo_counters = 2;</code>
     * @param index The index of the element to return.
     * @return The meminfoCounters at the given index.
     */
    @java.lang.Override
    public perfetto.protos.SysStatsCounters.MeminfoCounters getMeminfoCounters(int index) {
      return meminfoCounters_converter_.convert(meminfoCounters_.getInt(index));
    }

    public static final int VMSTAT_PERIOD_MS_FIELD_NUMBER = 3;
    private int vmstatPeriodMs_ = 0;
    /**
     * <pre>
     * Polls /proc/vmstat every X ms, if non-zero.
     * This is required to be &gt; 10ms to avoid excessive CPU usage.
     * Cost: 0.2 ms [read] + 0.3 ms [parse + trace injection]
     * </pre>
     *
     * <code>optional uint32 vmstat_period_ms = 3;</code>
     * @return Whether the vmstatPeriodMs field is set.
     */
    @java.lang.Override
    public boolean hasVmstatPeriodMs() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Polls /proc/vmstat every X ms, if non-zero.
     * This is required to be &gt; 10ms to avoid excessive CPU usage.
     * Cost: 0.2 ms [read] + 0.3 ms [parse + trace injection]
     * </pre>
     *
     * <code>optional uint32 vmstat_period_ms = 3;</code>
     * @return The vmstatPeriodMs.
     */
    @java.lang.Override
    public int getVmstatPeriodMs() {
      return vmstatPeriodMs_;
    }

    public static final int VMSTAT_COUNTERS_FIELD_NUMBER = 4;
    @SuppressWarnings("serial")
    private com.google.protobuf.Internal.IntList vmstatCounters_;
    private static final com.google.protobuf.Internal.IntListAdapter.IntConverter<
        perfetto.protos.SysStatsCounters.VmstatCounters> vmstatCounters_converter_ =
            new com.google.protobuf.Internal.IntListAdapter.IntConverter<
                perfetto.protos.SysStatsCounters.VmstatCounters>() {
              public perfetto.protos.SysStatsCounters.VmstatCounters convert(int from) {
                perfetto.protos.SysStatsCounters.VmstatCounters result = perfetto.protos.SysStatsCounters.VmstatCounters.forNumber(from);
                return result == null ? perfetto.protos.SysStatsCounters.VmstatCounters.VMSTAT_UNSPECIFIED : result;
              }
            };
    /**
     * <code>repeated .perfetto.protos.VmstatCounters vmstat_counters = 4;</code>
     * @return A list containing the vmstatCounters.
     */
    @java.lang.Override
    public java.util.List<perfetto.protos.SysStatsCounters.VmstatCounters> getVmstatCountersList() {
      return new com.google.protobuf.Internal.IntListAdapter<
          perfetto.protos.SysStatsCounters.VmstatCounters>(vmstatCounters_, vmstatCounters_converter_);
    }
    /**
     * <code>repeated .perfetto.protos.VmstatCounters vmstat_counters = 4;</code>
     * @return The count of vmstatCounters.
     */
    @java.lang.Override
    public int getVmstatCountersCount() {
      return vmstatCounters_.size();
    }
    /**
     * <code>repeated .perfetto.protos.VmstatCounters vmstat_counters = 4;</code>
     * @param index The index of the element to return.
     * @return The vmstatCounters at the given index.
     */
    @java.lang.Override
    public perfetto.protos.SysStatsCounters.VmstatCounters getVmstatCounters(int index) {
      return vmstatCounters_converter_.convert(vmstatCounters_.getInt(index));
    }

    public static final int STAT_PERIOD_MS_FIELD_NUMBER = 5;
    private int statPeriodMs_ = 0;
    /**
     * <pre>
     * Pols /proc/stat every X ms, if non-zero.
     * This is required to be &gt; 10ms to avoid excessive CPU usage.
     * Cost: 4.1 ms [read] + 1.9 ms [parse + trace injection]
     * </pre>
     *
     * <code>optional uint32 stat_period_ms = 5;</code>
     * @return Whether the statPeriodMs field is set.
     */
    @java.lang.Override
    public boolean hasStatPeriodMs() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * Pols /proc/stat every X ms, if non-zero.
     * This is required to be &gt; 10ms to avoid excessive CPU usage.
     * Cost: 4.1 ms [read] + 1.9 ms [parse + trace injection]
     * </pre>
     *
     * <code>optional uint32 stat_period_ms = 5;</code>
     * @return The statPeriodMs.
     */
    @java.lang.Override
    public int getStatPeriodMs() {
      return statPeriodMs_;
    }

    public static final int STAT_COUNTERS_FIELD_NUMBER = 6;
    @SuppressWarnings("serial")
    private com.google.protobuf.Internal.IntList statCounters_;
    private static final com.google.protobuf.Internal.IntListAdapter.IntConverter<
        perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig.StatCounters> statCounters_converter_ =
            new com.google.protobuf.Internal.IntListAdapter.IntConverter<
                perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig.StatCounters>() {
              public perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig.StatCounters convert(int from) {
                perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig.StatCounters result = perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig.StatCounters.forNumber(from);
                return result == null ? perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig.StatCounters.STAT_UNSPECIFIED : result;
              }
            };
    /**
     * <code>repeated .perfetto.protos.SysStatsConfig.StatCounters stat_counters = 6;</code>
     * @return A list containing the statCounters.
     */
    @java.lang.Override
    public java.util.List<perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig.StatCounters> getStatCountersList() {
      return new com.google.protobuf.Internal.IntListAdapter<
          perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig.StatCounters>(statCounters_, statCounters_converter_);
    }
    /**
     * <code>repeated .perfetto.protos.SysStatsConfig.StatCounters stat_counters = 6;</code>
     * @return The count of statCounters.
     */
    @java.lang.Override
    public int getStatCountersCount() {
      return statCounters_.size();
    }
    /**
     * <code>repeated .perfetto.protos.SysStatsConfig.StatCounters stat_counters = 6;</code>
     * @param index The index of the element to return.
     * @return The statCounters at the given index.
     */
    @java.lang.Override
    public perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig.StatCounters getStatCounters(int index) {
      return statCounters_converter_.convert(statCounters_.getInt(index));
    }

    public static final int DEVFREQ_PERIOD_MS_FIELD_NUMBER = 7;
    private int devfreqPeriodMs_ = 0;
    /**
     * <pre>
     * Polls /sys/devfreq/&#42;&#47;curfreq every X ms, if non-zero.
     * This is required to be &gt; 10ms to avoid excessive CPU usage.
     * This option can be used to record unchanging values.
     * Updates from frequency changes can come from ftrace/set_clock_rate.
     * </pre>
     *
     * <code>optional uint32 devfreq_period_ms = 7;</code>
     * @return Whether the devfreqPeriodMs field is set.
     */
    @java.lang.Override
    public boolean hasDevfreqPeriodMs() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * Polls /sys/devfreq/&#42;&#47;curfreq every X ms, if non-zero.
     * This is required to be &gt; 10ms to avoid excessive CPU usage.
     * This option can be used to record unchanging values.
     * Updates from frequency changes can come from ftrace/set_clock_rate.
     * </pre>
     *
     * <code>optional uint32 devfreq_period_ms = 7;</code>
     * @return The devfreqPeriodMs.
     */
    @java.lang.Override
    public int getDevfreqPeriodMs() {
      return devfreqPeriodMs_;
    }

    public static final int CPUFREQ_PERIOD_MS_FIELD_NUMBER = 8;
    private int cpufreqPeriodMs_ = 0;
    /**
     * <pre>
     * Polls /sys/devices/system/cpu/cpu*&#47;cpufreq/cpuinfo_cur_freq every X ms.
     * This is required to be &gt; 10ms to avoid excessive CPU usage.
     * </pre>
     *
     * <code>optional uint32 cpufreq_period_ms = 8;</code>
     * @return Whether the cpufreqPeriodMs field is set.
     */
    @java.lang.Override
    public boolean hasCpufreqPeriodMs() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * Polls /sys/devices/system/cpu/cpu*&#47;cpufreq/cpuinfo_cur_freq every X ms.
     * This is required to be &gt; 10ms to avoid excessive CPU usage.
     * </pre>
     *
     * <code>optional uint32 cpufreq_period_ms = 8;</code>
     * @return The cpufreqPeriodMs.
     */
    @java.lang.Override
    public int getCpufreqPeriodMs() {
      return cpufreqPeriodMs_;
    }

    public static final int BUDDYINFO_PERIOD_MS_FIELD_NUMBER = 9;
    private int buddyinfoPeriodMs_ = 0;
    /**
     * <pre>
     * Polls /proc/buddyinfo every X ms, if non-zero.
     * This is required to be &gt; 10ms to avoid excessive CPU usage.
     * </pre>
     *
     * <code>optional uint32 buddyinfo_period_ms = 9;</code>
     * @return Whether the buddyinfoPeriodMs field is set.
     */
    @java.lang.Override
    public boolean hasBuddyinfoPeriodMs() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * Polls /proc/buddyinfo every X ms, if non-zero.
     * This is required to be &gt; 10ms to avoid excessive CPU usage.
     * </pre>
     *
     * <code>optional uint32 buddyinfo_period_ms = 9;</code>
     * @return The buddyinfoPeriodMs.
     */
    @java.lang.Override
    public int getBuddyinfoPeriodMs() {
      return buddyinfoPeriodMs_;
    }

    public static final int DISKSTAT_PERIOD_MS_FIELD_NUMBER = 10;
    private int diskstatPeriodMs_ = 0;
    /**
     * <pre>
     * Polls /proc/diskstats every X ms, if non-zero.
     * This is required to be &gt; 10ms to avoid excessive CPU usage.
     * </pre>
     *
     * <code>optional uint32 diskstat_period_ms = 10;</code>
     * @return Whether the diskstatPeriodMs field is set.
     */
    @java.lang.Override
    public boolean hasDiskstatPeriodMs() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <pre>
     * Polls /proc/diskstats every X ms, if non-zero.
     * This is required to be &gt; 10ms to avoid excessive CPU usage.
     * </pre>
     *
     * <code>optional uint32 diskstat_period_ms = 10;</code>
     * @return The diskstatPeriodMs.
     */
    @java.lang.Override
    public int getDiskstatPeriodMs() {
      return diskstatPeriodMs_;
    }

    public static final int PSI_PERIOD_MS_FIELD_NUMBER = 11;
    private int psiPeriodMs_ = 0;
    /**
     * <pre>
     * Polls /proc/pressure/&#42; every X ms, if non-zero.
     * This is required to be &gt; 10ms to avoid excessive CPU usage.
     * </pre>
     *
     * <code>optional uint32 psi_period_ms = 11;</code>
     * @return Whether the psiPeriodMs field is set.
     */
    @java.lang.Override
    public boolean hasPsiPeriodMs() {
      return ((bitField0_ & 0x00000080) != 0);
    }
    /**
     * <pre>
     * Polls /proc/pressure/&#42; every X ms, if non-zero.
     * This is required to be &gt; 10ms to avoid excessive CPU usage.
     * </pre>
     *
     * <code>optional uint32 psi_period_ms = 11;</code>
     * @return The psiPeriodMs.
     */
    @java.lang.Override
    public int getPsiPeriodMs() {
      return psiPeriodMs_;
    }

    public static final int THERMAL_PERIOD_MS_FIELD_NUMBER = 12;
    private int thermalPeriodMs_ = 0;
    /**
     * <pre>
     * Polls /sys/class/thermal/&#42; every X ms, if non-zero.
     * This is required to be &gt; 10ms to avoid excessive CPU usage.
     * </pre>
     *
     * <code>optional uint32 thermal_period_ms = 12;</code>
     * @return Whether the thermalPeriodMs field is set.
     */
    @java.lang.Override
    public boolean hasThermalPeriodMs() {
      return ((bitField0_ & 0x00000100) != 0);
    }
    /**
     * <pre>
     * Polls /sys/class/thermal/&#42; every X ms, if non-zero.
     * This is required to be &gt; 10ms to avoid excessive CPU usage.
     * </pre>
     *
     * <code>optional uint32 thermal_period_ms = 12;</code>
     * @return The thermalPeriodMs.
     */
    @java.lang.Override
    public int getThermalPeriodMs() {
      return thermalPeriodMs_;
    }

    public static final int CPUIDLE_PERIOD_MS_FIELD_NUMBER = 13;
    private int cpuidlePeriodMs_ = 0;
    /**
     * <pre>
     * Polls /sys/devices/system/cpu/cpu*&#47;cpuidle/state* every X ms, if non-zero.
     * This is required to be &gt; 10ms to avoid excessive CPU usage.
     * </pre>
     *
     * <code>optional uint32 cpuidle_period_ms = 13;</code>
     * @return Whether the cpuidlePeriodMs field is set.
     */
    @java.lang.Override
    public boolean hasCpuidlePeriodMs() {
      return ((bitField0_ & 0x00000200) != 0);
    }
    /**
     * <pre>
     * Polls /sys/devices/system/cpu/cpu*&#47;cpuidle/state* every X ms, if non-zero.
     * This is required to be &gt; 10ms to avoid excessive CPU usage.
     * </pre>
     *
     * <code>optional uint32 cpuidle_period_ms = 13;</code>
     * @return The cpuidlePeriodMs.
     */
    @java.lang.Override
    public int getCpuidlePeriodMs() {
      return cpuidlePeriodMs_;
    }

    public static final int GPUFREQ_PERIOD_MS_FIELD_NUMBER = 14;
    private int gpufreqPeriodMs_ = 0;
    /**
     * <pre>
     * Polls device-specific GPU frequency info every X ms, if non-zero.
     * This is required to be &gt; 10ms to avoid excessive CPU usage.
     * </pre>
     *
     * <code>optional uint32 gpufreq_period_ms = 14;</code>
     * @return Whether the gpufreqPeriodMs field is set.
     */
    @java.lang.Override
    public boolean hasGpufreqPeriodMs() {
      return ((bitField0_ & 0x00000400) != 0);
    }
    /**
     * <pre>
     * Polls device-specific GPU frequency info every X ms, if non-zero.
     * This is required to be &gt; 10ms to avoid excessive CPU usage.
     * </pre>
     *
     * <code>optional uint32 gpufreq_period_ms = 14;</code>
     * @return The gpufreqPeriodMs.
     */
    @java.lang.Override
    public int getGpufreqPeriodMs() {
      return gpufreqPeriodMs_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeUInt32(1, meminfoPeriodMs_);
      }
      for (int i = 0; i < meminfoCounters_.size(); i++) {
        output.writeEnum(2, meminfoCounters_.getInt(i));
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeUInt32(3, vmstatPeriodMs_);
      }
      for (int i = 0; i < vmstatCounters_.size(); i++) {
        output.writeEnum(4, vmstatCounters_.getInt(i));
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeUInt32(5, statPeriodMs_);
      }
      for (int i = 0; i < statCounters_.size(); i++) {
        output.writeEnum(6, statCounters_.getInt(i));
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        output.writeUInt32(7, devfreqPeriodMs_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        output.writeUInt32(8, cpufreqPeriodMs_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        output.writeUInt32(9, buddyinfoPeriodMs_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        output.writeUInt32(10, diskstatPeriodMs_);
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        output.writeUInt32(11, psiPeriodMs_);
      }
      if (((bitField0_ & 0x00000100) != 0)) {
        output.writeUInt32(12, thermalPeriodMs_);
      }
      if (((bitField0_ & 0x00000200) != 0)) {
        output.writeUInt32(13, cpuidlePeriodMs_);
      }
      if (((bitField0_ & 0x00000400) != 0)) {
        output.writeUInt32(14, gpufreqPeriodMs_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(1, meminfoPeriodMs_);
      }
      {
        int dataSize = 0;
        for (int i = 0; i < meminfoCounters_.size(); i++) {
          dataSize += com.google.protobuf.CodedOutputStream
            .computeEnumSizeNoTag(meminfoCounters_.getInt(i));
        }
        size += dataSize;
        size += 1 * meminfoCounters_.size();
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(3, vmstatPeriodMs_);
      }
      {
        int dataSize = 0;
        for (int i = 0; i < vmstatCounters_.size(); i++) {
          dataSize += com.google.protobuf.CodedOutputStream
            .computeEnumSizeNoTag(vmstatCounters_.getInt(i));
        }
        size += dataSize;
        size += 1 * vmstatCounters_.size();
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(5, statPeriodMs_);
      }
      {
        int dataSize = 0;
        for (int i = 0; i < statCounters_.size(); i++) {
          dataSize += com.google.protobuf.CodedOutputStream
            .computeEnumSizeNoTag(statCounters_.getInt(i));
        }
        size += dataSize;
        size += 1 * statCounters_.size();
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(7, devfreqPeriodMs_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(8, cpufreqPeriodMs_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(9, buddyinfoPeriodMs_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(10, diskstatPeriodMs_);
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(11, psiPeriodMs_);
      }
      if (((bitField0_ & 0x00000100) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(12, thermalPeriodMs_);
      }
      if (((bitField0_ & 0x00000200) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(13, cpuidlePeriodMs_);
      }
      if (((bitField0_ & 0x00000400) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(14, gpufreqPeriodMs_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig)) {
        return super.equals(obj);
      }
      perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig other = (perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig) obj;

      if (hasMeminfoPeriodMs() != other.hasMeminfoPeriodMs()) return false;
      if (hasMeminfoPeriodMs()) {
        if (getMeminfoPeriodMs()
            != other.getMeminfoPeriodMs()) return false;
      }
      if (!meminfoCounters_.equals(other.meminfoCounters_)) return false;
      if (hasVmstatPeriodMs() != other.hasVmstatPeriodMs()) return false;
      if (hasVmstatPeriodMs()) {
        if (getVmstatPeriodMs()
            != other.getVmstatPeriodMs()) return false;
      }
      if (!vmstatCounters_.equals(other.vmstatCounters_)) return false;
      if (hasStatPeriodMs() != other.hasStatPeriodMs()) return false;
      if (hasStatPeriodMs()) {
        if (getStatPeriodMs()
            != other.getStatPeriodMs()) return false;
      }
      if (!statCounters_.equals(other.statCounters_)) return false;
      if (hasDevfreqPeriodMs() != other.hasDevfreqPeriodMs()) return false;
      if (hasDevfreqPeriodMs()) {
        if (getDevfreqPeriodMs()
            != other.getDevfreqPeriodMs()) return false;
      }
      if (hasCpufreqPeriodMs() != other.hasCpufreqPeriodMs()) return false;
      if (hasCpufreqPeriodMs()) {
        if (getCpufreqPeriodMs()
            != other.getCpufreqPeriodMs()) return false;
      }
      if (hasBuddyinfoPeriodMs() != other.hasBuddyinfoPeriodMs()) return false;
      if (hasBuddyinfoPeriodMs()) {
        if (getBuddyinfoPeriodMs()
            != other.getBuddyinfoPeriodMs()) return false;
      }
      if (hasDiskstatPeriodMs() != other.hasDiskstatPeriodMs()) return false;
      if (hasDiskstatPeriodMs()) {
        if (getDiskstatPeriodMs()
            != other.getDiskstatPeriodMs()) return false;
      }
      if (hasPsiPeriodMs() != other.hasPsiPeriodMs()) return false;
      if (hasPsiPeriodMs()) {
        if (getPsiPeriodMs()
            != other.getPsiPeriodMs()) return false;
      }
      if (hasThermalPeriodMs() != other.hasThermalPeriodMs()) return false;
      if (hasThermalPeriodMs()) {
        if (getThermalPeriodMs()
            != other.getThermalPeriodMs()) return false;
      }
      if (hasCpuidlePeriodMs() != other.hasCpuidlePeriodMs()) return false;
      if (hasCpuidlePeriodMs()) {
        if (getCpuidlePeriodMs()
            != other.getCpuidlePeriodMs()) return false;
      }
      if (hasGpufreqPeriodMs() != other.hasGpufreqPeriodMs()) return false;
      if (hasGpufreqPeriodMs()) {
        if (getGpufreqPeriodMs()
            != other.getGpufreqPeriodMs()) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMeminfoPeriodMs()) {
        hash = (37 * hash) + MEMINFO_PERIOD_MS_FIELD_NUMBER;
        hash = (53 * hash) + getMeminfoPeriodMs();
      }
      if (getMeminfoCountersCount() > 0) {
        hash = (37 * hash) + MEMINFO_COUNTERS_FIELD_NUMBER;
        hash = (53 * hash) + meminfoCounters_.hashCode();
      }
      if (hasVmstatPeriodMs()) {
        hash = (37 * hash) + VMSTAT_PERIOD_MS_FIELD_NUMBER;
        hash = (53 * hash) + getVmstatPeriodMs();
      }
      if (getVmstatCountersCount() > 0) {
        hash = (37 * hash) + VMSTAT_COUNTERS_FIELD_NUMBER;
        hash = (53 * hash) + vmstatCounters_.hashCode();
      }
      if (hasStatPeriodMs()) {
        hash = (37 * hash) + STAT_PERIOD_MS_FIELD_NUMBER;
        hash = (53 * hash) + getStatPeriodMs();
      }
      if (getStatCountersCount() > 0) {
        hash = (37 * hash) + STAT_COUNTERS_FIELD_NUMBER;
        hash = (53 * hash) + statCounters_.hashCode();
      }
      if (hasDevfreqPeriodMs()) {
        hash = (37 * hash) + DEVFREQ_PERIOD_MS_FIELD_NUMBER;
        hash = (53 * hash) + getDevfreqPeriodMs();
      }
      if (hasCpufreqPeriodMs()) {
        hash = (37 * hash) + CPUFREQ_PERIOD_MS_FIELD_NUMBER;
        hash = (53 * hash) + getCpufreqPeriodMs();
      }
      if (hasBuddyinfoPeriodMs()) {
        hash = (37 * hash) + BUDDYINFO_PERIOD_MS_FIELD_NUMBER;
        hash = (53 * hash) + getBuddyinfoPeriodMs();
      }
      if (hasDiskstatPeriodMs()) {
        hash = (37 * hash) + DISKSTAT_PERIOD_MS_FIELD_NUMBER;
        hash = (53 * hash) + getDiskstatPeriodMs();
      }
      if (hasPsiPeriodMs()) {
        hash = (37 * hash) + PSI_PERIOD_MS_FIELD_NUMBER;
        hash = (53 * hash) + getPsiPeriodMs();
      }
      if (hasThermalPeriodMs()) {
        hash = (37 * hash) + THERMAL_PERIOD_MS_FIELD_NUMBER;
        hash = (53 * hash) + getThermalPeriodMs();
      }
      if (hasCpuidlePeriodMs()) {
        hash = (37 * hash) + CPUIDLE_PERIOD_MS_FIELD_NUMBER;
        hash = (53 * hash) + getCpuidlePeriodMs();
      }
      if (hasGpufreqPeriodMs()) {
        hash = (37 * hash) + GPUFREQ_PERIOD_MS_FIELD_NUMBER;
        hash = (53 * hash) + getGpufreqPeriodMs();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * This file defines the configuration for the Linux /proc poller data source,
     * which injects counters in the trace.
     * Counters that are needed in the trace must be explicitly listed in the
     * *_counters fields. This is to avoid spamming the trace with all counters
     * at all times.
     * The sampling rate is configurable. All polling rates (*_period_ms) need
     * to be integer multiples of each other.
     * OK:     [10ms, 10ms, 10ms],  [10ms, 20ms, 10ms],  [10ms, 20ms, 60ms]
     * Not OK: [10ms, 10ms, 11ms],  [10ms, 15ms, 20ms]
     * </pre>
     *
     * Protobuf type {@code perfetto.protos.SysStatsConfig}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:perfetto.protos.SysStatsConfig)
        perfetto.protos.SysStatsConfigOuterClass.SysStatsConfigOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return perfetto.protos.SysStatsConfigOuterClass.internal_static_perfetto_protos_SysStatsConfig_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return perfetto.protos.SysStatsConfigOuterClass.internal_static_perfetto_protos_SysStatsConfig_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig.class, perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig.Builder.class);
      }

      // Construct using perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        meminfoPeriodMs_ = 0;
        meminfoCounters_ = emptyIntList();
        bitField0_ = (bitField0_ & ~0x00000002);
        vmstatPeriodMs_ = 0;
        vmstatCounters_ = emptyIntList();
        bitField0_ = (bitField0_ & ~0x00000008);
        statPeriodMs_ = 0;
        statCounters_ = emptyIntList();
        bitField0_ = (bitField0_ & ~0x00000020);
        devfreqPeriodMs_ = 0;
        cpufreqPeriodMs_ = 0;
        buddyinfoPeriodMs_ = 0;
        diskstatPeriodMs_ = 0;
        psiPeriodMs_ = 0;
        thermalPeriodMs_ = 0;
        cpuidlePeriodMs_ = 0;
        gpufreqPeriodMs_ = 0;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return perfetto.protos.SysStatsConfigOuterClass.internal_static_perfetto_protos_SysStatsConfig_descriptor;
      }

      @java.lang.Override
      public perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig getDefaultInstanceForType() {
        return perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig.getDefaultInstance();
      }

      @java.lang.Override
      public perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig build() {
        perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig buildPartial() {
        perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig result = new perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig result) {
        if (((bitField0_ & 0x00000002) != 0)) {
          meminfoCounters_.makeImmutable();
          bitField0_ = (bitField0_ & ~0x00000002);
        }
        result.meminfoCounters_ = meminfoCounters_;
        if (((bitField0_ & 0x00000008) != 0)) {
          vmstatCounters_.makeImmutable();
          bitField0_ = (bitField0_ & ~0x00000008);
        }
        result.vmstatCounters_ = vmstatCounters_;
        if (((bitField0_ & 0x00000020) != 0)) {
          statCounters_.makeImmutable();
          bitField0_ = (bitField0_ & ~0x00000020);
        }
        result.statCounters_ = statCounters_;
      }

      private void buildPartial0(perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.meminfoPeriodMs_ = meminfoPeriodMs_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.vmstatPeriodMs_ = vmstatPeriodMs_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.statPeriodMs_ = statPeriodMs_;
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000040) != 0)) {
          result.devfreqPeriodMs_ = devfreqPeriodMs_;
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000080) != 0)) {
          result.cpufreqPeriodMs_ = cpufreqPeriodMs_;
          to_bitField0_ |= 0x00000010;
        }
        if (((from_bitField0_ & 0x00000100) != 0)) {
          result.buddyinfoPeriodMs_ = buddyinfoPeriodMs_;
          to_bitField0_ |= 0x00000020;
        }
        if (((from_bitField0_ & 0x00000200) != 0)) {
          result.diskstatPeriodMs_ = diskstatPeriodMs_;
          to_bitField0_ |= 0x00000040;
        }
        if (((from_bitField0_ & 0x00000400) != 0)) {
          result.psiPeriodMs_ = psiPeriodMs_;
          to_bitField0_ |= 0x00000080;
        }
        if (((from_bitField0_ & 0x00000800) != 0)) {
          result.thermalPeriodMs_ = thermalPeriodMs_;
          to_bitField0_ |= 0x00000100;
        }
        if (((from_bitField0_ & 0x00001000) != 0)) {
          result.cpuidlePeriodMs_ = cpuidlePeriodMs_;
          to_bitField0_ |= 0x00000200;
        }
        if (((from_bitField0_ & 0x00002000) != 0)) {
          result.gpufreqPeriodMs_ = gpufreqPeriodMs_;
          to_bitField0_ |= 0x00000400;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig) {
          return mergeFrom((perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig other) {
        if (other == perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig.getDefaultInstance()) return this;
        if (other.hasMeminfoPeriodMs()) {
          setMeminfoPeriodMs(other.getMeminfoPeriodMs());
        }
        if (!other.meminfoCounters_.isEmpty()) {
          if (meminfoCounters_.isEmpty()) {
            meminfoCounters_ = other.meminfoCounters_;
            bitField0_ = (bitField0_ & ~0x00000002);
          } else {
            ensureMeminfoCountersIsMutable();
            meminfoCounters_.addAll(other.meminfoCounters_);
          }
          onChanged();
        }
        if (other.hasVmstatPeriodMs()) {
          setVmstatPeriodMs(other.getVmstatPeriodMs());
        }
        if (!other.vmstatCounters_.isEmpty()) {
          if (vmstatCounters_.isEmpty()) {
            vmstatCounters_ = other.vmstatCounters_;
            bitField0_ = (bitField0_ & ~0x00000008);
          } else {
            ensureVmstatCountersIsMutable();
            vmstatCounters_.addAll(other.vmstatCounters_);
          }
          onChanged();
        }
        if (other.hasStatPeriodMs()) {
          setStatPeriodMs(other.getStatPeriodMs());
        }
        if (!other.statCounters_.isEmpty()) {
          if (statCounters_.isEmpty()) {
            statCounters_ = other.statCounters_;
            bitField0_ = (bitField0_ & ~0x00000020);
          } else {
            ensureStatCountersIsMutable();
            statCounters_.addAll(other.statCounters_);
          }
          onChanged();
        }
        if (other.hasDevfreqPeriodMs()) {
          setDevfreqPeriodMs(other.getDevfreqPeriodMs());
        }
        if (other.hasCpufreqPeriodMs()) {
          setCpufreqPeriodMs(other.getCpufreqPeriodMs());
        }
        if (other.hasBuddyinfoPeriodMs()) {
          setBuddyinfoPeriodMs(other.getBuddyinfoPeriodMs());
        }
        if (other.hasDiskstatPeriodMs()) {
          setDiskstatPeriodMs(other.getDiskstatPeriodMs());
        }
        if (other.hasPsiPeriodMs()) {
          setPsiPeriodMs(other.getPsiPeriodMs());
        }
        if (other.hasThermalPeriodMs()) {
          setThermalPeriodMs(other.getThermalPeriodMs());
        }
        if (other.hasCpuidlePeriodMs()) {
          setCpuidlePeriodMs(other.getCpuidlePeriodMs());
        }
        if (other.hasGpufreqPeriodMs()) {
          setGpufreqPeriodMs(other.getGpufreqPeriodMs());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                meminfoPeriodMs_ = input.readUInt32();
                bitField0_ |= 0x00000001;
                break;
              } // case 8
              case 16: {
                int tmpRaw = input.readEnum();
                perfetto.protos.SysStatsCounters.MeminfoCounters tmpValue =
                    perfetto.protos.SysStatsCounters.MeminfoCounters.forNumber(tmpRaw);
                if (tmpValue == null) {
                  mergeUnknownVarintField(2, tmpRaw);
                } else {
                  ensureMeminfoCountersIsMutable();
                  meminfoCounters_.addInt(tmpRaw);
                }
                break;
              } // case 16
              case 18: {
                int length = input.readRawVarint32();
                int oldLimit = input.pushLimit(length);
                while(input.getBytesUntilLimit() > 0) {
                  int tmpRaw = input.readEnum();
                  perfetto.protos.SysStatsCounters.MeminfoCounters tmpValue =
                      perfetto.protos.SysStatsCounters.MeminfoCounters.forNumber(tmpRaw);
                  if (tmpValue == null) {
                    mergeUnknownVarintField(2, tmpRaw);
                  } else {
                    ensureMeminfoCountersIsMutable();
                    meminfoCounters_.addInt(tmpRaw);
                  }
                }
                input.popLimit(oldLimit);
                break;
              } // case 18
              case 24: {
                vmstatPeriodMs_ = input.readUInt32();
                bitField0_ |= 0x00000004;
                break;
              } // case 24
              case 32: {
                int tmpRaw = input.readEnum();
                perfetto.protos.SysStatsCounters.VmstatCounters tmpValue =
                    perfetto.protos.SysStatsCounters.VmstatCounters.forNumber(tmpRaw);
                if (tmpValue == null) {
                  mergeUnknownVarintField(4, tmpRaw);
                } else {
                  ensureVmstatCountersIsMutable();
                  vmstatCounters_.addInt(tmpRaw);
                }
                break;
              } // case 32
              case 34: {
                int length = input.readRawVarint32();
                int oldLimit = input.pushLimit(length);
                while(input.getBytesUntilLimit() > 0) {
                  int tmpRaw = input.readEnum();
                  perfetto.protos.SysStatsCounters.VmstatCounters tmpValue =
                      perfetto.protos.SysStatsCounters.VmstatCounters.forNumber(tmpRaw);
                  if (tmpValue == null) {
                    mergeUnknownVarintField(4, tmpRaw);
                  } else {
                    ensureVmstatCountersIsMutable();
                    vmstatCounters_.addInt(tmpRaw);
                  }
                }
                input.popLimit(oldLimit);
                break;
              } // case 34
              case 40: {
                statPeriodMs_ = input.readUInt32();
                bitField0_ |= 0x00000010;
                break;
              } // case 40
              case 48: {
                int tmpRaw = input.readEnum();
                perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig.StatCounters tmpValue =
                    perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig.StatCounters.forNumber(tmpRaw);
                if (tmpValue == null) {
                  mergeUnknownVarintField(6, tmpRaw);
                } else {
                  ensureStatCountersIsMutable();
                  statCounters_.addInt(tmpRaw);
                }
                break;
              } // case 48
              case 50: {
                int length = input.readRawVarint32();
                int oldLimit = input.pushLimit(length);
                while(input.getBytesUntilLimit() > 0) {
                  int tmpRaw = input.readEnum();
                  perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig.StatCounters tmpValue =
                      perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig.StatCounters.forNumber(tmpRaw);
                  if (tmpValue == null) {
                    mergeUnknownVarintField(6, tmpRaw);
                  } else {
                    ensureStatCountersIsMutable();
                    statCounters_.addInt(tmpRaw);
                  }
                }
                input.popLimit(oldLimit);
                break;
              } // case 50
              case 56: {
                devfreqPeriodMs_ = input.readUInt32();
                bitField0_ |= 0x00000040;
                break;
              } // case 56
              case 64: {
                cpufreqPeriodMs_ = input.readUInt32();
                bitField0_ |= 0x00000080;
                break;
              } // case 64
              case 72: {
                buddyinfoPeriodMs_ = input.readUInt32();
                bitField0_ |= 0x00000100;
                break;
              } // case 72
              case 80: {
                diskstatPeriodMs_ = input.readUInt32();
                bitField0_ |= 0x00000200;
                break;
              } // case 80
              case 88: {
                psiPeriodMs_ = input.readUInt32();
                bitField0_ |= 0x00000400;
                break;
              } // case 88
              case 96: {
                thermalPeriodMs_ = input.readUInt32();
                bitField0_ |= 0x00000800;
                break;
              } // case 96
              case 104: {
                cpuidlePeriodMs_ = input.readUInt32();
                bitField0_ |= 0x00001000;
                break;
              } // case 104
              case 112: {
                gpufreqPeriodMs_ = input.readUInt32();
                bitField0_ |= 0x00002000;
                break;
              } // case 112
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private int meminfoPeriodMs_ ;
      /**
       * <pre>
       * Polls /proc/meminfo every X ms, if non-zero.
       * This is required to be &gt; 10ms to avoid excessive CPU usage.
       * Cost: 0.3 ms [read] + 0.07 ms [parse + trace injection]
       * </pre>
       *
       * <code>optional uint32 meminfo_period_ms = 1;</code>
       * @return Whether the meminfoPeriodMs field is set.
       */
      @java.lang.Override
      public boolean hasMeminfoPeriodMs() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Polls /proc/meminfo every X ms, if non-zero.
       * This is required to be &gt; 10ms to avoid excessive CPU usage.
       * Cost: 0.3 ms [read] + 0.07 ms [parse + trace injection]
       * </pre>
       *
       * <code>optional uint32 meminfo_period_ms = 1;</code>
       * @return The meminfoPeriodMs.
       */
      @java.lang.Override
      public int getMeminfoPeriodMs() {
        return meminfoPeriodMs_;
      }
      /**
       * <pre>
       * Polls /proc/meminfo every X ms, if non-zero.
       * This is required to be &gt; 10ms to avoid excessive CPU usage.
       * Cost: 0.3 ms [read] + 0.07 ms [parse + trace injection]
       * </pre>
       *
       * <code>optional uint32 meminfo_period_ms = 1;</code>
       * @param value The meminfoPeriodMs to set.
       * @return This builder for chaining.
       */
      public Builder setMeminfoPeriodMs(int value) {

        meminfoPeriodMs_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Polls /proc/meminfo every X ms, if non-zero.
       * This is required to be &gt; 10ms to avoid excessive CPU usage.
       * Cost: 0.3 ms [read] + 0.07 ms [parse + trace injection]
       * </pre>
       *
       * <code>optional uint32 meminfo_period_ms = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearMeminfoPeriodMs() {
        bitField0_ = (bitField0_ & ~0x00000001);
        meminfoPeriodMs_ = 0;
        onChanged();
        return this;
      }

      private com.google.protobuf.Internal.IntList meminfoCounters_ =
        emptyIntList();
      private void ensureMeminfoCountersIsMutable() {
        if (!((bitField0_ & 0x00000002) != 0)) {
          meminfoCounters_ = makeMutableCopy(meminfoCounters_);
          bitField0_ |= 0x00000002;
        }
      }
      /**
       * <pre>
       * If empty all known counters are reported. Otherwise, only the counters
       * specified below are reported.
       * </pre>
       *
       * <code>repeated .perfetto.protos.MeminfoCounters meminfo_counters = 2;</code>
       * @return A list containing the meminfoCounters.
       */
      public java.util.List<perfetto.protos.SysStatsCounters.MeminfoCounters> getMeminfoCountersList() {
        return new com.google.protobuf.Internal.IntListAdapter<
            perfetto.protos.SysStatsCounters.MeminfoCounters>(meminfoCounters_, meminfoCounters_converter_);
      }
      /**
       * <pre>
       * If empty all known counters are reported. Otherwise, only the counters
       * specified below are reported.
       * </pre>
       *
       * <code>repeated .perfetto.protos.MeminfoCounters meminfo_counters = 2;</code>
       * @return The count of meminfoCounters.
       */
      public int getMeminfoCountersCount() {
        return meminfoCounters_.size();
      }
      /**
       * <pre>
       * If empty all known counters are reported. Otherwise, only the counters
       * specified below are reported.
       * </pre>
       *
       * <code>repeated .perfetto.protos.MeminfoCounters meminfo_counters = 2;</code>
       * @param index The index of the element to return.
       * @return The meminfoCounters at the given index.
       */
      public perfetto.protos.SysStatsCounters.MeminfoCounters getMeminfoCounters(int index) {
        return meminfoCounters_converter_.convert(meminfoCounters_.getInt(index));
      }
      /**
       * <pre>
       * If empty all known counters are reported. Otherwise, only the counters
       * specified below are reported.
       * </pre>
       *
       * <code>repeated .perfetto.protos.MeminfoCounters meminfo_counters = 2;</code>
       * @param index The index to set the value at.
       * @param value The meminfoCounters to set.
       * @return This builder for chaining.
       */
      public Builder setMeminfoCounters(
          int index, perfetto.protos.SysStatsCounters.MeminfoCounters value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureMeminfoCountersIsMutable();
        meminfoCounters_.setInt(index, value.getNumber());
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If empty all known counters are reported. Otherwise, only the counters
       * specified below are reported.
       * </pre>
       *
       * <code>repeated .perfetto.protos.MeminfoCounters meminfo_counters = 2;</code>
       * @param value The meminfoCounters to add.
       * @return This builder for chaining.
       */
      public Builder addMeminfoCounters(perfetto.protos.SysStatsCounters.MeminfoCounters value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureMeminfoCountersIsMutable();
        meminfoCounters_.addInt(value.getNumber());
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If empty all known counters are reported. Otherwise, only the counters
       * specified below are reported.
       * </pre>
       *
       * <code>repeated .perfetto.protos.MeminfoCounters meminfo_counters = 2;</code>
       * @param values The meminfoCounters to add.
       * @return This builder for chaining.
       */
      public Builder addAllMeminfoCounters(
          java.lang.Iterable<? extends perfetto.protos.SysStatsCounters.MeminfoCounters> values) {
        ensureMeminfoCountersIsMutable();
        for (perfetto.protos.SysStatsCounters.MeminfoCounters value : values) {
          meminfoCounters_.addInt(value.getNumber());
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If empty all known counters are reported. Otherwise, only the counters
       * specified below are reported.
       * </pre>
       *
       * <code>repeated .perfetto.protos.MeminfoCounters meminfo_counters = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearMeminfoCounters() {
        meminfoCounters_ = emptyIntList();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }

      private int vmstatPeriodMs_ ;
      /**
       * <pre>
       * Polls /proc/vmstat every X ms, if non-zero.
       * This is required to be &gt; 10ms to avoid excessive CPU usage.
       * Cost: 0.2 ms [read] + 0.3 ms [parse + trace injection]
       * </pre>
       *
       * <code>optional uint32 vmstat_period_ms = 3;</code>
       * @return Whether the vmstatPeriodMs field is set.
       */
      @java.lang.Override
      public boolean hasVmstatPeriodMs() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * Polls /proc/vmstat every X ms, if non-zero.
       * This is required to be &gt; 10ms to avoid excessive CPU usage.
       * Cost: 0.2 ms [read] + 0.3 ms [parse + trace injection]
       * </pre>
       *
       * <code>optional uint32 vmstat_period_ms = 3;</code>
       * @return The vmstatPeriodMs.
       */
      @java.lang.Override
      public int getVmstatPeriodMs() {
        return vmstatPeriodMs_;
      }
      /**
       * <pre>
       * Polls /proc/vmstat every X ms, if non-zero.
       * This is required to be &gt; 10ms to avoid excessive CPU usage.
       * Cost: 0.2 ms [read] + 0.3 ms [parse + trace injection]
       * </pre>
       *
       * <code>optional uint32 vmstat_period_ms = 3;</code>
       * @param value The vmstatPeriodMs to set.
       * @return This builder for chaining.
       */
      public Builder setVmstatPeriodMs(int value) {

        vmstatPeriodMs_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Polls /proc/vmstat every X ms, if non-zero.
       * This is required to be &gt; 10ms to avoid excessive CPU usage.
       * Cost: 0.2 ms [read] + 0.3 ms [parse + trace injection]
       * </pre>
       *
       * <code>optional uint32 vmstat_period_ms = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearVmstatPeriodMs() {
        bitField0_ = (bitField0_ & ~0x00000004);
        vmstatPeriodMs_ = 0;
        onChanged();
        return this;
      }

      private com.google.protobuf.Internal.IntList vmstatCounters_ =
        emptyIntList();
      private void ensureVmstatCountersIsMutable() {
        if (!((bitField0_ & 0x00000008) != 0)) {
          vmstatCounters_ = makeMutableCopy(vmstatCounters_);
          bitField0_ |= 0x00000008;
        }
      }
      /**
       * <code>repeated .perfetto.protos.VmstatCounters vmstat_counters = 4;</code>
       * @return A list containing the vmstatCounters.
       */
      public java.util.List<perfetto.protos.SysStatsCounters.VmstatCounters> getVmstatCountersList() {
        return new com.google.protobuf.Internal.IntListAdapter<
            perfetto.protos.SysStatsCounters.VmstatCounters>(vmstatCounters_, vmstatCounters_converter_);
      }
      /**
       * <code>repeated .perfetto.protos.VmstatCounters vmstat_counters = 4;</code>
       * @return The count of vmstatCounters.
       */
      public int getVmstatCountersCount() {
        return vmstatCounters_.size();
      }
      /**
       * <code>repeated .perfetto.protos.VmstatCounters vmstat_counters = 4;</code>
       * @param index The index of the element to return.
       * @return The vmstatCounters at the given index.
       */
      public perfetto.protos.SysStatsCounters.VmstatCounters getVmstatCounters(int index) {
        return vmstatCounters_converter_.convert(vmstatCounters_.getInt(index));
      }
      /**
       * <code>repeated .perfetto.protos.VmstatCounters vmstat_counters = 4;</code>
       * @param index The index to set the value at.
       * @param value The vmstatCounters to set.
       * @return This builder for chaining.
       */
      public Builder setVmstatCounters(
          int index, perfetto.protos.SysStatsCounters.VmstatCounters value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureVmstatCountersIsMutable();
        vmstatCounters_.setInt(index, value.getNumber());
        onChanged();
        return this;
      }
      /**
       * <code>repeated .perfetto.protos.VmstatCounters vmstat_counters = 4;</code>
       * @param value The vmstatCounters to add.
       * @return This builder for chaining.
       */
      public Builder addVmstatCounters(perfetto.protos.SysStatsCounters.VmstatCounters value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureVmstatCountersIsMutable();
        vmstatCounters_.addInt(value.getNumber());
        onChanged();
        return this;
      }
      /**
       * <code>repeated .perfetto.protos.VmstatCounters vmstat_counters = 4;</code>
       * @param values The vmstatCounters to add.
       * @return This builder for chaining.
       */
      public Builder addAllVmstatCounters(
          java.lang.Iterable<? extends perfetto.protos.SysStatsCounters.VmstatCounters> values) {
        ensureVmstatCountersIsMutable();
        for (perfetto.protos.SysStatsCounters.VmstatCounters value : values) {
          vmstatCounters_.addInt(value.getNumber());
        }
        onChanged();
        return this;
      }
      /**
       * <code>repeated .perfetto.protos.VmstatCounters vmstat_counters = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearVmstatCounters() {
        vmstatCounters_ = emptyIntList();
        bitField0_ = (bitField0_ & ~0x00000008);
        onChanged();
        return this;
      }

      private int statPeriodMs_ ;
      /**
       * <pre>
       * Pols /proc/stat every X ms, if non-zero.
       * This is required to be &gt; 10ms to avoid excessive CPU usage.
       * Cost: 4.1 ms [read] + 1.9 ms [parse + trace injection]
       * </pre>
       *
       * <code>optional uint32 stat_period_ms = 5;</code>
       * @return Whether the statPeriodMs field is set.
       */
      @java.lang.Override
      public boolean hasStatPeriodMs() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * Pols /proc/stat every X ms, if non-zero.
       * This is required to be &gt; 10ms to avoid excessive CPU usage.
       * Cost: 4.1 ms [read] + 1.9 ms [parse + trace injection]
       * </pre>
       *
       * <code>optional uint32 stat_period_ms = 5;</code>
       * @return The statPeriodMs.
       */
      @java.lang.Override
      public int getStatPeriodMs() {
        return statPeriodMs_;
      }
      /**
       * <pre>
       * Pols /proc/stat every X ms, if non-zero.
       * This is required to be &gt; 10ms to avoid excessive CPU usage.
       * Cost: 4.1 ms [read] + 1.9 ms [parse + trace injection]
       * </pre>
       *
       * <code>optional uint32 stat_period_ms = 5;</code>
       * @param value The statPeriodMs to set.
       * @return This builder for chaining.
       */
      public Builder setStatPeriodMs(int value) {

        statPeriodMs_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Pols /proc/stat every X ms, if non-zero.
       * This is required to be &gt; 10ms to avoid excessive CPU usage.
       * Cost: 4.1 ms [read] + 1.9 ms [parse + trace injection]
       * </pre>
       *
       * <code>optional uint32 stat_period_ms = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearStatPeriodMs() {
        bitField0_ = (bitField0_ & ~0x00000010);
        statPeriodMs_ = 0;
        onChanged();
        return this;
      }

      private com.google.protobuf.Internal.IntList statCounters_ =
        emptyIntList();
      private void ensureStatCountersIsMutable() {
        if (!((bitField0_ & 0x00000020) != 0)) {
          statCounters_ = makeMutableCopy(statCounters_);
          bitField0_ |= 0x00000020;
        }
      }
      /**
       * <code>repeated .perfetto.protos.SysStatsConfig.StatCounters stat_counters = 6;</code>
       * @return A list containing the statCounters.
       */
      public java.util.List<perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig.StatCounters> getStatCountersList() {
        return new com.google.protobuf.Internal.IntListAdapter<
            perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig.StatCounters>(statCounters_, statCounters_converter_);
      }
      /**
       * <code>repeated .perfetto.protos.SysStatsConfig.StatCounters stat_counters = 6;</code>
       * @return The count of statCounters.
       */
      public int getStatCountersCount() {
        return statCounters_.size();
      }
      /**
       * <code>repeated .perfetto.protos.SysStatsConfig.StatCounters stat_counters = 6;</code>
       * @param index The index of the element to return.
       * @return The statCounters at the given index.
       */
      public perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig.StatCounters getStatCounters(int index) {
        return statCounters_converter_.convert(statCounters_.getInt(index));
      }
      /**
       * <code>repeated .perfetto.protos.SysStatsConfig.StatCounters stat_counters = 6;</code>
       * @param index The index to set the value at.
       * @param value The statCounters to set.
       * @return This builder for chaining.
       */
      public Builder setStatCounters(
          int index, perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig.StatCounters value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureStatCountersIsMutable();
        statCounters_.setInt(index, value.getNumber());
        onChanged();
        return this;
      }
      /**
       * <code>repeated .perfetto.protos.SysStatsConfig.StatCounters stat_counters = 6;</code>
       * @param value The statCounters to add.
       * @return This builder for chaining.
       */
      public Builder addStatCounters(perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig.StatCounters value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureStatCountersIsMutable();
        statCounters_.addInt(value.getNumber());
        onChanged();
        return this;
      }
      /**
       * <code>repeated .perfetto.protos.SysStatsConfig.StatCounters stat_counters = 6;</code>
       * @param values The statCounters to add.
       * @return This builder for chaining.
       */
      public Builder addAllStatCounters(
          java.lang.Iterable<? extends perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig.StatCounters> values) {
        ensureStatCountersIsMutable();
        for (perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig.StatCounters value : values) {
          statCounters_.addInt(value.getNumber());
        }
        onChanged();
        return this;
      }
      /**
       * <code>repeated .perfetto.protos.SysStatsConfig.StatCounters stat_counters = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearStatCounters() {
        statCounters_ = emptyIntList();
        bitField0_ = (bitField0_ & ~0x00000020);
        onChanged();
        return this;
      }

      private int devfreqPeriodMs_ ;
      /**
       * <pre>
       * Polls /sys/devfreq/&#42;&#47;curfreq every X ms, if non-zero.
       * This is required to be &gt; 10ms to avoid excessive CPU usage.
       * This option can be used to record unchanging values.
       * Updates from frequency changes can come from ftrace/set_clock_rate.
       * </pre>
       *
       * <code>optional uint32 devfreq_period_ms = 7;</code>
       * @return Whether the devfreqPeriodMs field is set.
       */
      @java.lang.Override
      public boolean hasDevfreqPeriodMs() {
        return ((bitField0_ & 0x00000040) != 0);
      }
      /**
       * <pre>
       * Polls /sys/devfreq/&#42;&#47;curfreq every X ms, if non-zero.
       * This is required to be &gt; 10ms to avoid excessive CPU usage.
       * This option can be used to record unchanging values.
       * Updates from frequency changes can come from ftrace/set_clock_rate.
       * </pre>
       *
       * <code>optional uint32 devfreq_period_ms = 7;</code>
       * @return The devfreqPeriodMs.
       */
      @java.lang.Override
      public int getDevfreqPeriodMs() {
        return devfreqPeriodMs_;
      }
      /**
       * <pre>
       * Polls /sys/devfreq/&#42;&#47;curfreq every X ms, if non-zero.
       * This is required to be &gt; 10ms to avoid excessive CPU usage.
       * This option can be used to record unchanging values.
       * Updates from frequency changes can come from ftrace/set_clock_rate.
       * </pre>
       *
       * <code>optional uint32 devfreq_period_ms = 7;</code>
       * @param value The devfreqPeriodMs to set.
       * @return This builder for chaining.
       */
      public Builder setDevfreqPeriodMs(int value) {

        devfreqPeriodMs_ = value;
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Polls /sys/devfreq/&#42;&#47;curfreq every X ms, if non-zero.
       * This is required to be &gt; 10ms to avoid excessive CPU usage.
       * This option can be used to record unchanging values.
       * Updates from frequency changes can come from ftrace/set_clock_rate.
       * </pre>
       *
       * <code>optional uint32 devfreq_period_ms = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearDevfreqPeriodMs() {
        bitField0_ = (bitField0_ & ~0x00000040);
        devfreqPeriodMs_ = 0;
        onChanged();
        return this;
      }

      private int cpufreqPeriodMs_ ;
      /**
       * <pre>
       * Polls /sys/devices/system/cpu/cpu*&#47;cpufreq/cpuinfo_cur_freq every X ms.
       * This is required to be &gt; 10ms to avoid excessive CPU usage.
       * </pre>
       *
       * <code>optional uint32 cpufreq_period_ms = 8;</code>
       * @return Whether the cpufreqPeriodMs field is set.
       */
      @java.lang.Override
      public boolean hasCpufreqPeriodMs() {
        return ((bitField0_ & 0x00000080) != 0);
      }
      /**
       * <pre>
       * Polls /sys/devices/system/cpu/cpu*&#47;cpufreq/cpuinfo_cur_freq every X ms.
       * This is required to be &gt; 10ms to avoid excessive CPU usage.
       * </pre>
       *
       * <code>optional uint32 cpufreq_period_ms = 8;</code>
       * @return The cpufreqPeriodMs.
       */
      @java.lang.Override
      public int getCpufreqPeriodMs() {
        return cpufreqPeriodMs_;
      }
      /**
       * <pre>
       * Polls /sys/devices/system/cpu/cpu*&#47;cpufreq/cpuinfo_cur_freq every X ms.
       * This is required to be &gt; 10ms to avoid excessive CPU usage.
       * </pre>
       *
       * <code>optional uint32 cpufreq_period_ms = 8;</code>
       * @param value The cpufreqPeriodMs to set.
       * @return This builder for chaining.
       */
      public Builder setCpufreqPeriodMs(int value) {

        cpufreqPeriodMs_ = value;
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Polls /sys/devices/system/cpu/cpu*&#47;cpufreq/cpuinfo_cur_freq every X ms.
       * This is required to be &gt; 10ms to avoid excessive CPU usage.
       * </pre>
       *
       * <code>optional uint32 cpufreq_period_ms = 8;</code>
       * @return This builder for chaining.
       */
      public Builder clearCpufreqPeriodMs() {
        bitField0_ = (bitField0_ & ~0x00000080);
        cpufreqPeriodMs_ = 0;
        onChanged();
        return this;
      }

      private int buddyinfoPeriodMs_ ;
      /**
       * <pre>
       * Polls /proc/buddyinfo every X ms, if non-zero.
       * This is required to be &gt; 10ms to avoid excessive CPU usage.
       * </pre>
       *
       * <code>optional uint32 buddyinfo_period_ms = 9;</code>
       * @return Whether the buddyinfoPeriodMs field is set.
       */
      @java.lang.Override
      public boolean hasBuddyinfoPeriodMs() {
        return ((bitField0_ & 0x00000100) != 0);
      }
      /**
       * <pre>
       * Polls /proc/buddyinfo every X ms, if non-zero.
       * This is required to be &gt; 10ms to avoid excessive CPU usage.
       * </pre>
       *
       * <code>optional uint32 buddyinfo_period_ms = 9;</code>
       * @return The buddyinfoPeriodMs.
       */
      @java.lang.Override
      public int getBuddyinfoPeriodMs() {
        return buddyinfoPeriodMs_;
      }
      /**
       * <pre>
       * Polls /proc/buddyinfo every X ms, if non-zero.
       * This is required to be &gt; 10ms to avoid excessive CPU usage.
       * </pre>
       *
       * <code>optional uint32 buddyinfo_period_ms = 9;</code>
       * @param value The buddyinfoPeriodMs to set.
       * @return This builder for chaining.
       */
      public Builder setBuddyinfoPeriodMs(int value) {

        buddyinfoPeriodMs_ = value;
        bitField0_ |= 0x00000100;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Polls /proc/buddyinfo every X ms, if non-zero.
       * This is required to be &gt; 10ms to avoid excessive CPU usage.
       * </pre>
       *
       * <code>optional uint32 buddyinfo_period_ms = 9;</code>
       * @return This builder for chaining.
       */
      public Builder clearBuddyinfoPeriodMs() {
        bitField0_ = (bitField0_ & ~0x00000100);
        buddyinfoPeriodMs_ = 0;
        onChanged();
        return this;
      }

      private int diskstatPeriodMs_ ;
      /**
       * <pre>
       * Polls /proc/diskstats every X ms, if non-zero.
       * This is required to be &gt; 10ms to avoid excessive CPU usage.
       * </pre>
       *
       * <code>optional uint32 diskstat_period_ms = 10;</code>
       * @return Whether the diskstatPeriodMs field is set.
       */
      @java.lang.Override
      public boolean hasDiskstatPeriodMs() {
        return ((bitField0_ & 0x00000200) != 0);
      }
      /**
       * <pre>
       * Polls /proc/diskstats every X ms, if non-zero.
       * This is required to be &gt; 10ms to avoid excessive CPU usage.
       * </pre>
       *
       * <code>optional uint32 diskstat_period_ms = 10;</code>
       * @return The diskstatPeriodMs.
       */
      @java.lang.Override
      public int getDiskstatPeriodMs() {
        return diskstatPeriodMs_;
      }
      /**
       * <pre>
       * Polls /proc/diskstats every X ms, if non-zero.
       * This is required to be &gt; 10ms to avoid excessive CPU usage.
       * </pre>
       *
       * <code>optional uint32 diskstat_period_ms = 10;</code>
       * @param value The diskstatPeriodMs to set.
       * @return This builder for chaining.
       */
      public Builder setDiskstatPeriodMs(int value) {

        diskstatPeriodMs_ = value;
        bitField0_ |= 0x00000200;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Polls /proc/diskstats every X ms, if non-zero.
       * This is required to be &gt; 10ms to avoid excessive CPU usage.
       * </pre>
       *
       * <code>optional uint32 diskstat_period_ms = 10;</code>
       * @return This builder for chaining.
       */
      public Builder clearDiskstatPeriodMs() {
        bitField0_ = (bitField0_ & ~0x00000200);
        diskstatPeriodMs_ = 0;
        onChanged();
        return this;
      }

      private int psiPeriodMs_ ;
      /**
       * <pre>
       * Polls /proc/pressure/&#42; every X ms, if non-zero.
       * This is required to be &gt; 10ms to avoid excessive CPU usage.
       * </pre>
       *
       * <code>optional uint32 psi_period_ms = 11;</code>
       * @return Whether the psiPeriodMs field is set.
       */
      @java.lang.Override
      public boolean hasPsiPeriodMs() {
        return ((bitField0_ & 0x00000400) != 0);
      }
      /**
       * <pre>
       * Polls /proc/pressure/&#42; every X ms, if non-zero.
       * This is required to be &gt; 10ms to avoid excessive CPU usage.
       * </pre>
       *
       * <code>optional uint32 psi_period_ms = 11;</code>
       * @return The psiPeriodMs.
       */
      @java.lang.Override
      public int getPsiPeriodMs() {
        return psiPeriodMs_;
      }
      /**
       * <pre>
       * Polls /proc/pressure/&#42; every X ms, if non-zero.
       * This is required to be &gt; 10ms to avoid excessive CPU usage.
       * </pre>
       *
       * <code>optional uint32 psi_period_ms = 11;</code>
       * @param value The psiPeriodMs to set.
       * @return This builder for chaining.
       */
      public Builder setPsiPeriodMs(int value) {

        psiPeriodMs_ = value;
        bitField0_ |= 0x00000400;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Polls /proc/pressure/&#42; every X ms, if non-zero.
       * This is required to be &gt; 10ms to avoid excessive CPU usage.
       * </pre>
       *
       * <code>optional uint32 psi_period_ms = 11;</code>
       * @return This builder for chaining.
       */
      public Builder clearPsiPeriodMs() {
        bitField0_ = (bitField0_ & ~0x00000400);
        psiPeriodMs_ = 0;
        onChanged();
        return this;
      }

      private int thermalPeriodMs_ ;
      /**
       * <pre>
       * Polls /sys/class/thermal/&#42; every X ms, if non-zero.
       * This is required to be &gt; 10ms to avoid excessive CPU usage.
       * </pre>
       *
       * <code>optional uint32 thermal_period_ms = 12;</code>
       * @return Whether the thermalPeriodMs field is set.
       */
      @java.lang.Override
      public boolean hasThermalPeriodMs() {
        return ((bitField0_ & 0x00000800) != 0);
      }
      /**
       * <pre>
       * Polls /sys/class/thermal/&#42; every X ms, if non-zero.
       * This is required to be &gt; 10ms to avoid excessive CPU usage.
       * </pre>
       *
       * <code>optional uint32 thermal_period_ms = 12;</code>
       * @return The thermalPeriodMs.
       */
      @java.lang.Override
      public int getThermalPeriodMs() {
        return thermalPeriodMs_;
      }
      /**
       * <pre>
       * Polls /sys/class/thermal/&#42; every X ms, if non-zero.
       * This is required to be &gt; 10ms to avoid excessive CPU usage.
       * </pre>
       *
       * <code>optional uint32 thermal_period_ms = 12;</code>
       * @param value The thermalPeriodMs to set.
       * @return This builder for chaining.
       */
      public Builder setThermalPeriodMs(int value) {

        thermalPeriodMs_ = value;
        bitField0_ |= 0x00000800;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Polls /sys/class/thermal/&#42; every X ms, if non-zero.
       * This is required to be &gt; 10ms to avoid excessive CPU usage.
       * </pre>
       *
       * <code>optional uint32 thermal_period_ms = 12;</code>
       * @return This builder for chaining.
       */
      public Builder clearThermalPeriodMs() {
        bitField0_ = (bitField0_ & ~0x00000800);
        thermalPeriodMs_ = 0;
        onChanged();
        return this;
      }

      private int cpuidlePeriodMs_ ;
      /**
       * <pre>
       * Polls /sys/devices/system/cpu/cpu*&#47;cpuidle/state* every X ms, if non-zero.
       * This is required to be &gt; 10ms to avoid excessive CPU usage.
       * </pre>
       *
       * <code>optional uint32 cpuidle_period_ms = 13;</code>
       * @return Whether the cpuidlePeriodMs field is set.
       */
      @java.lang.Override
      public boolean hasCpuidlePeriodMs() {
        return ((bitField0_ & 0x00001000) != 0);
      }
      /**
       * <pre>
       * Polls /sys/devices/system/cpu/cpu*&#47;cpuidle/state* every X ms, if non-zero.
       * This is required to be &gt; 10ms to avoid excessive CPU usage.
       * </pre>
       *
       * <code>optional uint32 cpuidle_period_ms = 13;</code>
       * @return The cpuidlePeriodMs.
       */
      @java.lang.Override
      public int getCpuidlePeriodMs() {
        return cpuidlePeriodMs_;
      }
      /**
       * <pre>
       * Polls /sys/devices/system/cpu/cpu*&#47;cpuidle/state* every X ms, if non-zero.
       * This is required to be &gt; 10ms to avoid excessive CPU usage.
       * </pre>
       *
       * <code>optional uint32 cpuidle_period_ms = 13;</code>
       * @param value The cpuidlePeriodMs to set.
       * @return This builder for chaining.
       */
      public Builder setCpuidlePeriodMs(int value) {

        cpuidlePeriodMs_ = value;
        bitField0_ |= 0x00001000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Polls /sys/devices/system/cpu/cpu*&#47;cpuidle/state* every X ms, if non-zero.
       * This is required to be &gt; 10ms to avoid excessive CPU usage.
       * </pre>
       *
       * <code>optional uint32 cpuidle_period_ms = 13;</code>
       * @return This builder for chaining.
       */
      public Builder clearCpuidlePeriodMs() {
        bitField0_ = (bitField0_ & ~0x00001000);
        cpuidlePeriodMs_ = 0;
        onChanged();
        return this;
      }

      private int gpufreqPeriodMs_ ;
      /**
       * <pre>
       * Polls device-specific GPU frequency info every X ms, if non-zero.
       * This is required to be &gt; 10ms to avoid excessive CPU usage.
       * </pre>
       *
       * <code>optional uint32 gpufreq_period_ms = 14;</code>
       * @return Whether the gpufreqPeriodMs field is set.
       */
      @java.lang.Override
      public boolean hasGpufreqPeriodMs() {
        return ((bitField0_ & 0x00002000) != 0);
      }
      /**
       * <pre>
       * Polls device-specific GPU frequency info every X ms, if non-zero.
       * This is required to be &gt; 10ms to avoid excessive CPU usage.
       * </pre>
       *
       * <code>optional uint32 gpufreq_period_ms = 14;</code>
       * @return The gpufreqPeriodMs.
       */
      @java.lang.Override
      public int getGpufreqPeriodMs() {
        return gpufreqPeriodMs_;
      }
      /**
       * <pre>
       * Polls device-specific GPU frequency info every X ms, if non-zero.
       * This is required to be &gt; 10ms to avoid excessive CPU usage.
       * </pre>
       *
       * <code>optional uint32 gpufreq_period_ms = 14;</code>
       * @param value The gpufreqPeriodMs to set.
       * @return This builder for chaining.
       */
      public Builder setGpufreqPeriodMs(int value) {

        gpufreqPeriodMs_ = value;
        bitField0_ |= 0x00002000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Polls device-specific GPU frequency info every X ms, if non-zero.
       * This is required to be &gt; 10ms to avoid excessive CPU usage.
       * </pre>
       *
       * <code>optional uint32 gpufreq_period_ms = 14;</code>
       * @return This builder for chaining.
       */
      public Builder clearGpufreqPeriodMs() {
        bitField0_ = (bitField0_ & ~0x00002000);
        gpufreqPeriodMs_ = 0;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:perfetto.protos.SysStatsConfig)
    }

    // @@protoc_insertion_point(class_scope:perfetto.protos.SysStatsConfig)
    private static final perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig();
    }

    public static perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<SysStatsConfig>
        PARSER = new com.google.protobuf.AbstractParser<SysStatsConfig>() {
      @java.lang.Override
      public SysStatsConfig parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<SysStatsConfig> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<SysStatsConfig> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_perfetto_protos_SysStatsConfig_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_perfetto_protos_SysStatsConfig_fieldAccessorTable;

  public static com.google.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
    return descriptor;
  }
  private static  com.google.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
    java.lang.String[] descriptorData = {
      "\n7protos/perfetto/config/sys_stats/sys_s" +
      "tats_config.proto\022\017perfetto.protos\032/prot" +
      "os/perfetto/common/sys_stats_counters.pr" +
      "oto\"\354\004\n\016SysStatsConfig\022\031\n\021meminfo_period" +
      "_ms\030\001 \001(\r\022:\n\020meminfo_counters\030\002 \003(\0162 .pe" +
      "rfetto.protos.MeminfoCounters\022\030\n\020vmstat_" +
      "period_ms\030\003 \001(\r\0228\n\017vmstat_counters\030\004 \003(\016" +
      "2\037.perfetto.protos.VmstatCounters\022\026\n\016sta" +
      "t_period_ms\030\005 \001(\r\022C\n\rstat_counters\030\006 \003(\016" +
      "2,.perfetto.protos.SysStatsConfig.StatCo" +
      "unters\022\031\n\021devfreq_period_ms\030\007 \001(\r\022\031\n\021cpu" +
      "freq_period_ms\030\010 \001(\r\022\033\n\023buddyinfo_period" +
      "_ms\030\t \001(\r\022\032\n\022diskstat_period_ms\030\n \001(\r\022\025\n" +
      "\rpsi_period_ms\030\013 \001(\r\022\031\n\021thermal_period_m" +
      "s\030\014 \001(\r\022\031\n\021cpuidle_period_ms\030\r \001(\r\022\031\n\021gp" +
      "ufreq_period_ms\030\016 \001(\r\"{\n\014StatCounters\022\024\n" +
      "\020STAT_UNSPECIFIED\020\000\022\022\n\016STAT_CPU_TIMES\020\001\022" +
      "\023\n\017STAT_IRQ_COUNTS\020\002\022\027\n\023STAT_SOFTIRQ_COU" +
      "NTS\020\003\022\023\n\017STAT_FORK_COUNT\020\004"
    };
    descriptor = com.google.protobuf.Descriptors.FileDescriptor
      .internalBuildGeneratedFileFrom(descriptorData,
        new com.google.protobuf.Descriptors.FileDescriptor[] {
          perfetto.protos.SysStatsCounters.getDescriptor(),
        });
    internal_static_perfetto_protos_SysStatsConfig_descriptor =
      getDescriptor().getMessageTypes().get(0);
    internal_static_perfetto_protos_SysStatsConfig_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_perfetto_protos_SysStatsConfig_descriptor,
        new java.lang.String[] { "MeminfoPeriodMs", "MeminfoCounters", "VmstatPeriodMs", "VmstatCounters", "StatPeriodMs", "StatCounters", "DevfreqPeriodMs", "CpufreqPeriodMs", "BuddyinfoPeriodMs", "DiskstatPeriodMs", "PsiPeriodMs", "ThermalPeriodMs", "CpuidlePeriodMs", "GpufreqPeriodMs", });
    descriptor.resolveAllFeaturesImmutable();
    perfetto.protos.SysStatsCounters.getDescriptor();
  }

  // @@protoc_insertion_point(outer_class_scope)
}
