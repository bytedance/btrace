// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: protos/perfetto/trace/ftrace/ftrace_stats.proto
// Protobuf Java Version: 4.29.3

package perfetto.protos;

public final class FtraceStatsOuterClass {
  private FtraceStatsOuterClass() {}
  static {
    com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
      com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
      /* major= */ 4,
      /* minor= */ 29,
      /* patch= */ 3,
      /* suffix= */ "",
      FtraceStatsOuterClass.class.getName());
  }
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }

  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistry registry) {
    registerAllExtensions(
        (com.google.protobuf.ExtensionRegistryLite) registry);
  }
  /**
   * Protobuf enum {@code perfetto.protos.FtraceParseStatus}
   */
  public enum FtraceParseStatus
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>FTRACE_STATUS_UNSPECIFIED = 0;</code>
     */
    FTRACE_STATUS_UNSPECIFIED(0),
    /**
     * <pre>
     * Not written, used for convenience of implementation:
     * </pre>
     *
     * <code>FTRACE_STATUS_OK = 1;</code>
     */
    FTRACE_STATUS_OK(1),
    /**
     * <pre>
     * Issues with reading data out of the ftrace ring buffer:
     * </pre>
     *
     * <code>FTRACE_STATUS_UNEXPECTED_READ_ERROR = 2;</code>
     */
    FTRACE_STATUS_UNEXPECTED_READ_ERROR(2),
    /**
     * <code>FTRACE_STATUS_PARTIAL_PAGE_READ = 3;</code>
     */
    FTRACE_STATUS_PARTIAL_PAGE_READ(3),
    /**
     * <pre>
     * Ring buffer binary data not matching our understanding of the layout:
     * </pre>
     *
     * <code>FTRACE_STATUS_ABI_INVALID_PAGE_HEADER = 4;</code>
     */
    FTRACE_STATUS_ABI_INVALID_PAGE_HEADER(4),
    /**
     * <code>FTRACE_STATUS_ABI_SHORT_EVENT_HEADER = 5;</code>
     */
    FTRACE_STATUS_ABI_SHORT_EVENT_HEADER(5),
    /**
     * <code>FTRACE_STATUS_ABI_NULL_PADDING = 6;</code>
     */
    FTRACE_STATUS_ABI_NULL_PADDING(6),
    /**
     * <code>FTRACE_STATUS_ABI_SHORT_PADDING_LENGTH = 7;</code>
     */
    FTRACE_STATUS_ABI_SHORT_PADDING_LENGTH(7),
    /**
     * <code>FTRACE_STATUS_ABI_INVALID_PADDING_LENGTH = 8;</code>
     */
    FTRACE_STATUS_ABI_INVALID_PADDING_LENGTH(8),
    /**
     * <code>FTRACE_STATUS_ABI_SHORT_TIME_EXTEND = 9;</code>
     */
    FTRACE_STATUS_ABI_SHORT_TIME_EXTEND(9),
    /**
     * <code>FTRACE_STATUS_ABI_SHORT_TIME_STAMP = 10;</code>
     */
    FTRACE_STATUS_ABI_SHORT_TIME_STAMP(10),
    /**
     * <code>FTRACE_STATUS_ABI_SHORT_DATA_LENGTH = 11;</code>
     */
    FTRACE_STATUS_ABI_SHORT_DATA_LENGTH(11),
    /**
     * <code>FTRACE_STATUS_ABI_ZERO_DATA_LENGTH = 12;</code>
     */
    FTRACE_STATUS_ABI_ZERO_DATA_LENGTH(12),
    /**
     * <code>FTRACE_STATUS_ABI_INVALID_DATA_LENGTH = 13;</code>
     */
    FTRACE_STATUS_ABI_INVALID_DATA_LENGTH(13),
    /**
     * <code>FTRACE_STATUS_ABI_SHORT_EVENT_ID = 14;</code>
     */
    FTRACE_STATUS_ABI_SHORT_EVENT_ID(14),
    /**
     * <code>FTRACE_STATUS_ABI_END_OVERFLOW = 15;</code>
     */
    FTRACE_STATUS_ABI_END_OVERFLOW(15),
    /**
     * <pre>
     * Issues with parsing the event payload:
     * </pre>
     *
     * <code>FTRACE_STATUS_SHORT_COMPACT_EVENT = 16;</code>
     */
    FTRACE_STATUS_SHORT_COMPACT_EVENT(16),
    /**
     * <code>FTRACE_STATUS_INVALID_EVENT = 17;</code>
     */
    FTRACE_STATUS_INVALID_EVENT(17),
    ;

    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 29,
        /* patch= */ 3,
        /* suffix= */ "",
        FtraceParseStatus.class.getName());
    }
    /**
     * <code>FTRACE_STATUS_UNSPECIFIED = 0;</code>
     */
    public static final int FTRACE_STATUS_UNSPECIFIED_VALUE = 0;
    /**
     * <pre>
     * Not written, used for convenience of implementation:
     * </pre>
     *
     * <code>FTRACE_STATUS_OK = 1;</code>
     */
    public static final int FTRACE_STATUS_OK_VALUE = 1;
    /**
     * <pre>
     * Issues with reading data out of the ftrace ring buffer:
     * </pre>
     *
     * <code>FTRACE_STATUS_UNEXPECTED_READ_ERROR = 2;</code>
     */
    public static final int FTRACE_STATUS_UNEXPECTED_READ_ERROR_VALUE = 2;
    /**
     * <code>FTRACE_STATUS_PARTIAL_PAGE_READ = 3;</code>
     */
    public static final int FTRACE_STATUS_PARTIAL_PAGE_READ_VALUE = 3;
    /**
     * <pre>
     * Ring buffer binary data not matching our understanding of the layout:
     * </pre>
     *
     * <code>FTRACE_STATUS_ABI_INVALID_PAGE_HEADER = 4;</code>
     */
    public static final int FTRACE_STATUS_ABI_INVALID_PAGE_HEADER_VALUE = 4;
    /**
     * <code>FTRACE_STATUS_ABI_SHORT_EVENT_HEADER = 5;</code>
     */
    public static final int FTRACE_STATUS_ABI_SHORT_EVENT_HEADER_VALUE = 5;
    /**
     * <code>FTRACE_STATUS_ABI_NULL_PADDING = 6;</code>
     */
    public static final int FTRACE_STATUS_ABI_NULL_PADDING_VALUE = 6;
    /**
     * <code>FTRACE_STATUS_ABI_SHORT_PADDING_LENGTH = 7;</code>
     */
    public static final int FTRACE_STATUS_ABI_SHORT_PADDING_LENGTH_VALUE = 7;
    /**
     * <code>FTRACE_STATUS_ABI_INVALID_PADDING_LENGTH = 8;</code>
     */
    public static final int FTRACE_STATUS_ABI_INVALID_PADDING_LENGTH_VALUE = 8;
    /**
     * <code>FTRACE_STATUS_ABI_SHORT_TIME_EXTEND = 9;</code>
     */
    public static final int FTRACE_STATUS_ABI_SHORT_TIME_EXTEND_VALUE = 9;
    /**
     * <code>FTRACE_STATUS_ABI_SHORT_TIME_STAMP = 10;</code>
     */
    public static final int FTRACE_STATUS_ABI_SHORT_TIME_STAMP_VALUE = 10;
    /**
     * <code>FTRACE_STATUS_ABI_SHORT_DATA_LENGTH = 11;</code>
     */
    public static final int FTRACE_STATUS_ABI_SHORT_DATA_LENGTH_VALUE = 11;
    /**
     * <code>FTRACE_STATUS_ABI_ZERO_DATA_LENGTH = 12;</code>
     */
    public static final int FTRACE_STATUS_ABI_ZERO_DATA_LENGTH_VALUE = 12;
    /**
     * <code>FTRACE_STATUS_ABI_INVALID_DATA_LENGTH = 13;</code>
     */
    public static final int FTRACE_STATUS_ABI_INVALID_DATA_LENGTH_VALUE = 13;
    /**
     * <code>FTRACE_STATUS_ABI_SHORT_EVENT_ID = 14;</code>
     */
    public static final int FTRACE_STATUS_ABI_SHORT_EVENT_ID_VALUE = 14;
    /**
     * <code>FTRACE_STATUS_ABI_END_OVERFLOW = 15;</code>
     */
    public static final int FTRACE_STATUS_ABI_END_OVERFLOW_VALUE = 15;
    /**
     * <pre>
     * Issues with parsing the event payload:
     * </pre>
     *
     * <code>FTRACE_STATUS_SHORT_COMPACT_EVENT = 16;</code>
     */
    public static final int FTRACE_STATUS_SHORT_COMPACT_EVENT_VALUE = 16;
    /**
     * <code>FTRACE_STATUS_INVALID_EVENT = 17;</code>
     */
    public static final int FTRACE_STATUS_INVALID_EVENT_VALUE = 17;


    public final int getNumber() {
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static FtraceParseStatus valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static FtraceParseStatus forNumber(int value) {
      switch (value) {
        case 0: return FTRACE_STATUS_UNSPECIFIED;
        case 1: return FTRACE_STATUS_OK;
        case 2: return FTRACE_STATUS_UNEXPECTED_READ_ERROR;
        case 3: return FTRACE_STATUS_PARTIAL_PAGE_READ;
        case 4: return FTRACE_STATUS_ABI_INVALID_PAGE_HEADER;
        case 5: return FTRACE_STATUS_ABI_SHORT_EVENT_HEADER;
        case 6: return FTRACE_STATUS_ABI_NULL_PADDING;
        case 7: return FTRACE_STATUS_ABI_SHORT_PADDING_LENGTH;
        case 8: return FTRACE_STATUS_ABI_INVALID_PADDING_LENGTH;
        case 9: return FTRACE_STATUS_ABI_SHORT_TIME_EXTEND;
        case 10: return FTRACE_STATUS_ABI_SHORT_TIME_STAMP;
        case 11: return FTRACE_STATUS_ABI_SHORT_DATA_LENGTH;
        case 12: return FTRACE_STATUS_ABI_ZERO_DATA_LENGTH;
        case 13: return FTRACE_STATUS_ABI_INVALID_DATA_LENGTH;
        case 14: return FTRACE_STATUS_ABI_SHORT_EVENT_ID;
        case 15: return FTRACE_STATUS_ABI_END_OVERFLOW;
        case 16: return FTRACE_STATUS_SHORT_COMPACT_EVENT;
        case 17: return FTRACE_STATUS_INVALID_EVENT;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<FtraceParseStatus>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        FtraceParseStatus> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<FtraceParseStatus>() {
            public FtraceParseStatus findValueByNumber(int number) {
              return FtraceParseStatus.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return perfetto.protos.FtraceStatsOuterClass.getDescriptor().getEnumTypes().get(0);
    }

    private static final FtraceParseStatus[] VALUES = values();

    public static FtraceParseStatus valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private FtraceParseStatus(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:perfetto.protos.FtraceParseStatus)
  }

  public interface FtraceCpuStatsOrBuilder extends
      // @@protoc_insertion_point(interface_extends:perfetto.protos.FtraceCpuStats)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * CPU index.
     * </pre>
     *
     * <code>optional uint64 cpu = 1;</code>
     * @return Whether the cpu field is set.
     */
    boolean hasCpu();
    /**
     * <pre>
     * CPU index.
     * </pre>
     *
     * <code>optional uint64 cpu = 1;</code>
     * @return The cpu.
     */
    long getCpu();

    /**
     * <pre>
     * Number of entries currently in the kernel buffer.
     * </pre>
     *
     * <code>optional uint64 entries = 2;</code>
     * @return Whether the entries field is set.
     */
    boolean hasEntries();
    /**
     * <pre>
     * Number of entries currently in the kernel buffer.
     * </pre>
     *
     * <code>optional uint64 entries = 2;</code>
     * @return The entries.
     */
    long getEntries();

    /**
     * <pre>
     * Number of events lost in kernel buffers due to overwriting of old events
     * before userspace had a chance to drain them. Valid if the buffer is in
     * "overwrite" mode, otherwise see |dropped_events|.
     * </pre>
     *
     * <code>optional uint64 overrun = 3;</code>
     * @return Whether the overrun field is set.
     */
    boolean hasOverrun();
    /**
     * <pre>
     * Number of events lost in kernel buffers due to overwriting of old events
     * before userspace had a chance to drain them. Valid if the buffer is in
     * "overwrite" mode, otherwise see |dropped_events|.
     * </pre>
     *
     * <code>optional uint64 overrun = 3;</code>
     * @return The overrun.
     */
    long getOverrun();

    /**
     * <pre>
     * This should always be zero. If not the buffer size is way too small or
     * something went wrong with the tracer. Quoting the kernel: "number of
     * commits failing due to the buffer wrapping around while there are
     * uncommitted events, such as during an interrupt storm".
     * </pre>
     *
     * <code>optional uint64 commit_overrun = 4;</code>
     * @return Whether the commitOverrun field is set.
     */
    boolean hasCommitOverrun();
    /**
     * <pre>
     * This should always be zero. If not the buffer size is way too small or
     * something went wrong with the tracer. Quoting the kernel: "number of
     * commits failing due to the buffer wrapping around while there are
     * uncommitted events, such as during an interrupt storm".
     * </pre>
     *
     * <code>optional uint64 commit_overrun = 4;</code>
     * @return The commitOverrun.
     */
    long getCommitOverrun();

    /**
     * <pre>
     * Size of entries currently in the kernel buffer (see |entries|) in bytes.
     * The field should be named "bytes", but is misnamed for historical reasons.
     * This value has known inaccuracies before Linux v6.6:
     * https://github.com/torvalds/linux/commit/45d99ea
     * </pre>
     *
     * <code>optional uint64 bytes_read = 5;</code>
     * @return Whether the bytesRead field is set.
     */
    boolean hasBytesRead();
    /**
     * <pre>
     * Size of entries currently in the kernel buffer (see |entries|) in bytes.
     * The field should be named "bytes", but is misnamed for historical reasons.
     * This value has known inaccuracies before Linux v6.6:
     * https://github.com/torvalds/linux/commit/45d99ea
     * </pre>
     *
     * <code>optional uint64 bytes_read = 5;</code>
     * @return The bytesRead.
     */
    long getBytesRead();

    /**
     * <pre>
     * The timestamp for the oldest event still in the ring buffer.
     * Unit: seconds for typical trace clocks (i.e. not tsc/counter).
     * </pre>
     *
     * <code>optional double oldest_event_ts = 6;</code>
     * @return Whether the oldestEventTs field is set.
     */
    boolean hasOldestEventTs();
    /**
     * <pre>
     * The timestamp for the oldest event still in the ring buffer.
     * Unit: seconds for typical trace clocks (i.e. not tsc/counter).
     * </pre>
     *
     * <code>optional double oldest_event_ts = 6;</code>
     * @return The oldestEventTs.
     */
    double getOldestEventTs();

    /**
     * <pre>
     * The current timestamp.
     * Unit: seconds for typical trace clocks (i.e. not tsc/counter).
     * </pre>
     *
     * <code>optional double now_ts = 7;</code>
     * @return Whether the nowTs field is set.
     */
    boolean hasNowTs();
    /**
     * <pre>
     * The current timestamp.
     * Unit: seconds for typical trace clocks (i.e. not tsc/counter).
     * </pre>
     *
     * <code>optional double now_ts = 7;</code>
     * @return The nowTs.
     */
    double getNowTs();

    /**
     * <pre>
     * If the kernel buffer has overwrite mode disabled, this will show the number
     * of new events that were lost because the buffer was full. This is similar
     * to |overrun| but only for the overwrite=false case.
     * </pre>
     *
     * <code>optional uint64 dropped_events = 8;</code>
     * @return Whether the droppedEvents field is set.
     */
    boolean hasDroppedEvents();
    /**
     * <pre>
     * If the kernel buffer has overwrite mode disabled, this will show the number
     * of new events that were lost because the buffer was full. This is similar
     * to |overrun| but only for the overwrite=false case.
     * </pre>
     *
     * <code>optional uint64 dropped_events = 8;</code>
     * @return The droppedEvents.
     */
    long getDroppedEvents();

    /**
     * <pre>
     * The number of events read (consumed) from the buffer by userspace.
     * </pre>
     *
     * <code>optional uint64 read_events = 9;</code>
     * @return Whether the readEvents field is set.
     */
    boolean hasReadEvents();
    /**
     * <pre>
     * The number of events read (consumed) from the buffer by userspace.
     * </pre>
     *
     * <code>optional uint64 read_events = 9;</code>
     * @return The readEvents.
     */
    long getReadEvents();
  }
  /**
   * <pre>
   * Per-CPU kernel buffer stats for the ftrace data source gathered from
   * /sys/kernel/tracing/per_cpu/cpuX/stats.
   * </pre>
   *
   * Protobuf type {@code perfetto.protos.FtraceCpuStats}
   */
  public static final class FtraceCpuStats extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:perfetto.protos.FtraceCpuStats)
      FtraceCpuStatsOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 29,
        /* patch= */ 3,
        /* suffix= */ "",
        FtraceCpuStats.class.getName());
    }
    // Use FtraceCpuStats.newBuilder() to construct.
    private FtraceCpuStats(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private FtraceCpuStats() {
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return perfetto.protos.FtraceStatsOuterClass.internal_static_perfetto_protos_FtraceCpuStats_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return perfetto.protos.FtraceStatsOuterClass.internal_static_perfetto_protos_FtraceCpuStats_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              perfetto.protos.FtraceStatsOuterClass.FtraceCpuStats.class, perfetto.protos.FtraceStatsOuterClass.FtraceCpuStats.Builder.class);
    }

    private int bitField0_;
    public static final int CPU_FIELD_NUMBER = 1;
    private long cpu_ = 0L;
    /**
     * <pre>
     * CPU index.
     * </pre>
     *
     * <code>optional uint64 cpu = 1;</code>
     * @return Whether the cpu field is set.
     */
    @java.lang.Override
    public boolean hasCpu() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * CPU index.
     * </pre>
     *
     * <code>optional uint64 cpu = 1;</code>
     * @return The cpu.
     */
    @java.lang.Override
    public long getCpu() {
      return cpu_;
    }

    public static final int ENTRIES_FIELD_NUMBER = 2;
    private long entries_ = 0L;
    /**
     * <pre>
     * Number of entries currently in the kernel buffer.
     * </pre>
     *
     * <code>optional uint64 entries = 2;</code>
     * @return Whether the entries field is set.
     */
    @java.lang.Override
    public boolean hasEntries() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Number of entries currently in the kernel buffer.
     * </pre>
     *
     * <code>optional uint64 entries = 2;</code>
     * @return The entries.
     */
    @java.lang.Override
    public long getEntries() {
      return entries_;
    }

    public static final int OVERRUN_FIELD_NUMBER = 3;
    private long overrun_ = 0L;
    /**
     * <pre>
     * Number of events lost in kernel buffers due to overwriting of old events
     * before userspace had a chance to drain them. Valid if the buffer is in
     * "overwrite" mode, otherwise see |dropped_events|.
     * </pre>
     *
     * <code>optional uint64 overrun = 3;</code>
     * @return Whether the overrun field is set.
     */
    @java.lang.Override
    public boolean hasOverrun() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * Number of events lost in kernel buffers due to overwriting of old events
     * before userspace had a chance to drain them. Valid if the buffer is in
     * "overwrite" mode, otherwise see |dropped_events|.
     * </pre>
     *
     * <code>optional uint64 overrun = 3;</code>
     * @return The overrun.
     */
    @java.lang.Override
    public long getOverrun() {
      return overrun_;
    }

    public static final int COMMIT_OVERRUN_FIELD_NUMBER = 4;
    private long commitOverrun_ = 0L;
    /**
     * <pre>
     * This should always be zero. If not the buffer size is way too small or
     * something went wrong with the tracer. Quoting the kernel: "number of
     * commits failing due to the buffer wrapping around while there are
     * uncommitted events, such as during an interrupt storm".
     * </pre>
     *
     * <code>optional uint64 commit_overrun = 4;</code>
     * @return Whether the commitOverrun field is set.
     */
    @java.lang.Override
    public boolean hasCommitOverrun() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * This should always be zero. If not the buffer size is way too small or
     * something went wrong with the tracer. Quoting the kernel: "number of
     * commits failing due to the buffer wrapping around while there are
     * uncommitted events, such as during an interrupt storm".
     * </pre>
     *
     * <code>optional uint64 commit_overrun = 4;</code>
     * @return The commitOverrun.
     */
    @java.lang.Override
    public long getCommitOverrun() {
      return commitOverrun_;
    }

    public static final int BYTES_READ_FIELD_NUMBER = 5;
    private long bytesRead_ = 0L;
    /**
     * <pre>
     * Size of entries currently in the kernel buffer (see |entries|) in bytes.
     * The field should be named "bytes", but is misnamed for historical reasons.
     * This value has known inaccuracies before Linux v6.6:
     * https://github.com/torvalds/linux/commit/45d99ea
     * </pre>
     *
     * <code>optional uint64 bytes_read = 5;</code>
     * @return Whether the bytesRead field is set.
     */
    @java.lang.Override
    public boolean hasBytesRead() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * Size of entries currently in the kernel buffer (see |entries|) in bytes.
     * The field should be named "bytes", but is misnamed for historical reasons.
     * This value has known inaccuracies before Linux v6.6:
     * https://github.com/torvalds/linux/commit/45d99ea
     * </pre>
     *
     * <code>optional uint64 bytes_read = 5;</code>
     * @return The bytesRead.
     */
    @java.lang.Override
    public long getBytesRead() {
      return bytesRead_;
    }

    public static final int OLDEST_EVENT_TS_FIELD_NUMBER = 6;
    private double oldestEventTs_ = 0D;
    /**
     * <pre>
     * The timestamp for the oldest event still in the ring buffer.
     * Unit: seconds for typical trace clocks (i.e. not tsc/counter).
     * </pre>
     *
     * <code>optional double oldest_event_ts = 6;</code>
     * @return Whether the oldestEventTs field is set.
     */
    @java.lang.Override
    public boolean hasOldestEventTs() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * The timestamp for the oldest event still in the ring buffer.
     * Unit: seconds for typical trace clocks (i.e. not tsc/counter).
     * </pre>
     *
     * <code>optional double oldest_event_ts = 6;</code>
     * @return The oldestEventTs.
     */
    @java.lang.Override
    public double getOldestEventTs() {
      return oldestEventTs_;
    }

    public static final int NOW_TS_FIELD_NUMBER = 7;
    private double nowTs_ = 0D;
    /**
     * <pre>
     * The current timestamp.
     * Unit: seconds for typical trace clocks (i.e. not tsc/counter).
     * </pre>
     *
     * <code>optional double now_ts = 7;</code>
     * @return Whether the nowTs field is set.
     */
    @java.lang.Override
    public boolean hasNowTs() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <pre>
     * The current timestamp.
     * Unit: seconds for typical trace clocks (i.e. not tsc/counter).
     * </pre>
     *
     * <code>optional double now_ts = 7;</code>
     * @return The nowTs.
     */
    @java.lang.Override
    public double getNowTs() {
      return nowTs_;
    }

    public static final int DROPPED_EVENTS_FIELD_NUMBER = 8;
    private long droppedEvents_ = 0L;
    /**
     * <pre>
     * If the kernel buffer has overwrite mode disabled, this will show the number
     * of new events that were lost because the buffer was full. This is similar
     * to |overrun| but only for the overwrite=false case.
     * </pre>
     *
     * <code>optional uint64 dropped_events = 8;</code>
     * @return Whether the droppedEvents field is set.
     */
    @java.lang.Override
    public boolean hasDroppedEvents() {
      return ((bitField0_ & 0x00000080) != 0);
    }
    /**
     * <pre>
     * If the kernel buffer has overwrite mode disabled, this will show the number
     * of new events that were lost because the buffer was full. This is similar
     * to |overrun| but only for the overwrite=false case.
     * </pre>
     *
     * <code>optional uint64 dropped_events = 8;</code>
     * @return The droppedEvents.
     */
    @java.lang.Override
    public long getDroppedEvents() {
      return droppedEvents_;
    }

    public static final int READ_EVENTS_FIELD_NUMBER = 9;
    private long readEvents_ = 0L;
    /**
     * <pre>
     * The number of events read (consumed) from the buffer by userspace.
     * </pre>
     *
     * <code>optional uint64 read_events = 9;</code>
     * @return Whether the readEvents field is set.
     */
    @java.lang.Override
    public boolean hasReadEvents() {
      return ((bitField0_ & 0x00000100) != 0);
    }
    /**
     * <pre>
     * The number of events read (consumed) from the buffer by userspace.
     * </pre>
     *
     * <code>optional uint64 read_events = 9;</code>
     * @return The readEvents.
     */
    @java.lang.Override
    public long getReadEvents() {
      return readEvents_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeUInt64(1, cpu_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeUInt64(2, entries_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeUInt64(3, overrun_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        output.writeUInt64(4, commitOverrun_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        output.writeUInt64(5, bytesRead_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        output.writeDouble(6, oldestEventTs_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        output.writeDouble(7, nowTs_);
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        output.writeUInt64(8, droppedEvents_);
      }
      if (((bitField0_ & 0x00000100) != 0)) {
        output.writeUInt64(9, readEvents_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(1, cpu_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(2, entries_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(3, overrun_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(4, commitOverrun_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(5, bytesRead_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeDoubleSize(6, oldestEventTs_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeDoubleSize(7, nowTs_);
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(8, droppedEvents_);
      }
      if (((bitField0_ & 0x00000100) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(9, readEvents_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof perfetto.protos.FtraceStatsOuterClass.FtraceCpuStats)) {
        return super.equals(obj);
      }
      perfetto.protos.FtraceStatsOuterClass.FtraceCpuStats other = (perfetto.protos.FtraceStatsOuterClass.FtraceCpuStats) obj;

      if (hasCpu() != other.hasCpu()) return false;
      if (hasCpu()) {
        if (getCpu()
            != other.getCpu()) return false;
      }
      if (hasEntries() != other.hasEntries()) return false;
      if (hasEntries()) {
        if (getEntries()
            != other.getEntries()) return false;
      }
      if (hasOverrun() != other.hasOverrun()) return false;
      if (hasOverrun()) {
        if (getOverrun()
            != other.getOverrun()) return false;
      }
      if (hasCommitOverrun() != other.hasCommitOverrun()) return false;
      if (hasCommitOverrun()) {
        if (getCommitOverrun()
            != other.getCommitOverrun()) return false;
      }
      if (hasBytesRead() != other.hasBytesRead()) return false;
      if (hasBytesRead()) {
        if (getBytesRead()
            != other.getBytesRead()) return false;
      }
      if (hasOldestEventTs() != other.hasOldestEventTs()) return false;
      if (hasOldestEventTs()) {
        if (java.lang.Double.doubleToLongBits(getOldestEventTs())
            != java.lang.Double.doubleToLongBits(
                other.getOldestEventTs())) return false;
      }
      if (hasNowTs() != other.hasNowTs()) return false;
      if (hasNowTs()) {
        if (java.lang.Double.doubleToLongBits(getNowTs())
            != java.lang.Double.doubleToLongBits(
                other.getNowTs())) return false;
      }
      if (hasDroppedEvents() != other.hasDroppedEvents()) return false;
      if (hasDroppedEvents()) {
        if (getDroppedEvents()
            != other.getDroppedEvents()) return false;
      }
      if (hasReadEvents() != other.hasReadEvents()) return false;
      if (hasReadEvents()) {
        if (getReadEvents()
            != other.getReadEvents()) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasCpu()) {
        hash = (37 * hash) + CPU_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getCpu());
      }
      if (hasEntries()) {
        hash = (37 * hash) + ENTRIES_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getEntries());
      }
      if (hasOverrun()) {
        hash = (37 * hash) + OVERRUN_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getOverrun());
      }
      if (hasCommitOverrun()) {
        hash = (37 * hash) + COMMIT_OVERRUN_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getCommitOverrun());
      }
      if (hasBytesRead()) {
        hash = (37 * hash) + BYTES_READ_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getBytesRead());
      }
      if (hasOldestEventTs()) {
        hash = (37 * hash) + OLDEST_EVENT_TS_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            java.lang.Double.doubleToLongBits(getOldestEventTs()));
      }
      if (hasNowTs()) {
        hash = (37 * hash) + NOW_TS_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            java.lang.Double.doubleToLongBits(getNowTs()));
      }
      if (hasDroppedEvents()) {
        hash = (37 * hash) + DROPPED_EVENTS_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getDroppedEvents());
      }
      if (hasReadEvents()) {
        hash = (37 * hash) + READ_EVENTS_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getReadEvents());
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static perfetto.protos.FtraceStatsOuterClass.FtraceCpuStats parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static perfetto.protos.FtraceStatsOuterClass.FtraceCpuStats parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static perfetto.protos.FtraceStatsOuterClass.FtraceCpuStats parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static perfetto.protos.FtraceStatsOuterClass.FtraceCpuStats parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static perfetto.protos.FtraceStatsOuterClass.FtraceCpuStats parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static perfetto.protos.FtraceStatsOuterClass.FtraceCpuStats parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static perfetto.protos.FtraceStatsOuterClass.FtraceCpuStats parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static perfetto.protos.FtraceStatsOuterClass.FtraceCpuStats parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static perfetto.protos.FtraceStatsOuterClass.FtraceCpuStats parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static perfetto.protos.FtraceStatsOuterClass.FtraceCpuStats parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static perfetto.protos.FtraceStatsOuterClass.FtraceCpuStats parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static perfetto.protos.FtraceStatsOuterClass.FtraceCpuStats parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(perfetto.protos.FtraceStatsOuterClass.FtraceCpuStats prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Per-CPU kernel buffer stats for the ftrace data source gathered from
     * /sys/kernel/tracing/per_cpu/cpuX/stats.
     * </pre>
     *
     * Protobuf type {@code perfetto.protos.FtraceCpuStats}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:perfetto.protos.FtraceCpuStats)
        perfetto.protos.FtraceStatsOuterClass.FtraceCpuStatsOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return perfetto.protos.FtraceStatsOuterClass.internal_static_perfetto_protos_FtraceCpuStats_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return perfetto.protos.FtraceStatsOuterClass.internal_static_perfetto_protos_FtraceCpuStats_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                perfetto.protos.FtraceStatsOuterClass.FtraceCpuStats.class, perfetto.protos.FtraceStatsOuterClass.FtraceCpuStats.Builder.class);
      }

      // Construct using perfetto.protos.FtraceStatsOuterClass.FtraceCpuStats.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        cpu_ = 0L;
        entries_ = 0L;
        overrun_ = 0L;
        commitOverrun_ = 0L;
        bytesRead_ = 0L;
        oldestEventTs_ = 0D;
        nowTs_ = 0D;
        droppedEvents_ = 0L;
        readEvents_ = 0L;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return perfetto.protos.FtraceStatsOuterClass.internal_static_perfetto_protos_FtraceCpuStats_descriptor;
      }

      @java.lang.Override
      public perfetto.protos.FtraceStatsOuterClass.FtraceCpuStats getDefaultInstanceForType() {
        return perfetto.protos.FtraceStatsOuterClass.FtraceCpuStats.getDefaultInstance();
      }

      @java.lang.Override
      public perfetto.protos.FtraceStatsOuterClass.FtraceCpuStats build() {
        perfetto.protos.FtraceStatsOuterClass.FtraceCpuStats result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public perfetto.protos.FtraceStatsOuterClass.FtraceCpuStats buildPartial() {
        perfetto.protos.FtraceStatsOuterClass.FtraceCpuStats result = new perfetto.protos.FtraceStatsOuterClass.FtraceCpuStats(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(perfetto.protos.FtraceStatsOuterClass.FtraceCpuStats result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.cpu_ = cpu_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.entries_ = entries_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.overrun_ = overrun_;
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.commitOverrun_ = commitOverrun_;
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.bytesRead_ = bytesRead_;
          to_bitField0_ |= 0x00000010;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          result.oldestEventTs_ = oldestEventTs_;
          to_bitField0_ |= 0x00000020;
        }
        if (((from_bitField0_ & 0x00000040) != 0)) {
          result.nowTs_ = nowTs_;
          to_bitField0_ |= 0x00000040;
        }
        if (((from_bitField0_ & 0x00000080) != 0)) {
          result.droppedEvents_ = droppedEvents_;
          to_bitField0_ |= 0x00000080;
        }
        if (((from_bitField0_ & 0x00000100) != 0)) {
          result.readEvents_ = readEvents_;
          to_bitField0_ |= 0x00000100;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof perfetto.protos.FtraceStatsOuterClass.FtraceCpuStats) {
          return mergeFrom((perfetto.protos.FtraceStatsOuterClass.FtraceCpuStats)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(perfetto.protos.FtraceStatsOuterClass.FtraceCpuStats other) {
        if (other == perfetto.protos.FtraceStatsOuterClass.FtraceCpuStats.getDefaultInstance()) return this;
        if (other.hasCpu()) {
          setCpu(other.getCpu());
        }
        if (other.hasEntries()) {
          setEntries(other.getEntries());
        }
        if (other.hasOverrun()) {
          setOverrun(other.getOverrun());
        }
        if (other.hasCommitOverrun()) {
          setCommitOverrun(other.getCommitOverrun());
        }
        if (other.hasBytesRead()) {
          setBytesRead(other.getBytesRead());
        }
        if (other.hasOldestEventTs()) {
          setOldestEventTs(other.getOldestEventTs());
        }
        if (other.hasNowTs()) {
          setNowTs(other.getNowTs());
        }
        if (other.hasDroppedEvents()) {
          setDroppedEvents(other.getDroppedEvents());
        }
        if (other.hasReadEvents()) {
          setReadEvents(other.getReadEvents());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                cpu_ = input.readUInt64();
                bitField0_ |= 0x00000001;
                break;
              } // case 8
              case 16: {
                entries_ = input.readUInt64();
                bitField0_ |= 0x00000002;
                break;
              } // case 16
              case 24: {
                overrun_ = input.readUInt64();
                bitField0_ |= 0x00000004;
                break;
              } // case 24
              case 32: {
                commitOverrun_ = input.readUInt64();
                bitField0_ |= 0x00000008;
                break;
              } // case 32
              case 40: {
                bytesRead_ = input.readUInt64();
                bitField0_ |= 0x00000010;
                break;
              } // case 40
              case 49: {
                oldestEventTs_ = input.readDouble();
                bitField0_ |= 0x00000020;
                break;
              } // case 49
              case 57: {
                nowTs_ = input.readDouble();
                bitField0_ |= 0x00000040;
                break;
              } // case 57
              case 64: {
                droppedEvents_ = input.readUInt64();
                bitField0_ |= 0x00000080;
                break;
              } // case 64
              case 72: {
                readEvents_ = input.readUInt64();
                bitField0_ |= 0x00000100;
                break;
              } // case 72
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private long cpu_ ;
      /**
       * <pre>
       * CPU index.
       * </pre>
       *
       * <code>optional uint64 cpu = 1;</code>
       * @return Whether the cpu field is set.
       */
      @java.lang.Override
      public boolean hasCpu() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * CPU index.
       * </pre>
       *
       * <code>optional uint64 cpu = 1;</code>
       * @return The cpu.
       */
      @java.lang.Override
      public long getCpu() {
        return cpu_;
      }
      /**
       * <pre>
       * CPU index.
       * </pre>
       *
       * <code>optional uint64 cpu = 1;</code>
       * @param value The cpu to set.
       * @return This builder for chaining.
       */
      public Builder setCpu(long value) {

        cpu_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * CPU index.
       * </pre>
       *
       * <code>optional uint64 cpu = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearCpu() {
        bitField0_ = (bitField0_ & ~0x00000001);
        cpu_ = 0L;
        onChanged();
        return this;
      }

      private long entries_ ;
      /**
       * <pre>
       * Number of entries currently in the kernel buffer.
       * </pre>
       *
       * <code>optional uint64 entries = 2;</code>
       * @return Whether the entries field is set.
       */
      @java.lang.Override
      public boolean hasEntries() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Number of entries currently in the kernel buffer.
       * </pre>
       *
       * <code>optional uint64 entries = 2;</code>
       * @return The entries.
       */
      @java.lang.Override
      public long getEntries() {
        return entries_;
      }
      /**
       * <pre>
       * Number of entries currently in the kernel buffer.
       * </pre>
       *
       * <code>optional uint64 entries = 2;</code>
       * @param value The entries to set.
       * @return This builder for chaining.
       */
      public Builder setEntries(long value) {

        entries_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Number of entries currently in the kernel buffer.
       * </pre>
       *
       * <code>optional uint64 entries = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearEntries() {
        bitField0_ = (bitField0_ & ~0x00000002);
        entries_ = 0L;
        onChanged();
        return this;
      }

      private long overrun_ ;
      /**
       * <pre>
       * Number of events lost in kernel buffers due to overwriting of old events
       * before userspace had a chance to drain them. Valid if the buffer is in
       * "overwrite" mode, otherwise see |dropped_events|.
       * </pre>
       *
       * <code>optional uint64 overrun = 3;</code>
       * @return Whether the overrun field is set.
       */
      @java.lang.Override
      public boolean hasOverrun() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * Number of events lost in kernel buffers due to overwriting of old events
       * before userspace had a chance to drain them. Valid if the buffer is in
       * "overwrite" mode, otherwise see |dropped_events|.
       * </pre>
       *
       * <code>optional uint64 overrun = 3;</code>
       * @return The overrun.
       */
      @java.lang.Override
      public long getOverrun() {
        return overrun_;
      }
      /**
       * <pre>
       * Number of events lost in kernel buffers due to overwriting of old events
       * before userspace had a chance to drain them. Valid if the buffer is in
       * "overwrite" mode, otherwise see |dropped_events|.
       * </pre>
       *
       * <code>optional uint64 overrun = 3;</code>
       * @param value The overrun to set.
       * @return This builder for chaining.
       */
      public Builder setOverrun(long value) {

        overrun_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Number of events lost in kernel buffers due to overwriting of old events
       * before userspace had a chance to drain them. Valid if the buffer is in
       * "overwrite" mode, otherwise see |dropped_events|.
       * </pre>
       *
       * <code>optional uint64 overrun = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearOverrun() {
        bitField0_ = (bitField0_ & ~0x00000004);
        overrun_ = 0L;
        onChanged();
        return this;
      }

      private long commitOverrun_ ;
      /**
       * <pre>
       * This should always be zero. If not the buffer size is way too small or
       * something went wrong with the tracer. Quoting the kernel: "number of
       * commits failing due to the buffer wrapping around while there are
       * uncommitted events, such as during an interrupt storm".
       * </pre>
       *
       * <code>optional uint64 commit_overrun = 4;</code>
       * @return Whether the commitOverrun field is set.
       */
      @java.lang.Override
      public boolean hasCommitOverrun() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * This should always be zero. If not the buffer size is way too small or
       * something went wrong with the tracer. Quoting the kernel: "number of
       * commits failing due to the buffer wrapping around while there are
       * uncommitted events, such as during an interrupt storm".
       * </pre>
       *
       * <code>optional uint64 commit_overrun = 4;</code>
       * @return The commitOverrun.
       */
      @java.lang.Override
      public long getCommitOverrun() {
        return commitOverrun_;
      }
      /**
       * <pre>
       * This should always be zero. If not the buffer size is way too small or
       * something went wrong with the tracer. Quoting the kernel: "number of
       * commits failing due to the buffer wrapping around while there are
       * uncommitted events, such as during an interrupt storm".
       * </pre>
       *
       * <code>optional uint64 commit_overrun = 4;</code>
       * @param value The commitOverrun to set.
       * @return This builder for chaining.
       */
      public Builder setCommitOverrun(long value) {

        commitOverrun_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * This should always be zero. If not the buffer size is way too small or
       * something went wrong with the tracer. Quoting the kernel: "number of
       * commits failing due to the buffer wrapping around while there are
       * uncommitted events, such as during an interrupt storm".
       * </pre>
       *
       * <code>optional uint64 commit_overrun = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearCommitOverrun() {
        bitField0_ = (bitField0_ & ~0x00000008);
        commitOverrun_ = 0L;
        onChanged();
        return this;
      }

      private long bytesRead_ ;
      /**
       * <pre>
       * Size of entries currently in the kernel buffer (see |entries|) in bytes.
       * The field should be named "bytes", but is misnamed for historical reasons.
       * This value has known inaccuracies before Linux v6.6:
       * https://github.com/torvalds/linux/commit/45d99ea
       * </pre>
       *
       * <code>optional uint64 bytes_read = 5;</code>
       * @return Whether the bytesRead field is set.
       */
      @java.lang.Override
      public boolean hasBytesRead() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * Size of entries currently in the kernel buffer (see |entries|) in bytes.
       * The field should be named "bytes", but is misnamed for historical reasons.
       * This value has known inaccuracies before Linux v6.6:
       * https://github.com/torvalds/linux/commit/45d99ea
       * </pre>
       *
       * <code>optional uint64 bytes_read = 5;</code>
       * @return The bytesRead.
       */
      @java.lang.Override
      public long getBytesRead() {
        return bytesRead_;
      }
      /**
       * <pre>
       * Size of entries currently in the kernel buffer (see |entries|) in bytes.
       * The field should be named "bytes", but is misnamed for historical reasons.
       * This value has known inaccuracies before Linux v6.6:
       * https://github.com/torvalds/linux/commit/45d99ea
       * </pre>
       *
       * <code>optional uint64 bytes_read = 5;</code>
       * @param value The bytesRead to set.
       * @return This builder for chaining.
       */
      public Builder setBytesRead(long value) {

        bytesRead_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Size of entries currently in the kernel buffer (see |entries|) in bytes.
       * The field should be named "bytes", but is misnamed for historical reasons.
       * This value has known inaccuracies before Linux v6.6:
       * https://github.com/torvalds/linux/commit/45d99ea
       * </pre>
       *
       * <code>optional uint64 bytes_read = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearBytesRead() {
        bitField0_ = (bitField0_ & ~0x00000010);
        bytesRead_ = 0L;
        onChanged();
        return this;
      }

      private double oldestEventTs_ ;
      /**
       * <pre>
       * The timestamp for the oldest event still in the ring buffer.
       * Unit: seconds for typical trace clocks (i.e. not tsc/counter).
       * </pre>
       *
       * <code>optional double oldest_event_ts = 6;</code>
       * @return Whether the oldestEventTs field is set.
       */
      @java.lang.Override
      public boolean hasOldestEventTs() {
        return ((bitField0_ & 0x00000020) != 0);
      }
      /**
       * <pre>
       * The timestamp for the oldest event still in the ring buffer.
       * Unit: seconds for typical trace clocks (i.e. not tsc/counter).
       * </pre>
       *
       * <code>optional double oldest_event_ts = 6;</code>
       * @return The oldestEventTs.
       */
      @java.lang.Override
      public double getOldestEventTs() {
        return oldestEventTs_;
      }
      /**
       * <pre>
       * The timestamp for the oldest event still in the ring buffer.
       * Unit: seconds for typical trace clocks (i.e. not tsc/counter).
       * </pre>
       *
       * <code>optional double oldest_event_ts = 6;</code>
       * @param value The oldestEventTs to set.
       * @return This builder for chaining.
       */
      public Builder setOldestEventTs(double value) {

        oldestEventTs_ = value;
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The timestamp for the oldest event still in the ring buffer.
       * Unit: seconds for typical trace clocks (i.e. not tsc/counter).
       * </pre>
       *
       * <code>optional double oldest_event_ts = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearOldestEventTs() {
        bitField0_ = (bitField0_ & ~0x00000020);
        oldestEventTs_ = 0D;
        onChanged();
        return this;
      }

      private double nowTs_ ;
      /**
       * <pre>
       * The current timestamp.
       * Unit: seconds for typical trace clocks (i.e. not tsc/counter).
       * </pre>
       *
       * <code>optional double now_ts = 7;</code>
       * @return Whether the nowTs field is set.
       */
      @java.lang.Override
      public boolean hasNowTs() {
        return ((bitField0_ & 0x00000040) != 0);
      }
      /**
       * <pre>
       * The current timestamp.
       * Unit: seconds for typical trace clocks (i.e. not tsc/counter).
       * </pre>
       *
       * <code>optional double now_ts = 7;</code>
       * @return The nowTs.
       */
      @java.lang.Override
      public double getNowTs() {
        return nowTs_;
      }
      /**
       * <pre>
       * The current timestamp.
       * Unit: seconds for typical trace clocks (i.e. not tsc/counter).
       * </pre>
       *
       * <code>optional double now_ts = 7;</code>
       * @param value The nowTs to set.
       * @return This builder for chaining.
       */
      public Builder setNowTs(double value) {

        nowTs_ = value;
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The current timestamp.
       * Unit: seconds for typical trace clocks (i.e. not tsc/counter).
       * </pre>
       *
       * <code>optional double now_ts = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearNowTs() {
        bitField0_ = (bitField0_ & ~0x00000040);
        nowTs_ = 0D;
        onChanged();
        return this;
      }

      private long droppedEvents_ ;
      /**
       * <pre>
       * If the kernel buffer has overwrite mode disabled, this will show the number
       * of new events that were lost because the buffer was full. This is similar
       * to |overrun| but only for the overwrite=false case.
       * </pre>
       *
       * <code>optional uint64 dropped_events = 8;</code>
       * @return Whether the droppedEvents field is set.
       */
      @java.lang.Override
      public boolean hasDroppedEvents() {
        return ((bitField0_ & 0x00000080) != 0);
      }
      /**
       * <pre>
       * If the kernel buffer has overwrite mode disabled, this will show the number
       * of new events that were lost because the buffer was full. This is similar
       * to |overrun| but only for the overwrite=false case.
       * </pre>
       *
       * <code>optional uint64 dropped_events = 8;</code>
       * @return The droppedEvents.
       */
      @java.lang.Override
      public long getDroppedEvents() {
        return droppedEvents_;
      }
      /**
       * <pre>
       * If the kernel buffer has overwrite mode disabled, this will show the number
       * of new events that were lost because the buffer was full. This is similar
       * to |overrun| but only for the overwrite=false case.
       * </pre>
       *
       * <code>optional uint64 dropped_events = 8;</code>
       * @param value The droppedEvents to set.
       * @return This builder for chaining.
       */
      public Builder setDroppedEvents(long value) {

        droppedEvents_ = value;
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If the kernel buffer has overwrite mode disabled, this will show the number
       * of new events that were lost because the buffer was full. This is similar
       * to |overrun| but only for the overwrite=false case.
       * </pre>
       *
       * <code>optional uint64 dropped_events = 8;</code>
       * @return This builder for chaining.
       */
      public Builder clearDroppedEvents() {
        bitField0_ = (bitField0_ & ~0x00000080);
        droppedEvents_ = 0L;
        onChanged();
        return this;
      }

      private long readEvents_ ;
      /**
       * <pre>
       * The number of events read (consumed) from the buffer by userspace.
       * </pre>
       *
       * <code>optional uint64 read_events = 9;</code>
       * @return Whether the readEvents field is set.
       */
      @java.lang.Override
      public boolean hasReadEvents() {
        return ((bitField0_ & 0x00000100) != 0);
      }
      /**
       * <pre>
       * The number of events read (consumed) from the buffer by userspace.
       * </pre>
       *
       * <code>optional uint64 read_events = 9;</code>
       * @return The readEvents.
       */
      @java.lang.Override
      public long getReadEvents() {
        return readEvents_;
      }
      /**
       * <pre>
       * The number of events read (consumed) from the buffer by userspace.
       * </pre>
       *
       * <code>optional uint64 read_events = 9;</code>
       * @param value The readEvents to set.
       * @return This builder for chaining.
       */
      public Builder setReadEvents(long value) {

        readEvents_ = value;
        bitField0_ |= 0x00000100;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The number of events read (consumed) from the buffer by userspace.
       * </pre>
       *
       * <code>optional uint64 read_events = 9;</code>
       * @return This builder for chaining.
       */
      public Builder clearReadEvents() {
        bitField0_ = (bitField0_ & ~0x00000100);
        readEvents_ = 0L;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:perfetto.protos.FtraceCpuStats)
    }

    // @@protoc_insertion_point(class_scope:perfetto.protos.FtraceCpuStats)
    private static final perfetto.protos.FtraceStatsOuterClass.FtraceCpuStats DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new perfetto.protos.FtraceStatsOuterClass.FtraceCpuStats();
    }

    public static perfetto.protos.FtraceStatsOuterClass.FtraceCpuStats getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<FtraceCpuStats>
        PARSER = new com.google.protobuf.AbstractParser<FtraceCpuStats>() {
      @java.lang.Override
      public FtraceCpuStats parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<FtraceCpuStats> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<FtraceCpuStats> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public perfetto.protos.FtraceStatsOuterClass.FtraceCpuStats getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface FtraceStatsOrBuilder extends
      // @@protoc_insertion_point(interface_extends:perfetto.protos.FtraceStats)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * A pair of FtraceStats is written on every trace flush:
     * * START_OF_TRACE - stats recorded at the beginning of the trace.
     * * END_OF_TRACE - stats recorded during the flush. In other words shortly
     * before this packet was written. For simple traces this
     * will be once at the end of the trace.
     * </pre>
     *
     * <code>optional .perfetto.protos.FtraceStats.Phase phase = 1;</code>
     * @return Whether the phase field is set.
     */
    boolean hasPhase();
    /**
     * <pre>
     * A pair of FtraceStats is written on every trace flush:
     * * START_OF_TRACE - stats recorded at the beginning of the trace.
     * * END_OF_TRACE - stats recorded during the flush. In other words shortly
     * before this packet was written. For simple traces this
     * will be once at the end of the trace.
     * </pre>
     *
     * <code>optional .perfetto.protos.FtraceStats.Phase phase = 1;</code>
     * @return The phase.
     */
    perfetto.protos.FtraceStatsOuterClass.FtraceStats.Phase getPhase();

    /**
     * <pre>
     * Per-CPU stats (one entry for each CPU).
     * </pre>
     *
     * <code>repeated .perfetto.protos.FtraceCpuStats cpu_stats = 2;</code>
     */
    java.util.List<perfetto.protos.FtraceStatsOuterClass.FtraceCpuStats> 
        getCpuStatsList();
    /**
     * <pre>
     * Per-CPU stats (one entry for each CPU).
     * </pre>
     *
     * <code>repeated .perfetto.protos.FtraceCpuStats cpu_stats = 2;</code>
     */
    perfetto.protos.FtraceStatsOuterClass.FtraceCpuStats getCpuStats(int index);
    /**
     * <pre>
     * Per-CPU stats (one entry for each CPU).
     * </pre>
     *
     * <code>repeated .perfetto.protos.FtraceCpuStats cpu_stats = 2;</code>
     */
    int getCpuStatsCount();
    /**
     * <pre>
     * Per-CPU stats (one entry for each CPU).
     * </pre>
     *
     * <code>repeated .perfetto.protos.FtraceCpuStats cpu_stats = 2;</code>
     */
    java.util.List<? extends perfetto.protos.FtraceStatsOuterClass.FtraceCpuStatsOrBuilder> 
        getCpuStatsOrBuilderList();
    /**
     * <pre>
     * Per-CPU stats (one entry for each CPU).
     * </pre>
     *
     * <code>repeated .perfetto.protos.FtraceCpuStats cpu_stats = 2;</code>
     */
    perfetto.protos.FtraceStatsOuterClass.FtraceCpuStatsOrBuilder getCpuStatsOrBuilder(
        int index);

    /**
     * <pre>
     * When FtraceConfig.symbolize_ksyms = true, this records the number of
     * symbols parsed from /proc/kallsyms, whether they have been seen in the
     * trace or not. It can be used to debug kptr_restrict or security-related
     * errors.
     * Note: this will be valid only when phase = END_OF_TRACE. The symbolizer is
     * initialized. When START_OF_TRACE is emitted it is not ready yet.
     * </pre>
     *
     * <code>optional uint32 kernel_symbols_parsed = 3;</code>
     * @return Whether the kernelSymbolsParsed field is set.
     */
    boolean hasKernelSymbolsParsed();
    /**
     * <pre>
     * When FtraceConfig.symbolize_ksyms = true, this records the number of
     * symbols parsed from /proc/kallsyms, whether they have been seen in the
     * trace or not. It can be used to debug kptr_restrict or security-related
     * errors.
     * Note: this will be valid only when phase = END_OF_TRACE. The symbolizer is
     * initialized. When START_OF_TRACE is emitted it is not ready yet.
     * </pre>
     *
     * <code>optional uint32 kernel_symbols_parsed = 3;</code>
     * @return The kernelSymbolsParsed.
     */
    int getKernelSymbolsParsed();

    /**
     * <pre>
     * The memory used by the kernel symbolizer (KernelSymbolMap.size_bytes()).
     * </pre>
     *
     * <code>optional uint32 kernel_symbols_mem_kb = 4;</code>
     * @return Whether the kernelSymbolsMemKb field is set.
     */
    boolean hasKernelSymbolsMemKb();
    /**
     * <pre>
     * The memory used by the kernel symbolizer (KernelSymbolMap.size_bytes()).
     * </pre>
     *
     * <code>optional uint32 kernel_symbols_mem_kb = 4;</code>
     * @return The kernelSymbolsMemKb.
     */
    int getKernelSymbolsMemKb();

    /**
     * <pre>
     * Atrace errors (even non-fatal ones) are reported here. A typical example is
     * one or more atrace categories not available on the device.
     * </pre>
     *
     * <code>optional string atrace_errors = 5;</code>
     * @return Whether the atraceErrors field is set.
     */
    boolean hasAtraceErrors();
    /**
     * <pre>
     * Atrace errors (even non-fatal ones) are reported here. A typical example is
     * one or more atrace categories not available on the device.
     * </pre>
     *
     * <code>optional string atrace_errors = 5;</code>
     * @return The atraceErrors.
     */
    java.lang.String getAtraceErrors();
    /**
     * <pre>
     * Atrace errors (even non-fatal ones) are reported here. A typical example is
     * one or more atrace categories not available on the device.
     * </pre>
     *
     * <code>optional string atrace_errors = 5;</code>
     * @return The bytes for atraceErrors.
     */
    com.google.protobuf.ByteString
        getAtraceErrorsBytes();

    /**
     * <pre>
     * Ftrace events requested by the config but not present on device.
     * </pre>
     *
     * <code>repeated string unknown_ftrace_events = 6;</code>
     * @return A list containing the unknownFtraceEvents.
     */
    java.util.List<java.lang.String>
        getUnknownFtraceEventsList();
    /**
     * <pre>
     * Ftrace events requested by the config but not present on device.
     * </pre>
     *
     * <code>repeated string unknown_ftrace_events = 6;</code>
     * @return The count of unknownFtraceEvents.
     */
    int getUnknownFtraceEventsCount();
    /**
     * <pre>
     * Ftrace events requested by the config but not present on device.
     * </pre>
     *
     * <code>repeated string unknown_ftrace_events = 6;</code>
     * @param index The index of the element to return.
     * @return The unknownFtraceEvents at the given index.
     */
    java.lang.String getUnknownFtraceEvents(int index);
    /**
     * <pre>
     * Ftrace events requested by the config but not present on device.
     * </pre>
     *
     * <code>repeated string unknown_ftrace_events = 6;</code>
     * @param index The index of the value to return.
     * @return The bytes of the unknownFtraceEvents at the given index.
     */
    com.google.protobuf.ByteString
        getUnknownFtraceEventsBytes(int index);

    /**
     * <pre>
     * Ftrace events requested by the config and present on device, but which we
     * failed to enable due to permissions, or due to a conflicting option
     * (currently FtraceConfig.disable_generic_events).
     * </pre>
     *
     * <code>repeated string failed_ftrace_events = 7;</code>
     * @return A list containing the failedFtraceEvents.
     */
    java.util.List<java.lang.String>
        getFailedFtraceEventsList();
    /**
     * <pre>
     * Ftrace events requested by the config and present on device, but which we
     * failed to enable due to permissions, or due to a conflicting option
     * (currently FtraceConfig.disable_generic_events).
     * </pre>
     *
     * <code>repeated string failed_ftrace_events = 7;</code>
     * @return The count of failedFtraceEvents.
     */
    int getFailedFtraceEventsCount();
    /**
     * <pre>
     * Ftrace events requested by the config and present on device, but which we
     * failed to enable due to permissions, or due to a conflicting option
     * (currently FtraceConfig.disable_generic_events).
     * </pre>
     *
     * <code>repeated string failed_ftrace_events = 7;</code>
     * @param index The index of the element to return.
     * @return The failedFtraceEvents at the given index.
     */
    java.lang.String getFailedFtraceEvents(int index);
    /**
     * <pre>
     * Ftrace events requested by the config and present on device, but which we
     * failed to enable due to permissions, or due to a conflicting option
     * (currently FtraceConfig.disable_generic_events).
     * </pre>
     *
     * <code>repeated string failed_ftrace_events = 7;</code>
     * @param index The index of the value to return.
     * @return The bytes of the failedFtraceEvents at the given index.
     */
    com.google.protobuf.ByteString
        getFailedFtraceEventsBytes(int index);

    /**
     * <pre>
     * The data source was configured to preserve existing events in the ftrace
     * buffer before the start of the trace.
     * </pre>
     *
     * <code>optional bool preserve_ftrace_buffer = 8;</code>
     * @return Whether the preserveFtraceBuffer field is set.
     */
    boolean hasPreserveFtraceBuffer();
    /**
     * <pre>
     * The data source was configured to preserve existing events in the ftrace
     * buffer before the start of the trace.
     * </pre>
     *
     * <code>optional bool preserve_ftrace_buffer = 8;</code>
     * @return The preserveFtraceBuffer.
     */
    boolean getPreserveFtraceBuffer();

    /**
     * <pre>
     * Unique errors encountered during reading and parsing of the raw ftrace
     * data. Ring buffer ABI related errors will also be recorded in the
     * affected FtraceEventBundles with a timestamp.
     * Any traces with entries in this field should be investigated, as they
     * indicate a bug in perfetto or the kernel.
     * </pre>
     *
     * <code>repeated .perfetto.protos.FtraceParseStatus ftrace_parse_errors = 9;</code>
     * @return A list containing the ftraceParseErrors.
     */
    java.util.List<perfetto.protos.FtraceStatsOuterClass.FtraceParseStatus> getFtraceParseErrorsList();
    /**
     * <pre>
     * Unique errors encountered during reading and parsing of the raw ftrace
     * data. Ring buffer ABI related errors will also be recorded in the
     * affected FtraceEventBundles with a timestamp.
     * Any traces with entries in this field should be investigated, as they
     * indicate a bug in perfetto or the kernel.
     * </pre>
     *
     * <code>repeated .perfetto.protos.FtraceParseStatus ftrace_parse_errors = 9;</code>
     * @return The count of ftraceParseErrors.
     */
    int getFtraceParseErrorsCount();
    /**
     * <pre>
     * Unique errors encountered during reading and parsing of the raw ftrace
     * data. Ring buffer ABI related errors will also be recorded in the
     * affected FtraceEventBundles with a timestamp.
     * Any traces with entries in this field should be investigated, as they
     * indicate a bug in perfetto or the kernel.
     * </pre>
     *
     * <code>repeated .perfetto.protos.FtraceParseStatus ftrace_parse_errors = 9;</code>
     * @param index The index of the element to return.
     * @return The ftraceParseErrors at the given index.
     */
    perfetto.protos.FtraceStatsOuterClass.FtraceParseStatus getFtraceParseErrors(int index);
  }
  /**
   * <pre>
   * Errors and kernel buffer stats for the ftrace data source.
   * </pre>
   *
   * Protobuf type {@code perfetto.protos.FtraceStats}
   */
  public static final class FtraceStats extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:perfetto.protos.FtraceStats)
      FtraceStatsOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 29,
        /* patch= */ 3,
        /* suffix= */ "",
        FtraceStats.class.getName());
    }
    // Use FtraceStats.newBuilder() to construct.
    private FtraceStats(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private FtraceStats() {
      phase_ = 0;
      cpuStats_ = java.util.Collections.emptyList();
      atraceErrors_ = "";
      unknownFtraceEvents_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
      failedFtraceEvents_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
      ftraceParseErrors_ = emptyIntList();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return perfetto.protos.FtraceStatsOuterClass.internal_static_perfetto_protos_FtraceStats_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return perfetto.protos.FtraceStatsOuterClass.internal_static_perfetto_protos_FtraceStats_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              perfetto.protos.FtraceStatsOuterClass.FtraceStats.class, perfetto.protos.FtraceStatsOuterClass.FtraceStats.Builder.class);
    }

    /**
     * Protobuf enum {@code perfetto.protos.FtraceStats.Phase}
     */
    public enum Phase
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <code>UNSPECIFIED = 0;</code>
       */
      UNSPECIFIED(0),
      /**
       * <code>START_OF_TRACE = 1;</code>
       */
      START_OF_TRACE(1),
      /**
       * <code>END_OF_TRACE = 2;</code>
       */
      END_OF_TRACE(2),
      ;

      static {
        com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
          com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
          /* major= */ 4,
          /* minor= */ 29,
          /* patch= */ 3,
          /* suffix= */ "",
          Phase.class.getName());
      }
      /**
       * <code>UNSPECIFIED = 0;</code>
       */
      public static final int UNSPECIFIED_VALUE = 0;
      /**
       * <code>START_OF_TRACE = 1;</code>
       */
      public static final int START_OF_TRACE_VALUE = 1;
      /**
       * <code>END_OF_TRACE = 2;</code>
       */
      public static final int END_OF_TRACE_VALUE = 2;


      public final int getNumber() {
        return value;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static Phase valueOf(int value) {
        return forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       */
      public static Phase forNumber(int value) {
        switch (value) {
          case 0: return UNSPECIFIED;
          case 1: return START_OF_TRACE;
          case 2: return END_OF_TRACE;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<Phase>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          Phase> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<Phase>() {
              public Phase findValueByNumber(int number) {
                return Phase.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return perfetto.protos.FtraceStatsOuterClass.FtraceStats.getDescriptor().getEnumTypes().get(0);
      }

      private static final Phase[] VALUES = values();

      public static Phase valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private Phase(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:perfetto.protos.FtraceStats.Phase)
    }

    private int bitField0_;
    public static final int PHASE_FIELD_NUMBER = 1;
    private int phase_ = 0;
    /**
     * <pre>
     * A pair of FtraceStats is written on every trace flush:
     * * START_OF_TRACE - stats recorded at the beginning of the trace.
     * * END_OF_TRACE - stats recorded during the flush. In other words shortly
     * before this packet was written. For simple traces this
     * will be once at the end of the trace.
     * </pre>
     *
     * <code>optional .perfetto.protos.FtraceStats.Phase phase = 1;</code>
     * @return Whether the phase field is set.
     */
    @java.lang.Override public boolean hasPhase() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * A pair of FtraceStats is written on every trace flush:
     * * START_OF_TRACE - stats recorded at the beginning of the trace.
     * * END_OF_TRACE - stats recorded during the flush. In other words shortly
     * before this packet was written. For simple traces this
     * will be once at the end of the trace.
     * </pre>
     *
     * <code>optional .perfetto.protos.FtraceStats.Phase phase = 1;</code>
     * @return The phase.
     */
    @java.lang.Override public perfetto.protos.FtraceStatsOuterClass.FtraceStats.Phase getPhase() {
      perfetto.protos.FtraceStatsOuterClass.FtraceStats.Phase result = perfetto.protos.FtraceStatsOuterClass.FtraceStats.Phase.forNumber(phase_);
      return result == null ? perfetto.protos.FtraceStatsOuterClass.FtraceStats.Phase.UNSPECIFIED : result;
    }

    public static final int CPU_STATS_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private java.util.List<perfetto.protos.FtraceStatsOuterClass.FtraceCpuStats> cpuStats_;
    /**
     * <pre>
     * Per-CPU stats (one entry for each CPU).
     * </pre>
     *
     * <code>repeated .perfetto.protos.FtraceCpuStats cpu_stats = 2;</code>
     */
    @java.lang.Override
    public java.util.List<perfetto.protos.FtraceStatsOuterClass.FtraceCpuStats> getCpuStatsList() {
      return cpuStats_;
    }
    /**
     * <pre>
     * Per-CPU stats (one entry for each CPU).
     * </pre>
     *
     * <code>repeated .perfetto.protos.FtraceCpuStats cpu_stats = 2;</code>
     */
    @java.lang.Override
    public java.util.List<? extends perfetto.protos.FtraceStatsOuterClass.FtraceCpuStatsOrBuilder> 
        getCpuStatsOrBuilderList() {
      return cpuStats_;
    }
    /**
     * <pre>
     * Per-CPU stats (one entry for each CPU).
     * </pre>
     *
     * <code>repeated .perfetto.protos.FtraceCpuStats cpu_stats = 2;</code>
     */
    @java.lang.Override
    public int getCpuStatsCount() {
      return cpuStats_.size();
    }
    /**
     * <pre>
     * Per-CPU stats (one entry for each CPU).
     * </pre>
     *
     * <code>repeated .perfetto.protos.FtraceCpuStats cpu_stats = 2;</code>
     */
    @java.lang.Override
    public perfetto.protos.FtraceStatsOuterClass.FtraceCpuStats getCpuStats(int index) {
      return cpuStats_.get(index);
    }
    /**
     * <pre>
     * Per-CPU stats (one entry for each CPU).
     * </pre>
     *
     * <code>repeated .perfetto.protos.FtraceCpuStats cpu_stats = 2;</code>
     */
    @java.lang.Override
    public perfetto.protos.FtraceStatsOuterClass.FtraceCpuStatsOrBuilder getCpuStatsOrBuilder(
        int index) {
      return cpuStats_.get(index);
    }

    public static final int KERNEL_SYMBOLS_PARSED_FIELD_NUMBER = 3;
    private int kernelSymbolsParsed_ = 0;
    /**
     * <pre>
     * When FtraceConfig.symbolize_ksyms = true, this records the number of
     * symbols parsed from /proc/kallsyms, whether they have been seen in the
     * trace or not. It can be used to debug kptr_restrict or security-related
     * errors.
     * Note: this will be valid only when phase = END_OF_TRACE. The symbolizer is
     * initialized. When START_OF_TRACE is emitted it is not ready yet.
     * </pre>
     *
     * <code>optional uint32 kernel_symbols_parsed = 3;</code>
     * @return Whether the kernelSymbolsParsed field is set.
     */
    @java.lang.Override
    public boolean hasKernelSymbolsParsed() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * When FtraceConfig.symbolize_ksyms = true, this records the number of
     * symbols parsed from /proc/kallsyms, whether they have been seen in the
     * trace or not. It can be used to debug kptr_restrict or security-related
     * errors.
     * Note: this will be valid only when phase = END_OF_TRACE. The symbolizer is
     * initialized. When START_OF_TRACE is emitted it is not ready yet.
     * </pre>
     *
     * <code>optional uint32 kernel_symbols_parsed = 3;</code>
     * @return The kernelSymbolsParsed.
     */
    @java.lang.Override
    public int getKernelSymbolsParsed() {
      return kernelSymbolsParsed_;
    }

    public static final int KERNEL_SYMBOLS_MEM_KB_FIELD_NUMBER = 4;
    private int kernelSymbolsMemKb_ = 0;
    /**
     * <pre>
     * The memory used by the kernel symbolizer (KernelSymbolMap.size_bytes()).
     * </pre>
     *
     * <code>optional uint32 kernel_symbols_mem_kb = 4;</code>
     * @return Whether the kernelSymbolsMemKb field is set.
     */
    @java.lang.Override
    public boolean hasKernelSymbolsMemKb() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * The memory used by the kernel symbolizer (KernelSymbolMap.size_bytes()).
     * </pre>
     *
     * <code>optional uint32 kernel_symbols_mem_kb = 4;</code>
     * @return The kernelSymbolsMemKb.
     */
    @java.lang.Override
    public int getKernelSymbolsMemKb() {
      return kernelSymbolsMemKb_;
    }

    public static final int ATRACE_ERRORS_FIELD_NUMBER = 5;
    @SuppressWarnings("serial")
    private volatile java.lang.Object atraceErrors_ = "";
    /**
     * <pre>
     * Atrace errors (even non-fatal ones) are reported here. A typical example is
     * one or more atrace categories not available on the device.
     * </pre>
     *
     * <code>optional string atrace_errors = 5;</code>
     * @return Whether the atraceErrors field is set.
     */
    @java.lang.Override
    public boolean hasAtraceErrors() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * Atrace errors (even non-fatal ones) are reported here. A typical example is
     * one or more atrace categories not available on the device.
     * </pre>
     *
     * <code>optional string atrace_errors = 5;</code>
     * @return The atraceErrors.
     */
    @java.lang.Override
    public java.lang.String getAtraceErrors() {
      java.lang.Object ref = atraceErrors_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          atraceErrors_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Atrace errors (even non-fatal ones) are reported here. A typical example is
     * one or more atrace categories not available on the device.
     * </pre>
     *
     * <code>optional string atrace_errors = 5;</code>
     * @return The bytes for atraceErrors.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getAtraceErrorsBytes() {
      java.lang.Object ref = atraceErrors_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        atraceErrors_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int UNKNOWN_FTRACE_EVENTS_FIELD_NUMBER = 6;
    @SuppressWarnings("serial")
    private com.google.protobuf.LazyStringArrayList unknownFtraceEvents_ =
        com.google.protobuf.LazyStringArrayList.emptyList();
    /**
     * <pre>
     * Ftrace events requested by the config but not present on device.
     * </pre>
     *
     * <code>repeated string unknown_ftrace_events = 6;</code>
     * @return A list containing the unknownFtraceEvents.
     */
    public com.google.protobuf.ProtocolStringList
        getUnknownFtraceEventsList() {
      return unknownFtraceEvents_;
    }
    /**
     * <pre>
     * Ftrace events requested by the config but not present on device.
     * </pre>
     *
     * <code>repeated string unknown_ftrace_events = 6;</code>
     * @return The count of unknownFtraceEvents.
     */
    public int getUnknownFtraceEventsCount() {
      return unknownFtraceEvents_.size();
    }
    /**
     * <pre>
     * Ftrace events requested by the config but not present on device.
     * </pre>
     *
     * <code>repeated string unknown_ftrace_events = 6;</code>
     * @param index The index of the element to return.
     * @return The unknownFtraceEvents at the given index.
     */
    public java.lang.String getUnknownFtraceEvents(int index) {
      return unknownFtraceEvents_.get(index);
    }
    /**
     * <pre>
     * Ftrace events requested by the config but not present on device.
     * </pre>
     *
     * <code>repeated string unknown_ftrace_events = 6;</code>
     * @param index The index of the value to return.
     * @return The bytes of the unknownFtraceEvents at the given index.
     */
    public com.google.protobuf.ByteString
        getUnknownFtraceEventsBytes(int index) {
      return unknownFtraceEvents_.getByteString(index);
    }

    public static final int FAILED_FTRACE_EVENTS_FIELD_NUMBER = 7;
    @SuppressWarnings("serial")
    private com.google.protobuf.LazyStringArrayList failedFtraceEvents_ =
        com.google.protobuf.LazyStringArrayList.emptyList();
    /**
     * <pre>
     * Ftrace events requested by the config and present on device, but which we
     * failed to enable due to permissions, or due to a conflicting option
     * (currently FtraceConfig.disable_generic_events).
     * </pre>
     *
     * <code>repeated string failed_ftrace_events = 7;</code>
     * @return A list containing the failedFtraceEvents.
     */
    public com.google.protobuf.ProtocolStringList
        getFailedFtraceEventsList() {
      return failedFtraceEvents_;
    }
    /**
     * <pre>
     * Ftrace events requested by the config and present on device, but which we
     * failed to enable due to permissions, or due to a conflicting option
     * (currently FtraceConfig.disable_generic_events).
     * </pre>
     *
     * <code>repeated string failed_ftrace_events = 7;</code>
     * @return The count of failedFtraceEvents.
     */
    public int getFailedFtraceEventsCount() {
      return failedFtraceEvents_.size();
    }
    /**
     * <pre>
     * Ftrace events requested by the config and present on device, but which we
     * failed to enable due to permissions, or due to a conflicting option
     * (currently FtraceConfig.disable_generic_events).
     * </pre>
     *
     * <code>repeated string failed_ftrace_events = 7;</code>
     * @param index The index of the element to return.
     * @return The failedFtraceEvents at the given index.
     */
    public java.lang.String getFailedFtraceEvents(int index) {
      return failedFtraceEvents_.get(index);
    }
    /**
     * <pre>
     * Ftrace events requested by the config and present on device, but which we
     * failed to enable due to permissions, or due to a conflicting option
     * (currently FtraceConfig.disable_generic_events).
     * </pre>
     *
     * <code>repeated string failed_ftrace_events = 7;</code>
     * @param index The index of the value to return.
     * @return The bytes of the failedFtraceEvents at the given index.
     */
    public com.google.protobuf.ByteString
        getFailedFtraceEventsBytes(int index) {
      return failedFtraceEvents_.getByteString(index);
    }

    public static final int PRESERVE_FTRACE_BUFFER_FIELD_NUMBER = 8;
    private boolean preserveFtraceBuffer_ = false;
    /**
     * <pre>
     * The data source was configured to preserve existing events in the ftrace
     * buffer before the start of the trace.
     * </pre>
     *
     * <code>optional bool preserve_ftrace_buffer = 8;</code>
     * @return Whether the preserveFtraceBuffer field is set.
     */
    @java.lang.Override
    public boolean hasPreserveFtraceBuffer() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * The data source was configured to preserve existing events in the ftrace
     * buffer before the start of the trace.
     * </pre>
     *
     * <code>optional bool preserve_ftrace_buffer = 8;</code>
     * @return The preserveFtraceBuffer.
     */
    @java.lang.Override
    public boolean getPreserveFtraceBuffer() {
      return preserveFtraceBuffer_;
    }

    public static final int FTRACE_PARSE_ERRORS_FIELD_NUMBER = 9;
    @SuppressWarnings("serial")
    private com.google.protobuf.Internal.IntList ftraceParseErrors_;
    private static final com.google.protobuf.Internal.IntListAdapter.IntConverter<
        perfetto.protos.FtraceStatsOuterClass.FtraceParseStatus> ftraceParseErrors_converter_ =
            new com.google.protobuf.Internal.IntListAdapter.IntConverter<
                perfetto.protos.FtraceStatsOuterClass.FtraceParseStatus>() {
              public perfetto.protos.FtraceStatsOuterClass.FtraceParseStatus convert(int from) {
                perfetto.protos.FtraceStatsOuterClass.FtraceParseStatus result = perfetto.protos.FtraceStatsOuterClass.FtraceParseStatus.forNumber(from);
                return result == null ? perfetto.protos.FtraceStatsOuterClass.FtraceParseStatus.FTRACE_STATUS_UNSPECIFIED : result;
              }
            };
    /**
     * <pre>
     * Unique errors encountered during reading and parsing of the raw ftrace
     * data. Ring buffer ABI related errors will also be recorded in the
     * affected FtraceEventBundles with a timestamp.
     * Any traces with entries in this field should be investigated, as they
     * indicate a bug in perfetto or the kernel.
     * </pre>
     *
     * <code>repeated .perfetto.protos.FtraceParseStatus ftrace_parse_errors = 9;</code>
     * @return A list containing the ftraceParseErrors.
     */
    @java.lang.Override
    public java.util.List<perfetto.protos.FtraceStatsOuterClass.FtraceParseStatus> getFtraceParseErrorsList() {
      return new com.google.protobuf.Internal.IntListAdapter<
          perfetto.protos.FtraceStatsOuterClass.FtraceParseStatus>(ftraceParseErrors_, ftraceParseErrors_converter_);
    }
    /**
     * <pre>
     * Unique errors encountered during reading and parsing of the raw ftrace
     * data. Ring buffer ABI related errors will also be recorded in the
     * affected FtraceEventBundles with a timestamp.
     * Any traces with entries in this field should be investigated, as they
     * indicate a bug in perfetto or the kernel.
     * </pre>
     *
     * <code>repeated .perfetto.protos.FtraceParseStatus ftrace_parse_errors = 9;</code>
     * @return The count of ftraceParseErrors.
     */
    @java.lang.Override
    public int getFtraceParseErrorsCount() {
      return ftraceParseErrors_.size();
    }
    /**
     * <pre>
     * Unique errors encountered during reading and parsing of the raw ftrace
     * data. Ring buffer ABI related errors will also be recorded in the
     * affected FtraceEventBundles with a timestamp.
     * Any traces with entries in this field should be investigated, as they
     * indicate a bug in perfetto or the kernel.
     * </pre>
     *
     * <code>repeated .perfetto.protos.FtraceParseStatus ftrace_parse_errors = 9;</code>
     * @param index The index of the element to return.
     * @return The ftraceParseErrors at the given index.
     */
    @java.lang.Override
    public perfetto.protos.FtraceStatsOuterClass.FtraceParseStatus getFtraceParseErrors(int index) {
      return ftraceParseErrors_converter_.convert(ftraceParseErrors_.getInt(index));
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeEnum(1, phase_);
      }
      for (int i = 0; i < cpuStats_.size(); i++) {
        output.writeMessage(2, cpuStats_.get(i));
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeUInt32(3, kernelSymbolsParsed_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeUInt32(4, kernelSymbolsMemKb_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 5, atraceErrors_);
      }
      for (int i = 0; i < unknownFtraceEvents_.size(); i++) {
        com.google.protobuf.GeneratedMessage.writeString(output, 6, unknownFtraceEvents_.getRaw(i));
      }
      for (int i = 0; i < failedFtraceEvents_.size(); i++) {
        com.google.protobuf.GeneratedMessage.writeString(output, 7, failedFtraceEvents_.getRaw(i));
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        output.writeBool(8, preserveFtraceBuffer_);
      }
      for (int i = 0; i < ftraceParseErrors_.size(); i++) {
        output.writeEnum(9, ftraceParseErrors_.getInt(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(1, phase_);
      }
      for (int i = 0; i < cpuStats_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, cpuStats_.get(i));
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(3, kernelSymbolsParsed_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(4, kernelSymbolsMemKb_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(5, atraceErrors_);
      }
      {
        int dataSize = 0;
        for (int i = 0; i < unknownFtraceEvents_.size(); i++) {
          dataSize += computeStringSizeNoTag(unknownFtraceEvents_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getUnknownFtraceEventsList().size();
      }
      {
        int dataSize = 0;
        for (int i = 0; i < failedFtraceEvents_.size(); i++) {
          dataSize += computeStringSizeNoTag(failedFtraceEvents_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getFailedFtraceEventsList().size();
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(8, preserveFtraceBuffer_);
      }
      {
        int dataSize = 0;
        for (int i = 0; i < ftraceParseErrors_.size(); i++) {
          dataSize += com.google.protobuf.CodedOutputStream
            .computeEnumSizeNoTag(ftraceParseErrors_.getInt(i));
        }
        size += dataSize;
        size += 1 * ftraceParseErrors_.size();
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof perfetto.protos.FtraceStatsOuterClass.FtraceStats)) {
        return super.equals(obj);
      }
      perfetto.protos.FtraceStatsOuterClass.FtraceStats other = (perfetto.protos.FtraceStatsOuterClass.FtraceStats) obj;

      if (hasPhase() != other.hasPhase()) return false;
      if (hasPhase()) {
        if (phase_ != other.phase_) return false;
      }
      if (!getCpuStatsList()
          .equals(other.getCpuStatsList())) return false;
      if (hasKernelSymbolsParsed() != other.hasKernelSymbolsParsed()) return false;
      if (hasKernelSymbolsParsed()) {
        if (getKernelSymbolsParsed()
            != other.getKernelSymbolsParsed()) return false;
      }
      if (hasKernelSymbolsMemKb() != other.hasKernelSymbolsMemKb()) return false;
      if (hasKernelSymbolsMemKb()) {
        if (getKernelSymbolsMemKb()
            != other.getKernelSymbolsMemKb()) return false;
      }
      if (hasAtraceErrors() != other.hasAtraceErrors()) return false;
      if (hasAtraceErrors()) {
        if (!getAtraceErrors()
            .equals(other.getAtraceErrors())) return false;
      }
      if (!getUnknownFtraceEventsList()
          .equals(other.getUnknownFtraceEventsList())) return false;
      if (!getFailedFtraceEventsList()
          .equals(other.getFailedFtraceEventsList())) return false;
      if (hasPreserveFtraceBuffer() != other.hasPreserveFtraceBuffer()) return false;
      if (hasPreserveFtraceBuffer()) {
        if (getPreserveFtraceBuffer()
            != other.getPreserveFtraceBuffer()) return false;
      }
      if (!ftraceParseErrors_.equals(other.ftraceParseErrors_)) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasPhase()) {
        hash = (37 * hash) + PHASE_FIELD_NUMBER;
        hash = (53 * hash) + phase_;
      }
      if (getCpuStatsCount() > 0) {
        hash = (37 * hash) + CPU_STATS_FIELD_NUMBER;
        hash = (53 * hash) + getCpuStatsList().hashCode();
      }
      if (hasKernelSymbolsParsed()) {
        hash = (37 * hash) + KERNEL_SYMBOLS_PARSED_FIELD_NUMBER;
        hash = (53 * hash) + getKernelSymbolsParsed();
      }
      if (hasKernelSymbolsMemKb()) {
        hash = (37 * hash) + KERNEL_SYMBOLS_MEM_KB_FIELD_NUMBER;
        hash = (53 * hash) + getKernelSymbolsMemKb();
      }
      if (hasAtraceErrors()) {
        hash = (37 * hash) + ATRACE_ERRORS_FIELD_NUMBER;
        hash = (53 * hash) + getAtraceErrors().hashCode();
      }
      if (getUnknownFtraceEventsCount() > 0) {
        hash = (37 * hash) + UNKNOWN_FTRACE_EVENTS_FIELD_NUMBER;
        hash = (53 * hash) + getUnknownFtraceEventsList().hashCode();
      }
      if (getFailedFtraceEventsCount() > 0) {
        hash = (37 * hash) + FAILED_FTRACE_EVENTS_FIELD_NUMBER;
        hash = (53 * hash) + getFailedFtraceEventsList().hashCode();
      }
      if (hasPreserveFtraceBuffer()) {
        hash = (37 * hash) + PRESERVE_FTRACE_BUFFER_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getPreserveFtraceBuffer());
      }
      if (getFtraceParseErrorsCount() > 0) {
        hash = (37 * hash) + FTRACE_PARSE_ERRORS_FIELD_NUMBER;
        hash = (53 * hash) + ftraceParseErrors_.hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static perfetto.protos.FtraceStatsOuterClass.FtraceStats parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static perfetto.protos.FtraceStatsOuterClass.FtraceStats parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static perfetto.protos.FtraceStatsOuterClass.FtraceStats parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static perfetto.protos.FtraceStatsOuterClass.FtraceStats parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static perfetto.protos.FtraceStatsOuterClass.FtraceStats parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static perfetto.protos.FtraceStatsOuterClass.FtraceStats parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static perfetto.protos.FtraceStatsOuterClass.FtraceStats parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static perfetto.protos.FtraceStatsOuterClass.FtraceStats parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static perfetto.protos.FtraceStatsOuterClass.FtraceStats parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static perfetto.protos.FtraceStatsOuterClass.FtraceStats parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static perfetto.protos.FtraceStatsOuterClass.FtraceStats parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static perfetto.protos.FtraceStatsOuterClass.FtraceStats parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(perfetto.protos.FtraceStatsOuterClass.FtraceStats prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Errors and kernel buffer stats for the ftrace data source.
     * </pre>
     *
     * Protobuf type {@code perfetto.protos.FtraceStats}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:perfetto.protos.FtraceStats)
        perfetto.protos.FtraceStatsOuterClass.FtraceStatsOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return perfetto.protos.FtraceStatsOuterClass.internal_static_perfetto_protos_FtraceStats_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return perfetto.protos.FtraceStatsOuterClass.internal_static_perfetto_protos_FtraceStats_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                perfetto.protos.FtraceStatsOuterClass.FtraceStats.class, perfetto.protos.FtraceStatsOuterClass.FtraceStats.Builder.class);
      }

      // Construct using perfetto.protos.FtraceStatsOuterClass.FtraceStats.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        phase_ = 0;
        if (cpuStatsBuilder_ == null) {
          cpuStats_ = java.util.Collections.emptyList();
        } else {
          cpuStats_ = null;
          cpuStatsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        kernelSymbolsParsed_ = 0;
        kernelSymbolsMemKb_ = 0;
        atraceErrors_ = "";
        unknownFtraceEvents_ =
            com.google.protobuf.LazyStringArrayList.emptyList();
        failedFtraceEvents_ =
            com.google.protobuf.LazyStringArrayList.emptyList();
        preserveFtraceBuffer_ = false;
        ftraceParseErrors_ = emptyIntList();
        bitField0_ = (bitField0_ & ~0x00000100);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return perfetto.protos.FtraceStatsOuterClass.internal_static_perfetto_protos_FtraceStats_descriptor;
      }

      @java.lang.Override
      public perfetto.protos.FtraceStatsOuterClass.FtraceStats getDefaultInstanceForType() {
        return perfetto.protos.FtraceStatsOuterClass.FtraceStats.getDefaultInstance();
      }

      @java.lang.Override
      public perfetto.protos.FtraceStatsOuterClass.FtraceStats build() {
        perfetto.protos.FtraceStatsOuterClass.FtraceStats result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public perfetto.protos.FtraceStatsOuterClass.FtraceStats buildPartial() {
        perfetto.protos.FtraceStatsOuterClass.FtraceStats result = new perfetto.protos.FtraceStatsOuterClass.FtraceStats(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(perfetto.protos.FtraceStatsOuterClass.FtraceStats result) {
        if (cpuStatsBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0)) {
            cpuStats_ = java.util.Collections.unmodifiableList(cpuStats_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.cpuStats_ = cpuStats_;
        } else {
          result.cpuStats_ = cpuStatsBuilder_.build();
        }
        if (((bitField0_ & 0x00000100) != 0)) {
          ftraceParseErrors_.makeImmutable();
          bitField0_ = (bitField0_ & ~0x00000100);
        }
        result.ftraceParseErrors_ = ftraceParseErrors_;
      }

      private void buildPartial0(perfetto.protos.FtraceStatsOuterClass.FtraceStats result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.phase_ = phase_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.kernelSymbolsParsed_ = kernelSymbolsParsed_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.kernelSymbolsMemKb_ = kernelSymbolsMemKb_;
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.atraceErrors_ = atraceErrors_;
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          unknownFtraceEvents_.makeImmutable();
          result.unknownFtraceEvents_ = unknownFtraceEvents_;
        }
        if (((from_bitField0_ & 0x00000040) != 0)) {
          failedFtraceEvents_.makeImmutable();
          result.failedFtraceEvents_ = failedFtraceEvents_;
        }
        if (((from_bitField0_ & 0x00000080) != 0)) {
          result.preserveFtraceBuffer_ = preserveFtraceBuffer_;
          to_bitField0_ |= 0x00000010;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof perfetto.protos.FtraceStatsOuterClass.FtraceStats) {
          return mergeFrom((perfetto.protos.FtraceStatsOuterClass.FtraceStats)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(perfetto.protos.FtraceStatsOuterClass.FtraceStats other) {
        if (other == perfetto.protos.FtraceStatsOuterClass.FtraceStats.getDefaultInstance()) return this;
        if (other.hasPhase()) {
          setPhase(other.getPhase());
        }
        if (cpuStatsBuilder_ == null) {
          if (!other.cpuStats_.isEmpty()) {
            if (cpuStats_.isEmpty()) {
              cpuStats_ = other.cpuStats_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureCpuStatsIsMutable();
              cpuStats_.addAll(other.cpuStats_);
            }
            onChanged();
          }
        } else {
          if (!other.cpuStats_.isEmpty()) {
            if (cpuStatsBuilder_.isEmpty()) {
              cpuStatsBuilder_.dispose();
              cpuStatsBuilder_ = null;
              cpuStats_ = other.cpuStats_;
              bitField0_ = (bitField0_ & ~0x00000002);
              cpuStatsBuilder_ = 
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   getCpuStatsFieldBuilder() : null;
            } else {
              cpuStatsBuilder_.addAllMessages(other.cpuStats_);
            }
          }
        }
        if (other.hasKernelSymbolsParsed()) {
          setKernelSymbolsParsed(other.getKernelSymbolsParsed());
        }
        if (other.hasKernelSymbolsMemKb()) {
          setKernelSymbolsMemKb(other.getKernelSymbolsMemKb());
        }
        if (other.hasAtraceErrors()) {
          atraceErrors_ = other.atraceErrors_;
          bitField0_ |= 0x00000010;
          onChanged();
        }
        if (!other.unknownFtraceEvents_.isEmpty()) {
          if (unknownFtraceEvents_.isEmpty()) {
            unknownFtraceEvents_ = other.unknownFtraceEvents_;
            bitField0_ |= 0x00000020;
          } else {
            ensureUnknownFtraceEventsIsMutable();
            unknownFtraceEvents_.addAll(other.unknownFtraceEvents_);
          }
          onChanged();
        }
        if (!other.failedFtraceEvents_.isEmpty()) {
          if (failedFtraceEvents_.isEmpty()) {
            failedFtraceEvents_ = other.failedFtraceEvents_;
            bitField0_ |= 0x00000040;
          } else {
            ensureFailedFtraceEventsIsMutable();
            failedFtraceEvents_.addAll(other.failedFtraceEvents_);
          }
          onChanged();
        }
        if (other.hasPreserveFtraceBuffer()) {
          setPreserveFtraceBuffer(other.getPreserveFtraceBuffer());
        }
        if (!other.ftraceParseErrors_.isEmpty()) {
          if (ftraceParseErrors_.isEmpty()) {
            ftraceParseErrors_ = other.ftraceParseErrors_;
            bitField0_ = (bitField0_ & ~0x00000100);
          } else {
            ensureFtraceParseErrorsIsMutable();
            ftraceParseErrors_.addAll(other.ftraceParseErrors_);
          }
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                int tmpRaw = input.readEnum();
                perfetto.protos.FtraceStatsOuterClass.FtraceStats.Phase tmpValue =
                    perfetto.protos.FtraceStatsOuterClass.FtraceStats.Phase.forNumber(tmpRaw);
                if (tmpValue == null) {
                  mergeUnknownVarintField(1, tmpRaw);
                } else {
                  phase_ = tmpRaw;
                  bitField0_ |= 0x00000001;
                }
                break;
              } // case 8
              case 18: {
                perfetto.protos.FtraceStatsOuterClass.FtraceCpuStats m =
                    input.readMessage(
                        perfetto.protos.FtraceStatsOuterClass.FtraceCpuStats.parser(),
                        extensionRegistry);
                if (cpuStatsBuilder_ == null) {
                  ensureCpuStatsIsMutable();
                  cpuStats_.add(m);
                } else {
                  cpuStatsBuilder_.addMessage(m);
                }
                break;
              } // case 18
              case 24: {
                kernelSymbolsParsed_ = input.readUInt32();
                bitField0_ |= 0x00000004;
                break;
              } // case 24
              case 32: {
                kernelSymbolsMemKb_ = input.readUInt32();
                bitField0_ |= 0x00000008;
                break;
              } // case 32
              case 42: {
                atraceErrors_ = input.readBytes();
                bitField0_ |= 0x00000010;
                break;
              } // case 42
              case 50: {
                com.google.protobuf.ByteString bs = input.readBytes();
                ensureUnknownFtraceEventsIsMutable();
                unknownFtraceEvents_.add(bs);
                break;
              } // case 50
              case 58: {
                com.google.protobuf.ByteString bs = input.readBytes();
                ensureFailedFtraceEventsIsMutable();
                failedFtraceEvents_.add(bs);
                break;
              } // case 58
              case 64: {
                preserveFtraceBuffer_ = input.readBool();
                bitField0_ |= 0x00000080;
                break;
              } // case 64
              case 72: {
                int tmpRaw = input.readEnum();
                perfetto.protos.FtraceStatsOuterClass.FtraceParseStatus tmpValue =
                    perfetto.protos.FtraceStatsOuterClass.FtraceParseStatus.forNumber(tmpRaw);
                if (tmpValue == null) {
                  mergeUnknownVarintField(9, tmpRaw);
                } else {
                  ensureFtraceParseErrorsIsMutable();
                  ftraceParseErrors_.addInt(tmpRaw);
                }
                break;
              } // case 72
              case 74: {
                int length = input.readRawVarint32();
                int oldLimit = input.pushLimit(length);
                while(input.getBytesUntilLimit() > 0) {
                  int tmpRaw = input.readEnum();
                  perfetto.protos.FtraceStatsOuterClass.FtraceParseStatus tmpValue =
                      perfetto.protos.FtraceStatsOuterClass.FtraceParseStatus.forNumber(tmpRaw);
                  if (tmpValue == null) {
                    mergeUnknownVarintField(9, tmpRaw);
                  } else {
                    ensureFtraceParseErrorsIsMutable();
                    ftraceParseErrors_.addInt(tmpRaw);
                  }
                }
                input.popLimit(oldLimit);
                break;
              } // case 74
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private int phase_ = 0;
      /**
       * <pre>
       * A pair of FtraceStats is written on every trace flush:
       * * START_OF_TRACE - stats recorded at the beginning of the trace.
       * * END_OF_TRACE - stats recorded during the flush. In other words shortly
       * before this packet was written. For simple traces this
       * will be once at the end of the trace.
       * </pre>
       *
       * <code>optional .perfetto.protos.FtraceStats.Phase phase = 1;</code>
       * @return Whether the phase field is set.
       */
      @java.lang.Override public boolean hasPhase() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * A pair of FtraceStats is written on every trace flush:
       * * START_OF_TRACE - stats recorded at the beginning of the trace.
       * * END_OF_TRACE - stats recorded during the flush. In other words shortly
       * before this packet was written. For simple traces this
       * will be once at the end of the trace.
       * </pre>
       *
       * <code>optional .perfetto.protos.FtraceStats.Phase phase = 1;</code>
       * @return The phase.
       */
      @java.lang.Override
      public perfetto.protos.FtraceStatsOuterClass.FtraceStats.Phase getPhase() {
        perfetto.protos.FtraceStatsOuterClass.FtraceStats.Phase result = perfetto.protos.FtraceStatsOuterClass.FtraceStats.Phase.forNumber(phase_);
        return result == null ? perfetto.protos.FtraceStatsOuterClass.FtraceStats.Phase.UNSPECIFIED : result;
      }
      /**
       * <pre>
       * A pair of FtraceStats is written on every trace flush:
       * * START_OF_TRACE - stats recorded at the beginning of the trace.
       * * END_OF_TRACE - stats recorded during the flush. In other words shortly
       * before this packet was written. For simple traces this
       * will be once at the end of the trace.
       * </pre>
       *
       * <code>optional .perfetto.protos.FtraceStats.Phase phase = 1;</code>
       * @param value The phase to set.
       * @return This builder for chaining.
       */
      public Builder setPhase(perfetto.protos.FtraceStatsOuterClass.FtraceStats.Phase value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000001;
        phase_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A pair of FtraceStats is written on every trace flush:
       * * START_OF_TRACE - stats recorded at the beginning of the trace.
       * * END_OF_TRACE - stats recorded during the flush. In other words shortly
       * before this packet was written. For simple traces this
       * will be once at the end of the trace.
       * </pre>
       *
       * <code>optional .perfetto.protos.FtraceStats.Phase phase = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearPhase() {
        bitField0_ = (bitField0_ & ~0x00000001);
        phase_ = 0;
        onChanged();
        return this;
      }

      private java.util.List<perfetto.protos.FtraceStatsOuterClass.FtraceCpuStats> cpuStats_ =
        java.util.Collections.emptyList();
      private void ensureCpuStatsIsMutable() {
        if (!((bitField0_ & 0x00000002) != 0)) {
          cpuStats_ = new java.util.ArrayList<perfetto.protos.FtraceStatsOuterClass.FtraceCpuStats>(cpuStats_);
          bitField0_ |= 0x00000002;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          perfetto.protos.FtraceStatsOuterClass.FtraceCpuStats, perfetto.protos.FtraceStatsOuterClass.FtraceCpuStats.Builder, perfetto.protos.FtraceStatsOuterClass.FtraceCpuStatsOrBuilder> cpuStatsBuilder_;

      /**
       * <pre>
       * Per-CPU stats (one entry for each CPU).
       * </pre>
       *
       * <code>repeated .perfetto.protos.FtraceCpuStats cpu_stats = 2;</code>
       */
      public java.util.List<perfetto.protos.FtraceStatsOuterClass.FtraceCpuStats> getCpuStatsList() {
        if (cpuStatsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(cpuStats_);
        } else {
          return cpuStatsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Per-CPU stats (one entry for each CPU).
       * </pre>
       *
       * <code>repeated .perfetto.protos.FtraceCpuStats cpu_stats = 2;</code>
       */
      public int getCpuStatsCount() {
        if (cpuStatsBuilder_ == null) {
          return cpuStats_.size();
        } else {
          return cpuStatsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Per-CPU stats (one entry for each CPU).
       * </pre>
       *
       * <code>repeated .perfetto.protos.FtraceCpuStats cpu_stats = 2;</code>
       */
      public perfetto.protos.FtraceStatsOuterClass.FtraceCpuStats getCpuStats(int index) {
        if (cpuStatsBuilder_ == null) {
          return cpuStats_.get(index);
        } else {
          return cpuStatsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Per-CPU stats (one entry for each CPU).
       * </pre>
       *
       * <code>repeated .perfetto.protos.FtraceCpuStats cpu_stats = 2;</code>
       */
      public Builder setCpuStats(
          int index, perfetto.protos.FtraceStatsOuterClass.FtraceCpuStats value) {
        if (cpuStatsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureCpuStatsIsMutable();
          cpuStats_.set(index, value);
          onChanged();
        } else {
          cpuStatsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Per-CPU stats (one entry for each CPU).
       * </pre>
       *
       * <code>repeated .perfetto.protos.FtraceCpuStats cpu_stats = 2;</code>
       */
      public Builder setCpuStats(
          int index, perfetto.protos.FtraceStatsOuterClass.FtraceCpuStats.Builder builderForValue) {
        if (cpuStatsBuilder_ == null) {
          ensureCpuStatsIsMutable();
          cpuStats_.set(index, builderForValue.build());
          onChanged();
        } else {
          cpuStatsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Per-CPU stats (one entry for each CPU).
       * </pre>
       *
       * <code>repeated .perfetto.protos.FtraceCpuStats cpu_stats = 2;</code>
       */
      public Builder addCpuStats(perfetto.protos.FtraceStatsOuterClass.FtraceCpuStats value) {
        if (cpuStatsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureCpuStatsIsMutable();
          cpuStats_.add(value);
          onChanged();
        } else {
          cpuStatsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Per-CPU stats (one entry for each CPU).
       * </pre>
       *
       * <code>repeated .perfetto.protos.FtraceCpuStats cpu_stats = 2;</code>
       */
      public Builder addCpuStats(
          int index, perfetto.protos.FtraceStatsOuterClass.FtraceCpuStats value) {
        if (cpuStatsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureCpuStatsIsMutable();
          cpuStats_.add(index, value);
          onChanged();
        } else {
          cpuStatsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Per-CPU stats (one entry for each CPU).
       * </pre>
       *
       * <code>repeated .perfetto.protos.FtraceCpuStats cpu_stats = 2;</code>
       */
      public Builder addCpuStats(
          perfetto.protos.FtraceStatsOuterClass.FtraceCpuStats.Builder builderForValue) {
        if (cpuStatsBuilder_ == null) {
          ensureCpuStatsIsMutable();
          cpuStats_.add(builderForValue.build());
          onChanged();
        } else {
          cpuStatsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Per-CPU stats (one entry for each CPU).
       * </pre>
       *
       * <code>repeated .perfetto.protos.FtraceCpuStats cpu_stats = 2;</code>
       */
      public Builder addCpuStats(
          int index, perfetto.protos.FtraceStatsOuterClass.FtraceCpuStats.Builder builderForValue) {
        if (cpuStatsBuilder_ == null) {
          ensureCpuStatsIsMutable();
          cpuStats_.add(index, builderForValue.build());
          onChanged();
        } else {
          cpuStatsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Per-CPU stats (one entry for each CPU).
       * </pre>
       *
       * <code>repeated .perfetto.protos.FtraceCpuStats cpu_stats = 2;</code>
       */
      public Builder addAllCpuStats(
          java.lang.Iterable<? extends perfetto.protos.FtraceStatsOuterClass.FtraceCpuStats> values) {
        if (cpuStatsBuilder_ == null) {
          ensureCpuStatsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, cpuStats_);
          onChanged();
        } else {
          cpuStatsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Per-CPU stats (one entry for each CPU).
       * </pre>
       *
       * <code>repeated .perfetto.protos.FtraceCpuStats cpu_stats = 2;</code>
       */
      public Builder clearCpuStats() {
        if (cpuStatsBuilder_ == null) {
          cpuStats_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          cpuStatsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Per-CPU stats (one entry for each CPU).
       * </pre>
       *
       * <code>repeated .perfetto.protos.FtraceCpuStats cpu_stats = 2;</code>
       */
      public Builder removeCpuStats(int index) {
        if (cpuStatsBuilder_ == null) {
          ensureCpuStatsIsMutable();
          cpuStats_.remove(index);
          onChanged();
        } else {
          cpuStatsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Per-CPU stats (one entry for each CPU).
       * </pre>
       *
       * <code>repeated .perfetto.protos.FtraceCpuStats cpu_stats = 2;</code>
       */
      public perfetto.protos.FtraceStatsOuterClass.FtraceCpuStats.Builder getCpuStatsBuilder(
          int index) {
        return getCpuStatsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Per-CPU stats (one entry for each CPU).
       * </pre>
       *
       * <code>repeated .perfetto.protos.FtraceCpuStats cpu_stats = 2;</code>
       */
      public perfetto.protos.FtraceStatsOuterClass.FtraceCpuStatsOrBuilder getCpuStatsOrBuilder(
          int index) {
        if (cpuStatsBuilder_ == null) {
          return cpuStats_.get(index);  } else {
          return cpuStatsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Per-CPU stats (one entry for each CPU).
       * </pre>
       *
       * <code>repeated .perfetto.protos.FtraceCpuStats cpu_stats = 2;</code>
       */
      public java.util.List<? extends perfetto.protos.FtraceStatsOuterClass.FtraceCpuStatsOrBuilder> 
           getCpuStatsOrBuilderList() {
        if (cpuStatsBuilder_ != null) {
          return cpuStatsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(cpuStats_);
        }
      }
      /**
       * <pre>
       * Per-CPU stats (one entry for each CPU).
       * </pre>
       *
       * <code>repeated .perfetto.protos.FtraceCpuStats cpu_stats = 2;</code>
       */
      public perfetto.protos.FtraceStatsOuterClass.FtraceCpuStats.Builder addCpuStatsBuilder() {
        return getCpuStatsFieldBuilder().addBuilder(
            perfetto.protos.FtraceStatsOuterClass.FtraceCpuStats.getDefaultInstance());
      }
      /**
       * <pre>
       * Per-CPU stats (one entry for each CPU).
       * </pre>
       *
       * <code>repeated .perfetto.protos.FtraceCpuStats cpu_stats = 2;</code>
       */
      public perfetto.protos.FtraceStatsOuterClass.FtraceCpuStats.Builder addCpuStatsBuilder(
          int index) {
        return getCpuStatsFieldBuilder().addBuilder(
            index, perfetto.protos.FtraceStatsOuterClass.FtraceCpuStats.getDefaultInstance());
      }
      /**
       * <pre>
       * Per-CPU stats (one entry for each CPU).
       * </pre>
       *
       * <code>repeated .perfetto.protos.FtraceCpuStats cpu_stats = 2;</code>
       */
      public java.util.List<perfetto.protos.FtraceStatsOuterClass.FtraceCpuStats.Builder> 
           getCpuStatsBuilderList() {
        return getCpuStatsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          perfetto.protos.FtraceStatsOuterClass.FtraceCpuStats, perfetto.protos.FtraceStatsOuterClass.FtraceCpuStats.Builder, perfetto.protos.FtraceStatsOuterClass.FtraceCpuStatsOrBuilder> 
          getCpuStatsFieldBuilder() {
        if (cpuStatsBuilder_ == null) {
          cpuStatsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              perfetto.protos.FtraceStatsOuterClass.FtraceCpuStats, perfetto.protos.FtraceStatsOuterClass.FtraceCpuStats.Builder, perfetto.protos.FtraceStatsOuterClass.FtraceCpuStatsOrBuilder>(
                  cpuStats_,
                  ((bitField0_ & 0x00000002) != 0),
                  getParentForChildren(),
                  isClean());
          cpuStats_ = null;
        }
        return cpuStatsBuilder_;
      }

      private int kernelSymbolsParsed_ ;
      /**
       * <pre>
       * When FtraceConfig.symbolize_ksyms = true, this records the number of
       * symbols parsed from /proc/kallsyms, whether they have been seen in the
       * trace or not. It can be used to debug kptr_restrict or security-related
       * errors.
       * Note: this will be valid only when phase = END_OF_TRACE. The symbolizer is
       * initialized. When START_OF_TRACE is emitted it is not ready yet.
       * </pre>
       *
       * <code>optional uint32 kernel_symbols_parsed = 3;</code>
       * @return Whether the kernelSymbolsParsed field is set.
       */
      @java.lang.Override
      public boolean hasKernelSymbolsParsed() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * When FtraceConfig.symbolize_ksyms = true, this records the number of
       * symbols parsed from /proc/kallsyms, whether they have been seen in the
       * trace or not. It can be used to debug kptr_restrict or security-related
       * errors.
       * Note: this will be valid only when phase = END_OF_TRACE. The symbolizer is
       * initialized. When START_OF_TRACE is emitted it is not ready yet.
       * </pre>
       *
       * <code>optional uint32 kernel_symbols_parsed = 3;</code>
       * @return The kernelSymbolsParsed.
       */
      @java.lang.Override
      public int getKernelSymbolsParsed() {
        return kernelSymbolsParsed_;
      }
      /**
       * <pre>
       * When FtraceConfig.symbolize_ksyms = true, this records the number of
       * symbols parsed from /proc/kallsyms, whether they have been seen in the
       * trace or not. It can be used to debug kptr_restrict or security-related
       * errors.
       * Note: this will be valid only when phase = END_OF_TRACE. The symbolizer is
       * initialized. When START_OF_TRACE is emitted it is not ready yet.
       * </pre>
       *
       * <code>optional uint32 kernel_symbols_parsed = 3;</code>
       * @param value The kernelSymbolsParsed to set.
       * @return This builder for chaining.
       */
      public Builder setKernelSymbolsParsed(int value) {

        kernelSymbolsParsed_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * When FtraceConfig.symbolize_ksyms = true, this records the number of
       * symbols parsed from /proc/kallsyms, whether they have been seen in the
       * trace or not. It can be used to debug kptr_restrict or security-related
       * errors.
       * Note: this will be valid only when phase = END_OF_TRACE. The symbolizer is
       * initialized. When START_OF_TRACE is emitted it is not ready yet.
       * </pre>
       *
       * <code>optional uint32 kernel_symbols_parsed = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearKernelSymbolsParsed() {
        bitField0_ = (bitField0_ & ~0x00000004);
        kernelSymbolsParsed_ = 0;
        onChanged();
        return this;
      }

      private int kernelSymbolsMemKb_ ;
      /**
       * <pre>
       * The memory used by the kernel symbolizer (KernelSymbolMap.size_bytes()).
       * </pre>
       *
       * <code>optional uint32 kernel_symbols_mem_kb = 4;</code>
       * @return Whether the kernelSymbolsMemKb field is set.
       */
      @java.lang.Override
      public boolean hasKernelSymbolsMemKb() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * The memory used by the kernel symbolizer (KernelSymbolMap.size_bytes()).
       * </pre>
       *
       * <code>optional uint32 kernel_symbols_mem_kb = 4;</code>
       * @return The kernelSymbolsMemKb.
       */
      @java.lang.Override
      public int getKernelSymbolsMemKb() {
        return kernelSymbolsMemKb_;
      }
      /**
       * <pre>
       * The memory used by the kernel symbolizer (KernelSymbolMap.size_bytes()).
       * </pre>
       *
       * <code>optional uint32 kernel_symbols_mem_kb = 4;</code>
       * @param value The kernelSymbolsMemKb to set.
       * @return This builder for chaining.
       */
      public Builder setKernelSymbolsMemKb(int value) {

        kernelSymbolsMemKb_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The memory used by the kernel symbolizer (KernelSymbolMap.size_bytes()).
       * </pre>
       *
       * <code>optional uint32 kernel_symbols_mem_kb = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearKernelSymbolsMemKb() {
        bitField0_ = (bitField0_ & ~0x00000008);
        kernelSymbolsMemKb_ = 0;
        onChanged();
        return this;
      }

      private java.lang.Object atraceErrors_ = "";
      /**
       * <pre>
       * Atrace errors (even non-fatal ones) are reported here. A typical example is
       * one or more atrace categories not available on the device.
       * </pre>
       *
       * <code>optional string atrace_errors = 5;</code>
       * @return Whether the atraceErrors field is set.
       */
      public boolean hasAtraceErrors() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * Atrace errors (even non-fatal ones) are reported here. A typical example is
       * one or more atrace categories not available on the device.
       * </pre>
       *
       * <code>optional string atrace_errors = 5;</code>
       * @return The atraceErrors.
       */
      public java.lang.String getAtraceErrors() {
        java.lang.Object ref = atraceErrors_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            atraceErrors_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Atrace errors (even non-fatal ones) are reported here. A typical example is
       * one or more atrace categories not available on the device.
       * </pre>
       *
       * <code>optional string atrace_errors = 5;</code>
       * @return The bytes for atraceErrors.
       */
      public com.google.protobuf.ByteString
          getAtraceErrorsBytes() {
        java.lang.Object ref = atraceErrors_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          atraceErrors_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Atrace errors (even non-fatal ones) are reported here. A typical example is
       * one or more atrace categories not available on the device.
       * </pre>
       *
       * <code>optional string atrace_errors = 5;</code>
       * @param value The atraceErrors to set.
       * @return This builder for chaining.
       */
      public Builder setAtraceErrors(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        atraceErrors_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Atrace errors (even non-fatal ones) are reported here. A typical example is
       * one or more atrace categories not available on the device.
       * </pre>
       *
       * <code>optional string atrace_errors = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearAtraceErrors() {
        atraceErrors_ = getDefaultInstance().getAtraceErrors();
        bitField0_ = (bitField0_ & ~0x00000010);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Atrace errors (even non-fatal ones) are reported here. A typical example is
       * one or more atrace categories not available on the device.
       * </pre>
       *
       * <code>optional string atrace_errors = 5;</code>
       * @param value The bytes for atraceErrors to set.
       * @return This builder for chaining.
       */
      public Builder setAtraceErrorsBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        atraceErrors_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }

      private com.google.protobuf.LazyStringArrayList unknownFtraceEvents_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
      private void ensureUnknownFtraceEventsIsMutable() {
        if (!unknownFtraceEvents_.isModifiable()) {
          unknownFtraceEvents_ = new com.google.protobuf.LazyStringArrayList(unknownFtraceEvents_);
        }
        bitField0_ |= 0x00000020;
      }
      /**
       * <pre>
       * Ftrace events requested by the config but not present on device.
       * </pre>
       *
       * <code>repeated string unknown_ftrace_events = 6;</code>
       * @return A list containing the unknownFtraceEvents.
       */
      public com.google.protobuf.ProtocolStringList
          getUnknownFtraceEventsList() {
        unknownFtraceEvents_.makeImmutable();
        return unknownFtraceEvents_;
      }
      /**
       * <pre>
       * Ftrace events requested by the config but not present on device.
       * </pre>
       *
       * <code>repeated string unknown_ftrace_events = 6;</code>
       * @return The count of unknownFtraceEvents.
       */
      public int getUnknownFtraceEventsCount() {
        return unknownFtraceEvents_.size();
      }
      /**
       * <pre>
       * Ftrace events requested by the config but not present on device.
       * </pre>
       *
       * <code>repeated string unknown_ftrace_events = 6;</code>
       * @param index The index of the element to return.
       * @return The unknownFtraceEvents at the given index.
       */
      public java.lang.String getUnknownFtraceEvents(int index) {
        return unknownFtraceEvents_.get(index);
      }
      /**
       * <pre>
       * Ftrace events requested by the config but not present on device.
       * </pre>
       *
       * <code>repeated string unknown_ftrace_events = 6;</code>
       * @param index The index of the value to return.
       * @return The bytes of the unknownFtraceEvents at the given index.
       */
      public com.google.protobuf.ByteString
          getUnknownFtraceEventsBytes(int index) {
        return unknownFtraceEvents_.getByteString(index);
      }
      /**
       * <pre>
       * Ftrace events requested by the config but not present on device.
       * </pre>
       *
       * <code>repeated string unknown_ftrace_events = 6;</code>
       * @param index The index to set the value at.
       * @param value The unknownFtraceEvents to set.
       * @return This builder for chaining.
       */
      public Builder setUnknownFtraceEvents(
          int index, java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureUnknownFtraceEventsIsMutable();
        unknownFtraceEvents_.set(index, value);
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Ftrace events requested by the config but not present on device.
       * </pre>
       *
       * <code>repeated string unknown_ftrace_events = 6;</code>
       * @param value The unknownFtraceEvents to add.
       * @return This builder for chaining.
       */
      public Builder addUnknownFtraceEvents(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureUnknownFtraceEventsIsMutable();
        unknownFtraceEvents_.add(value);
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Ftrace events requested by the config but not present on device.
       * </pre>
       *
       * <code>repeated string unknown_ftrace_events = 6;</code>
       * @param values The unknownFtraceEvents to add.
       * @return This builder for chaining.
       */
      public Builder addAllUnknownFtraceEvents(
          java.lang.Iterable<java.lang.String> values) {
        ensureUnknownFtraceEventsIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, unknownFtraceEvents_);
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Ftrace events requested by the config but not present on device.
       * </pre>
       *
       * <code>repeated string unknown_ftrace_events = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearUnknownFtraceEvents() {
        unknownFtraceEvents_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
        bitField0_ = (bitField0_ & ~0x00000020);;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Ftrace events requested by the config but not present on device.
       * </pre>
       *
       * <code>repeated string unknown_ftrace_events = 6;</code>
       * @param value The bytes of the unknownFtraceEvents to add.
       * @return This builder for chaining.
       */
      public Builder addUnknownFtraceEventsBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        ensureUnknownFtraceEventsIsMutable();
        unknownFtraceEvents_.add(value);
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }

      private com.google.protobuf.LazyStringArrayList failedFtraceEvents_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
      private void ensureFailedFtraceEventsIsMutable() {
        if (!failedFtraceEvents_.isModifiable()) {
          failedFtraceEvents_ = new com.google.protobuf.LazyStringArrayList(failedFtraceEvents_);
        }
        bitField0_ |= 0x00000040;
      }
      /**
       * <pre>
       * Ftrace events requested by the config and present on device, but which we
       * failed to enable due to permissions, or due to a conflicting option
       * (currently FtraceConfig.disable_generic_events).
       * </pre>
       *
       * <code>repeated string failed_ftrace_events = 7;</code>
       * @return A list containing the failedFtraceEvents.
       */
      public com.google.protobuf.ProtocolStringList
          getFailedFtraceEventsList() {
        failedFtraceEvents_.makeImmutable();
        return failedFtraceEvents_;
      }
      /**
       * <pre>
       * Ftrace events requested by the config and present on device, but which we
       * failed to enable due to permissions, or due to a conflicting option
       * (currently FtraceConfig.disable_generic_events).
       * </pre>
       *
       * <code>repeated string failed_ftrace_events = 7;</code>
       * @return The count of failedFtraceEvents.
       */
      public int getFailedFtraceEventsCount() {
        return failedFtraceEvents_.size();
      }
      /**
       * <pre>
       * Ftrace events requested by the config and present on device, but which we
       * failed to enable due to permissions, or due to a conflicting option
       * (currently FtraceConfig.disable_generic_events).
       * </pre>
       *
       * <code>repeated string failed_ftrace_events = 7;</code>
       * @param index The index of the element to return.
       * @return The failedFtraceEvents at the given index.
       */
      public java.lang.String getFailedFtraceEvents(int index) {
        return failedFtraceEvents_.get(index);
      }
      /**
       * <pre>
       * Ftrace events requested by the config and present on device, but which we
       * failed to enable due to permissions, or due to a conflicting option
       * (currently FtraceConfig.disable_generic_events).
       * </pre>
       *
       * <code>repeated string failed_ftrace_events = 7;</code>
       * @param index The index of the value to return.
       * @return The bytes of the failedFtraceEvents at the given index.
       */
      public com.google.protobuf.ByteString
          getFailedFtraceEventsBytes(int index) {
        return failedFtraceEvents_.getByteString(index);
      }
      /**
       * <pre>
       * Ftrace events requested by the config and present on device, but which we
       * failed to enable due to permissions, or due to a conflicting option
       * (currently FtraceConfig.disable_generic_events).
       * </pre>
       *
       * <code>repeated string failed_ftrace_events = 7;</code>
       * @param index The index to set the value at.
       * @param value The failedFtraceEvents to set.
       * @return This builder for chaining.
       */
      public Builder setFailedFtraceEvents(
          int index, java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureFailedFtraceEventsIsMutable();
        failedFtraceEvents_.set(index, value);
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Ftrace events requested by the config and present on device, but which we
       * failed to enable due to permissions, or due to a conflicting option
       * (currently FtraceConfig.disable_generic_events).
       * </pre>
       *
       * <code>repeated string failed_ftrace_events = 7;</code>
       * @param value The failedFtraceEvents to add.
       * @return This builder for chaining.
       */
      public Builder addFailedFtraceEvents(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureFailedFtraceEventsIsMutable();
        failedFtraceEvents_.add(value);
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Ftrace events requested by the config and present on device, but which we
       * failed to enable due to permissions, or due to a conflicting option
       * (currently FtraceConfig.disable_generic_events).
       * </pre>
       *
       * <code>repeated string failed_ftrace_events = 7;</code>
       * @param values The failedFtraceEvents to add.
       * @return This builder for chaining.
       */
      public Builder addAllFailedFtraceEvents(
          java.lang.Iterable<java.lang.String> values) {
        ensureFailedFtraceEventsIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, failedFtraceEvents_);
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Ftrace events requested by the config and present on device, but which we
       * failed to enable due to permissions, or due to a conflicting option
       * (currently FtraceConfig.disable_generic_events).
       * </pre>
       *
       * <code>repeated string failed_ftrace_events = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearFailedFtraceEvents() {
        failedFtraceEvents_ =
          com.google.protobuf.LazyStringArrayList.emptyList();
        bitField0_ = (bitField0_ & ~0x00000040);;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Ftrace events requested by the config and present on device, but which we
       * failed to enable due to permissions, or due to a conflicting option
       * (currently FtraceConfig.disable_generic_events).
       * </pre>
       *
       * <code>repeated string failed_ftrace_events = 7;</code>
       * @param value The bytes of the failedFtraceEvents to add.
       * @return This builder for chaining.
       */
      public Builder addFailedFtraceEventsBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        ensureFailedFtraceEventsIsMutable();
        failedFtraceEvents_.add(value);
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }

      private boolean preserveFtraceBuffer_ ;
      /**
       * <pre>
       * The data source was configured to preserve existing events in the ftrace
       * buffer before the start of the trace.
       * </pre>
       *
       * <code>optional bool preserve_ftrace_buffer = 8;</code>
       * @return Whether the preserveFtraceBuffer field is set.
       */
      @java.lang.Override
      public boolean hasPreserveFtraceBuffer() {
        return ((bitField0_ & 0x00000080) != 0);
      }
      /**
       * <pre>
       * The data source was configured to preserve existing events in the ftrace
       * buffer before the start of the trace.
       * </pre>
       *
       * <code>optional bool preserve_ftrace_buffer = 8;</code>
       * @return The preserveFtraceBuffer.
       */
      @java.lang.Override
      public boolean getPreserveFtraceBuffer() {
        return preserveFtraceBuffer_;
      }
      /**
       * <pre>
       * The data source was configured to preserve existing events in the ftrace
       * buffer before the start of the trace.
       * </pre>
       *
       * <code>optional bool preserve_ftrace_buffer = 8;</code>
       * @param value The preserveFtraceBuffer to set.
       * @return This builder for chaining.
       */
      public Builder setPreserveFtraceBuffer(boolean value) {

        preserveFtraceBuffer_ = value;
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The data source was configured to preserve existing events in the ftrace
       * buffer before the start of the trace.
       * </pre>
       *
       * <code>optional bool preserve_ftrace_buffer = 8;</code>
       * @return This builder for chaining.
       */
      public Builder clearPreserveFtraceBuffer() {
        bitField0_ = (bitField0_ & ~0x00000080);
        preserveFtraceBuffer_ = false;
        onChanged();
        return this;
      }

      private com.google.protobuf.Internal.IntList ftraceParseErrors_ =
        emptyIntList();
      private void ensureFtraceParseErrorsIsMutable() {
        if (!((bitField0_ & 0x00000100) != 0)) {
          ftraceParseErrors_ = makeMutableCopy(ftraceParseErrors_);
          bitField0_ |= 0x00000100;
        }
      }
      /**
       * <pre>
       * Unique errors encountered during reading and parsing of the raw ftrace
       * data. Ring buffer ABI related errors will also be recorded in the
       * affected FtraceEventBundles with a timestamp.
       * Any traces with entries in this field should be investigated, as they
       * indicate a bug in perfetto or the kernel.
       * </pre>
       *
       * <code>repeated .perfetto.protos.FtraceParseStatus ftrace_parse_errors = 9;</code>
       * @return A list containing the ftraceParseErrors.
       */
      public java.util.List<perfetto.protos.FtraceStatsOuterClass.FtraceParseStatus> getFtraceParseErrorsList() {
        return new com.google.protobuf.Internal.IntListAdapter<
            perfetto.protos.FtraceStatsOuterClass.FtraceParseStatus>(ftraceParseErrors_, ftraceParseErrors_converter_);
      }
      /**
       * <pre>
       * Unique errors encountered during reading and parsing of the raw ftrace
       * data. Ring buffer ABI related errors will also be recorded in the
       * affected FtraceEventBundles with a timestamp.
       * Any traces with entries in this field should be investigated, as they
       * indicate a bug in perfetto or the kernel.
       * </pre>
       *
       * <code>repeated .perfetto.protos.FtraceParseStatus ftrace_parse_errors = 9;</code>
       * @return The count of ftraceParseErrors.
       */
      public int getFtraceParseErrorsCount() {
        return ftraceParseErrors_.size();
      }
      /**
       * <pre>
       * Unique errors encountered during reading and parsing of the raw ftrace
       * data. Ring buffer ABI related errors will also be recorded in the
       * affected FtraceEventBundles with a timestamp.
       * Any traces with entries in this field should be investigated, as they
       * indicate a bug in perfetto or the kernel.
       * </pre>
       *
       * <code>repeated .perfetto.protos.FtraceParseStatus ftrace_parse_errors = 9;</code>
       * @param index The index of the element to return.
       * @return The ftraceParseErrors at the given index.
       */
      public perfetto.protos.FtraceStatsOuterClass.FtraceParseStatus getFtraceParseErrors(int index) {
        return ftraceParseErrors_converter_.convert(ftraceParseErrors_.getInt(index));
      }
      /**
       * <pre>
       * Unique errors encountered during reading and parsing of the raw ftrace
       * data. Ring buffer ABI related errors will also be recorded in the
       * affected FtraceEventBundles with a timestamp.
       * Any traces with entries in this field should be investigated, as they
       * indicate a bug in perfetto or the kernel.
       * </pre>
       *
       * <code>repeated .perfetto.protos.FtraceParseStatus ftrace_parse_errors = 9;</code>
       * @param index The index to set the value at.
       * @param value The ftraceParseErrors to set.
       * @return This builder for chaining.
       */
      public Builder setFtraceParseErrors(
          int index, perfetto.protos.FtraceStatsOuterClass.FtraceParseStatus value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureFtraceParseErrorsIsMutable();
        ftraceParseErrors_.setInt(index, value.getNumber());
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Unique errors encountered during reading and parsing of the raw ftrace
       * data. Ring buffer ABI related errors will also be recorded in the
       * affected FtraceEventBundles with a timestamp.
       * Any traces with entries in this field should be investigated, as they
       * indicate a bug in perfetto or the kernel.
       * </pre>
       *
       * <code>repeated .perfetto.protos.FtraceParseStatus ftrace_parse_errors = 9;</code>
       * @param value The ftraceParseErrors to add.
       * @return This builder for chaining.
       */
      public Builder addFtraceParseErrors(perfetto.protos.FtraceStatsOuterClass.FtraceParseStatus value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureFtraceParseErrorsIsMutable();
        ftraceParseErrors_.addInt(value.getNumber());
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Unique errors encountered during reading and parsing of the raw ftrace
       * data. Ring buffer ABI related errors will also be recorded in the
       * affected FtraceEventBundles with a timestamp.
       * Any traces with entries in this field should be investigated, as they
       * indicate a bug in perfetto or the kernel.
       * </pre>
       *
       * <code>repeated .perfetto.protos.FtraceParseStatus ftrace_parse_errors = 9;</code>
       * @param values The ftraceParseErrors to add.
       * @return This builder for chaining.
       */
      public Builder addAllFtraceParseErrors(
          java.lang.Iterable<? extends perfetto.protos.FtraceStatsOuterClass.FtraceParseStatus> values) {
        ensureFtraceParseErrorsIsMutable();
        for (perfetto.protos.FtraceStatsOuterClass.FtraceParseStatus value : values) {
          ftraceParseErrors_.addInt(value.getNumber());
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Unique errors encountered during reading and parsing of the raw ftrace
       * data. Ring buffer ABI related errors will also be recorded in the
       * affected FtraceEventBundles with a timestamp.
       * Any traces with entries in this field should be investigated, as they
       * indicate a bug in perfetto or the kernel.
       * </pre>
       *
       * <code>repeated .perfetto.protos.FtraceParseStatus ftrace_parse_errors = 9;</code>
       * @return This builder for chaining.
       */
      public Builder clearFtraceParseErrors() {
        ftraceParseErrors_ = emptyIntList();
        bitField0_ = (bitField0_ & ~0x00000100);
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:perfetto.protos.FtraceStats)
    }

    // @@protoc_insertion_point(class_scope:perfetto.protos.FtraceStats)
    private static final perfetto.protos.FtraceStatsOuterClass.FtraceStats DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new perfetto.protos.FtraceStatsOuterClass.FtraceStats();
    }

    public static perfetto.protos.FtraceStatsOuterClass.FtraceStats getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<FtraceStats>
        PARSER = new com.google.protobuf.AbstractParser<FtraceStats>() {
      @java.lang.Override
      public FtraceStats parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<FtraceStats> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<FtraceStats> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public perfetto.protos.FtraceStatsOuterClass.FtraceStats getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_perfetto_protos_FtraceCpuStats_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_perfetto_protos_FtraceCpuStats_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_perfetto_protos_FtraceStats_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_perfetto_protos_FtraceStats_fieldAccessorTable;

  public static com.google.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
    return descriptor;
  }
  private static  com.google.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
    java.lang.String[] descriptorData = {
      "\n/protos/perfetto/trace/ftrace/ftrace_st" +
      "ats.proto\022\017perfetto.protos\"\301\001\n\016FtraceCpu" +
      "Stats\022\013\n\003cpu\030\001 \001(\004\022\017\n\007entries\030\002 \001(\004\022\017\n\007o" +
      "verrun\030\003 \001(\004\022\026\n\016commit_overrun\030\004 \001(\004\022\022\n\n" +
      "bytes_read\030\005 \001(\004\022\027\n\017oldest_event_ts\030\006 \001(" +
      "\001\022\016\n\006now_ts\030\007 \001(\001\022\026\n\016dropped_events\030\010 \001(" +
      "\004\022\023\n\013read_events\030\t \001(\004\"\247\003\n\013FtraceStats\0221" +
      "\n\005phase\030\001 \001(\0162\".perfetto.protos.FtraceSt" +
      "ats.Phase\0222\n\tcpu_stats\030\002 \003(\0132\037.perfetto." +
      "protos.FtraceCpuStats\022\035\n\025kernel_symbols_" +
      "parsed\030\003 \001(\r\022\035\n\025kernel_symbols_mem_kb\030\004 " +
      "\001(\r\022\025\n\ratrace_errors\030\005 \001(\t\022\035\n\025unknown_ft" +
      "race_events\030\006 \003(\t\022\034\n\024failed_ftrace_event" +
      "s\030\007 \003(\t\022\036\n\026preserve_ftrace_buffer\030\010 \001(\010\022" +
      "?\n\023ftrace_parse_errors\030\t \003(\0162\".perfetto." +
      "protos.FtraceParseStatus\">\n\005Phase\022\017\n\013UNS" +
      "PECIFIED\020\000\022\022\n\016START_OF_TRACE\020\001\022\020\n\014END_OF" +
      "_TRACE\020\002*\310\005\n\021FtraceParseStatus\022\035\n\031FTRACE" +
      "_STATUS_UNSPECIFIED\020\000\022\024\n\020FTRACE_STATUS_O" +
      "K\020\001\022\'\n#FTRACE_STATUS_UNEXPECTED_READ_ERR" +
      "OR\020\002\022#\n\037FTRACE_STATUS_PARTIAL_PAGE_READ\020" +
      "\003\022)\n%FTRACE_STATUS_ABI_INVALID_PAGE_HEAD" +
      "ER\020\004\022(\n$FTRACE_STATUS_ABI_SHORT_EVENT_HE" +
      "ADER\020\005\022\"\n\036FTRACE_STATUS_ABI_NULL_PADDING" +
      "\020\006\022*\n&FTRACE_STATUS_ABI_SHORT_PADDING_LE" +
      "NGTH\020\007\022,\n(FTRACE_STATUS_ABI_INVALID_PADD" +
      "ING_LENGTH\020\010\022\'\n#FTRACE_STATUS_ABI_SHORT_" +
      "TIME_EXTEND\020\t\022&\n\"FTRACE_STATUS_ABI_SHORT" +
      "_TIME_STAMP\020\n\022\'\n#FTRACE_STATUS_ABI_SHORT" +
      "_DATA_LENGTH\020\013\022&\n\"FTRACE_STATUS_ABI_ZERO" +
      "_DATA_LENGTH\020\014\022)\n%FTRACE_STATUS_ABI_INVA" +
      "LID_DATA_LENGTH\020\r\022$\n FTRACE_STATUS_ABI_S" +
      "HORT_EVENT_ID\020\016\022\"\n\036FTRACE_STATUS_ABI_END" +
      "_OVERFLOW\020\017\022%\n!FTRACE_STATUS_SHORT_COMPA" +
      "CT_EVENT\020\020\022\037\n\033FTRACE_STATUS_INVALID_EVEN" +
      "T\020\021"
    };
    descriptor = com.google.protobuf.Descriptors.FileDescriptor
      .internalBuildGeneratedFileFrom(descriptorData,
        new com.google.protobuf.Descriptors.FileDescriptor[] {
        });
    internal_static_perfetto_protos_FtraceCpuStats_descriptor =
      getDescriptor().getMessageTypes().get(0);
    internal_static_perfetto_protos_FtraceCpuStats_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_perfetto_protos_FtraceCpuStats_descriptor,
        new java.lang.String[] { "Cpu", "Entries", "Overrun", "CommitOverrun", "BytesRead", "OldestEventTs", "NowTs", "DroppedEvents", "ReadEvents", });
    internal_static_perfetto_protos_FtraceStats_descriptor =
      getDescriptor().getMessageTypes().get(1);
    internal_static_perfetto_protos_FtraceStats_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_perfetto_protos_FtraceStats_descriptor,
        new java.lang.String[] { "Phase", "CpuStats", "KernelSymbolsParsed", "KernelSymbolsMemKb", "AtraceErrors", "UnknownFtraceEvents", "FailedFtraceEvents", "PreserveFtraceBuffer", "FtraceParseErrors", });
    descriptor.resolveAllFeaturesImmutable();
  }

  // @@protoc_insertion_point(outer_class_scope)
}
