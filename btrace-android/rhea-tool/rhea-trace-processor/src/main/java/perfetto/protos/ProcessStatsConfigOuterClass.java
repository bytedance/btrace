// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: protos/perfetto/config/process_stats/process_stats_config.proto
// Protobuf Java Version: 4.29.3

package perfetto.protos;

public final class ProcessStatsConfigOuterClass {
  private ProcessStatsConfigOuterClass() {}
  static {
    com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
      com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
      /* major= */ 4,
      /* minor= */ 29,
      /* patch= */ 3,
      /* suffix= */ "",
      ProcessStatsConfigOuterClass.class.getName());
  }
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }

  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistry registry) {
    registerAllExtensions(
        (com.google.protobuf.ExtensionRegistryLite) registry);
  }
  public interface ProcessStatsConfigOrBuilder extends
      // @@protoc_insertion_point(interface_extends:perfetto.protos.ProcessStatsConfig)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>repeated .perfetto.protos.ProcessStatsConfig.Quirks quirks = 1;</code>
     * @return A list containing the quirks.
     */
    java.util.List<perfetto.protos.ProcessStatsConfigOuterClass.ProcessStatsConfig.Quirks> getQuirksList();
    /**
     * <code>repeated .perfetto.protos.ProcessStatsConfig.Quirks quirks = 1;</code>
     * @return The count of quirks.
     */
    int getQuirksCount();
    /**
     * <code>repeated .perfetto.protos.ProcessStatsConfig.Quirks quirks = 1;</code>
     * @param index The index of the element to return.
     * @return The quirks at the given index.
     */
    perfetto.protos.ProcessStatsConfigOuterClass.ProcessStatsConfig.Quirks getQuirks(int index);

    /**
     * <pre>
     * If enabled all processes will be scanned and dumped when the trace starts.
     * </pre>
     *
     * <code>optional bool scan_all_processes_on_start = 2;</code>
     * @return Whether the scanAllProcessesOnStart field is set.
     */
    boolean hasScanAllProcessesOnStart();
    /**
     * <pre>
     * If enabled all processes will be scanned and dumped when the trace starts.
     * </pre>
     *
     * <code>optional bool scan_all_processes_on_start = 2;</code>
     * @return The scanAllProcessesOnStart.
     */
    boolean getScanAllProcessesOnStart();

    /**
     * <pre>
     * If enabled thread names are also recoded (this is redundant if sched_switch
     * is enabled).
     * </pre>
     *
     * <code>optional bool record_thread_names = 3;</code>
     * @return Whether the recordThreadNames field is set.
     */
    boolean hasRecordThreadNames();
    /**
     * <pre>
     * If enabled thread names are also recoded (this is redundant if sched_switch
     * is enabled).
     * </pre>
     *
     * <code>optional bool record_thread_names = 3;</code>
     * @return The recordThreadNames.
     */
    boolean getRecordThreadNames();

    /**
     * <pre>
     * If &gt; 0 samples counters (see process_stats.proto) from
     * /proc/pid/status and oom_score_adj every X ms.
     * It will also sample /proc/pid/smaps_rollup if scan_smaps_rollup = true.
     * This is required to be &gt; 100ms to avoid excessive CPU usage.
     * </pre>
     *
     * <code>optional uint32 proc_stats_poll_ms = 4;</code>
     * @return Whether the procStatsPollMs field is set.
     */
    boolean hasProcStatsPollMs();
    /**
     * <pre>
     * If &gt; 0 samples counters (see process_stats.proto) from
     * /proc/pid/status and oom_score_adj every X ms.
     * It will also sample /proc/pid/smaps_rollup if scan_smaps_rollup = true.
     * This is required to be &gt; 100ms to avoid excessive CPU usage.
     * </pre>
     *
     * <code>optional uint32 proc_stats_poll_ms = 4;</code>
     * @return The procStatsPollMs.
     */
    int getProcStatsPollMs();

    /**
     * <pre>
     * This is required to be either = 0 or a multiple of |proc_stats_poll_ms|
     * (default: |proc_stats_poll_ms|). If = 0, will be set to
     * |proc_stats_poll_ms|. Non-multiples will be rounded down to the nearest
     * multiple.
     * </pre>
     *
     * <code>optional uint32 proc_stats_cache_ttl_ms = 6;</code>
     * @return Whether the procStatsCacheTtlMs field is set.
     */
    boolean hasProcStatsCacheTtlMs();
    /**
     * <pre>
     * This is required to be either = 0 or a multiple of |proc_stats_poll_ms|
     * (default: |proc_stats_poll_ms|). If = 0, will be set to
     * |proc_stats_poll_ms|. Non-multiples will be rounded down to the nearest
     * multiple.
     * </pre>
     *
     * <code>optional uint32 proc_stats_cache_ttl_ms = 6;</code>
     * @return The procStatsCacheTtlMs.
     */
    int getProcStatsCacheTtlMs();

    /**
     * <pre>
     * Niche feature: If true this will resolve file descriptors for each process
     * so these can be mapped to their actual device or file.
     * Requires raw_syscalls/sys_{enter,exit} ftrace events to be enabled or
     * new fds opened after initially scanning a process will not be
     * recognized.
     * </pre>
     *
     * <code>optional bool resolve_process_fds = 9;</code>
     * @return Whether the resolveProcessFds field is set.
     */
    boolean hasResolveProcessFds();
    /**
     * <pre>
     * Niche feature: If true this will resolve file descriptors for each process
     * so these can be mapped to their actual device or file.
     * Requires raw_syscalls/sys_{enter,exit} ftrace events to be enabled or
     * new fds opened after initially scanning a process will not be
     * recognized.
     * </pre>
     *
     * <code>optional bool resolve_process_fds = 9;</code>
     * @return The resolveProcessFds.
     */
    boolean getResolveProcessFds();

    /**
     * <pre>
     * If true, output will include memory stats from /proc/pid/smaps_rollup.
     * </pre>
     *
     * <code>optional bool scan_smaps_rollup = 10;</code>
     * @return Whether the scanSmapsRollup field is set.
     */
    boolean hasScanSmapsRollup();
    /**
     * <pre>
     * If true, output will include memory stats from /proc/pid/smaps_rollup.
     * </pre>
     *
     * <code>optional bool scan_smaps_rollup = 10;</code>
     * @return The scanSmapsRollup.
     */
    boolean getScanSmapsRollup();

    /**
     * <pre>
     * If true: process descriptions will include process age (starttime in
     * /proc/pid/stat).
     * Introduced in: perfetto v44.
     * </pre>
     *
     * <code>optional bool record_process_age = 11;</code>
     * @return Whether the recordProcessAge field is set.
     */
    boolean hasRecordProcessAge();
    /**
     * <pre>
     * If true: process descriptions will include process age (starttime in
     * /proc/pid/stat).
     * Introduced in: perfetto v44.
     * </pre>
     *
     * <code>optional bool record_process_age = 11;</code>
     * @return The recordProcessAge.
     */
    boolean getRecordProcessAge();

    /**
     * <pre>
     * If true and |proc_stats_poll_ms| is true, process stats will include time
     * spent running in user/kernel mode (utime/stime in /proc/pid/stat).
     * Introduced in: perfetto v44.
     * </pre>
     *
     * <code>optional bool record_process_runtime = 12;</code>
     * @return Whether the recordProcessRuntime field is set.
     */
    boolean hasRecordProcessRuntime();
    /**
     * <pre>
     * If true and |proc_stats_poll_ms| is true, process stats will include time
     * spent running in user/kernel mode (utime/stime in /proc/pid/stat).
     * Introduced in: perfetto v44.
     * </pre>
     *
     * <code>optional bool record_process_runtime = 12;</code>
     * @return The recordProcessRuntime.
     */
    boolean getRecordProcessRuntime();
  }
  /**
   * Protobuf type {@code perfetto.protos.ProcessStatsConfig}
   */
  public static final class ProcessStatsConfig extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:perfetto.protos.ProcessStatsConfig)
      ProcessStatsConfigOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 29,
        /* patch= */ 3,
        /* suffix= */ "",
        ProcessStatsConfig.class.getName());
    }
    // Use ProcessStatsConfig.newBuilder() to construct.
    private ProcessStatsConfig(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private ProcessStatsConfig() {
      quirks_ = emptyIntList();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return perfetto.protos.ProcessStatsConfigOuterClass.internal_static_perfetto_protos_ProcessStatsConfig_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return perfetto.protos.ProcessStatsConfigOuterClass.internal_static_perfetto_protos_ProcessStatsConfig_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              perfetto.protos.ProcessStatsConfigOuterClass.ProcessStatsConfig.class, perfetto.protos.ProcessStatsConfigOuterClass.ProcessStatsConfig.Builder.class);
    }

    /**
     * Protobuf enum {@code perfetto.protos.ProcessStatsConfig.Quirks}
     */
    public enum Quirks
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <code>QUIRKS_UNSPECIFIED = 0;</code>
       */
      QUIRKS_UNSPECIFIED(0),
      /**
       * <pre>
       * This has been deprecated and ignored as per 2018-05-01. Full scan at
       * startup is now disabled by default and can be re-enabled using the
       * |scan_all_processes_on_start| arg.
       * </pre>
       *
       * <code>DISABLE_INITIAL_DUMP = 1 [deprecated = true];</code>
       */
      @java.lang.Deprecated
      DISABLE_INITIAL_DUMP(1),
      /**
       * <code>DISABLE_ON_DEMAND = 2;</code>
       */
      DISABLE_ON_DEMAND(2),
      ;

      static {
        com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
          com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
          /* major= */ 4,
          /* minor= */ 29,
          /* patch= */ 3,
          /* suffix= */ "",
          Quirks.class.getName());
      }
      /**
       * <code>QUIRKS_UNSPECIFIED = 0;</code>
       */
      public static final int QUIRKS_UNSPECIFIED_VALUE = 0;
      /**
       * <pre>
       * This has been deprecated and ignored as per 2018-05-01. Full scan at
       * startup is now disabled by default and can be re-enabled using the
       * |scan_all_processes_on_start| arg.
       * </pre>
       *
       * <code>DISABLE_INITIAL_DUMP = 1 [deprecated = true];</code>
       */
      @java.lang.Deprecated public static final int DISABLE_INITIAL_DUMP_VALUE = 1;
      /**
       * <code>DISABLE_ON_DEMAND = 2;</code>
       */
      public static final int DISABLE_ON_DEMAND_VALUE = 2;


      public final int getNumber() {
        return value;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static Quirks valueOf(int value) {
        return forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       */
      public static Quirks forNumber(int value) {
        switch (value) {
          case 0: return QUIRKS_UNSPECIFIED;
          case 1: return DISABLE_INITIAL_DUMP;
          case 2: return DISABLE_ON_DEMAND;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<Quirks>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          Quirks> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<Quirks>() {
              public Quirks findValueByNumber(int number) {
                return Quirks.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return perfetto.protos.ProcessStatsConfigOuterClass.ProcessStatsConfig.getDescriptor().getEnumTypes().get(0);
      }

      private static final Quirks[] VALUES = values();

      public static Quirks valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private Quirks(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:perfetto.protos.ProcessStatsConfig.Quirks)
    }

    private int bitField0_;
    public static final int QUIRKS_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private com.google.protobuf.Internal.IntList quirks_;
    private static final com.google.protobuf.Internal.IntListAdapter.IntConverter<
        perfetto.protos.ProcessStatsConfigOuterClass.ProcessStatsConfig.Quirks> quirks_converter_ =
            new com.google.protobuf.Internal.IntListAdapter.IntConverter<
                perfetto.protos.ProcessStatsConfigOuterClass.ProcessStatsConfig.Quirks>() {
              public perfetto.protos.ProcessStatsConfigOuterClass.ProcessStatsConfig.Quirks convert(int from) {
                perfetto.protos.ProcessStatsConfigOuterClass.ProcessStatsConfig.Quirks result = perfetto.protos.ProcessStatsConfigOuterClass.ProcessStatsConfig.Quirks.forNumber(from);
                return result == null ? perfetto.protos.ProcessStatsConfigOuterClass.ProcessStatsConfig.Quirks.QUIRKS_UNSPECIFIED : result;
              }
            };
    /**
     * <code>repeated .perfetto.protos.ProcessStatsConfig.Quirks quirks = 1;</code>
     * @return A list containing the quirks.
     */
    @java.lang.Override
    public java.util.List<perfetto.protos.ProcessStatsConfigOuterClass.ProcessStatsConfig.Quirks> getQuirksList() {
      return new com.google.protobuf.Internal.IntListAdapter<
          perfetto.protos.ProcessStatsConfigOuterClass.ProcessStatsConfig.Quirks>(quirks_, quirks_converter_);
    }
    /**
     * <code>repeated .perfetto.protos.ProcessStatsConfig.Quirks quirks = 1;</code>
     * @return The count of quirks.
     */
    @java.lang.Override
    public int getQuirksCount() {
      return quirks_.size();
    }
    /**
     * <code>repeated .perfetto.protos.ProcessStatsConfig.Quirks quirks = 1;</code>
     * @param index The index of the element to return.
     * @return The quirks at the given index.
     */
    @java.lang.Override
    public perfetto.protos.ProcessStatsConfigOuterClass.ProcessStatsConfig.Quirks getQuirks(int index) {
      return quirks_converter_.convert(quirks_.getInt(index));
    }

    public static final int SCAN_ALL_PROCESSES_ON_START_FIELD_NUMBER = 2;
    private boolean scanAllProcessesOnStart_ = false;
    /**
     * <pre>
     * If enabled all processes will be scanned and dumped when the trace starts.
     * </pre>
     *
     * <code>optional bool scan_all_processes_on_start = 2;</code>
     * @return Whether the scanAllProcessesOnStart field is set.
     */
    @java.lang.Override
    public boolean hasScanAllProcessesOnStart() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * If enabled all processes will be scanned and dumped when the trace starts.
     * </pre>
     *
     * <code>optional bool scan_all_processes_on_start = 2;</code>
     * @return The scanAllProcessesOnStart.
     */
    @java.lang.Override
    public boolean getScanAllProcessesOnStart() {
      return scanAllProcessesOnStart_;
    }

    public static final int RECORD_THREAD_NAMES_FIELD_NUMBER = 3;
    private boolean recordThreadNames_ = false;
    /**
     * <pre>
     * If enabled thread names are also recoded (this is redundant if sched_switch
     * is enabled).
     * </pre>
     *
     * <code>optional bool record_thread_names = 3;</code>
     * @return Whether the recordThreadNames field is set.
     */
    @java.lang.Override
    public boolean hasRecordThreadNames() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * If enabled thread names are also recoded (this is redundant if sched_switch
     * is enabled).
     * </pre>
     *
     * <code>optional bool record_thread_names = 3;</code>
     * @return The recordThreadNames.
     */
    @java.lang.Override
    public boolean getRecordThreadNames() {
      return recordThreadNames_;
    }

    public static final int PROC_STATS_POLL_MS_FIELD_NUMBER = 4;
    private int procStatsPollMs_ = 0;
    /**
     * <pre>
     * If &gt; 0 samples counters (see process_stats.proto) from
     * /proc/pid/status and oom_score_adj every X ms.
     * It will also sample /proc/pid/smaps_rollup if scan_smaps_rollup = true.
     * This is required to be &gt; 100ms to avoid excessive CPU usage.
     * </pre>
     *
     * <code>optional uint32 proc_stats_poll_ms = 4;</code>
     * @return Whether the procStatsPollMs field is set.
     */
    @java.lang.Override
    public boolean hasProcStatsPollMs() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * If &gt; 0 samples counters (see process_stats.proto) from
     * /proc/pid/status and oom_score_adj every X ms.
     * It will also sample /proc/pid/smaps_rollup if scan_smaps_rollup = true.
     * This is required to be &gt; 100ms to avoid excessive CPU usage.
     * </pre>
     *
     * <code>optional uint32 proc_stats_poll_ms = 4;</code>
     * @return The procStatsPollMs.
     */
    @java.lang.Override
    public int getProcStatsPollMs() {
      return procStatsPollMs_;
    }

    public static final int PROC_STATS_CACHE_TTL_MS_FIELD_NUMBER = 6;
    private int procStatsCacheTtlMs_ = 0;
    /**
     * <pre>
     * This is required to be either = 0 or a multiple of |proc_stats_poll_ms|
     * (default: |proc_stats_poll_ms|). If = 0, will be set to
     * |proc_stats_poll_ms|. Non-multiples will be rounded down to the nearest
     * multiple.
     * </pre>
     *
     * <code>optional uint32 proc_stats_cache_ttl_ms = 6;</code>
     * @return Whether the procStatsCacheTtlMs field is set.
     */
    @java.lang.Override
    public boolean hasProcStatsCacheTtlMs() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * This is required to be either = 0 or a multiple of |proc_stats_poll_ms|
     * (default: |proc_stats_poll_ms|). If = 0, will be set to
     * |proc_stats_poll_ms|. Non-multiples will be rounded down to the nearest
     * multiple.
     * </pre>
     *
     * <code>optional uint32 proc_stats_cache_ttl_ms = 6;</code>
     * @return The procStatsCacheTtlMs.
     */
    @java.lang.Override
    public int getProcStatsCacheTtlMs() {
      return procStatsCacheTtlMs_;
    }

    public static final int RESOLVE_PROCESS_FDS_FIELD_NUMBER = 9;
    private boolean resolveProcessFds_ = false;
    /**
     * <pre>
     * Niche feature: If true this will resolve file descriptors for each process
     * so these can be mapped to their actual device or file.
     * Requires raw_syscalls/sys_{enter,exit} ftrace events to be enabled or
     * new fds opened after initially scanning a process will not be
     * recognized.
     * </pre>
     *
     * <code>optional bool resolve_process_fds = 9;</code>
     * @return Whether the resolveProcessFds field is set.
     */
    @java.lang.Override
    public boolean hasResolveProcessFds() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * Niche feature: If true this will resolve file descriptors for each process
     * so these can be mapped to their actual device or file.
     * Requires raw_syscalls/sys_{enter,exit} ftrace events to be enabled or
     * new fds opened after initially scanning a process will not be
     * recognized.
     * </pre>
     *
     * <code>optional bool resolve_process_fds = 9;</code>
     * @return The resolveProcessFds.
     */
    @java.lang.Override
    public boolean getResolveProcessFds() {
      return resolveProcessFds_;
    }

    public static final int SCAN_SMAPS_ROLLUP_FIELD_NUMBER = 10;
    private boolean scanSmapsRollup_ = false;
    /**
     * <pre>
     * If true, output will include memory stats from /proc/pid/smaps_rollup.
     * </pre>
     *
     * <code>optional bool scan_smaps_rollup = 10;</code>
     * @return Whether the scanSmapsRollup field is set.
     */
    @java.lang.Override
    public boolean hasScanSmapsRollup() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * If true, output will include memory stats from /proc/pid/smaps_rollup.
     * </pre>
     *
     * <code>optional bool scan_smaps_rollup = 10;</code>
     * @return The scanSmapsRollup.
     */
    @java.lang.Override
    public boolean getScanSmapsRollup() {
      return scanSmapsRollup_;
    }

    public static final int RECORD_PROCESS_AGE_FIELD_NUMBER = 11;
    private boolean recordProcessAge_ = false;
    /**
     * <pre>
     * If true: process descriptions will include process age (starttime in
     * /proc/pid/stat).
     * Introduced in: perfetto v44.
     * </pre>
     *
     * <code>optional bool record_process_age = 11;</code>
     * @return Whether the recordProcessAge field is set.
     */
    @java.lang.Override
    public boolean hasRecordProcessAge() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <pre>
     * If true: process descriptions will include process age (starttime in
     * /proc/pid/stat).
     * Introduced in: perfetto v44.
     * </pre>
     *
     * <code>optional bool record_process_age = 11;</code>
     * @return The recordProcessAge.
     */
    @java.lang.Override
    public boolean getRecordProcessAge() {
      return recordProcessAge_;
    }

    public static final int RECORD_PROCESS_RUNTIME_FIELD_NUMBER = 12;
    private boolean recordProcessRuntime_ = false;
    /**
     * <pre>
     * If true and |proc_stats_poll_ms| is true, process stats will include time
     * spent running in user/kernel mode (utime/stime in /proc/pid/stat).
     * Introduced in: perfetto v44.
     * </pre>
     *
     * <code>optional bool record_process_runtime = 12;</code>
     * @return Whether the recordProcessRuntime field is set.
     */
    @java.lang.Override
    public boolean hasRecordProcessRuntime() {
      return ((bitField0_ & 0x00000080) != 0);
    }
    /**
     * <pre>
     * If true and |proc_stats_poll_ms| is true, process stats will include time
     * spent running in user/kernel mode (utime/stime in /proc/pid/stat).
     * Introduced in: perfetto v44.
     * </pre>
     *
     * <code>optional bool record_process_runtime = 12;</code>
     * @return The recordProcessRuntime.
     */
    @java.lang.Override
    public boolean getRecordProcessRuntime() {
      return recordProcessRuntime_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < quirks_.size(); i++) {
        output.writeEnum(1, quirks_.getInt(i));
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeBool(2, scanAllProcessesOnStart_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeBool(3, recordThreadNames_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeUInt32(4, procStatsPollMs_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        output.writeUInt32(6, procStatsCacheTtlMs_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        output.writeBool(9, resolveProcessFds_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        output.writeBool(10, scanSmapsRollup_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        output.writeBool(11, recordProcessAge_);
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        output.writeBool(12, recordProcessRuntime_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      {
        int dataSize = 0;
        for (int i = 0; i < quirks_.size(); i++) {
          dataSize += com.google.protobuf.CodedOutputStream
            .computeEnumSizeNoTag(quirks_.getInt(i));
        }
        size += dataSize;
        size += 1 * quirks_.size();
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(2, scanAllProcessesOnStart_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(3, recordThreadNames_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(4, procStatsPollMs_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(6, procStatsCacheTtlMs_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(9, resolveProcessFds_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(10, scanSmapsRollup_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(11, recordProcessAge_);
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(12, recordProcessRuntime_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof perfetto.protos.ProcessStatsConfigOuterClass.ProcessStatsConfig)) {
        return super.equals(obj);
      }
      perfetto.protos.ProcessStatsConfigOuterClass.ProcessStatsConfig other = (perfetto.protos.ProcessStatsConfigOuterClass.ProcessStatsConfig) obj;

      if (!quirks_.equals(other.quirks_)) return false;
      if (hasScanAllProcessesOnStart() != other.hasScanAllProcessesOnStart()) return false;
      if (hasScanAllProcessesOnStart()) {
        if (getScanAllProcessesOnStart()
            != other.getScanAllProcessesOnStart()) return false;
      }
      if (hasRecordThreadNames() != other.hasRecordThreadNames()) return false;
      if (hasRecordThreadNames()) {
        if (getRecordThreadNames()
            != other.getRecordThreadNames()) return false;
      }
      if (hasProcStatsPollMs() != other.hasProcStatsPollMs()) return false;
      if (hasProcStatsPollMs()) {
        if (getProcStatsPollMs()
            != other.getProcStatsPollMs()) return false;
      }
      if (hasProcStatsCacheTtlMs() != other.hasProcStatsCacheTtlMs()) return false;
      if (hasProcStatsCacheTtlMs()) {
        if (getProcStatsCacheTtlMs()
            != other.getProcStatsCacheTtlMs()) return false;
      }
      if (hasResolveProcessFds() != other.hasResolveProcessFds()) return false;
      if (hasResolveProcessFds()) {
        if (getResolveProcessFds()
            != other.getResolveProcessFds()) return false;
      }
      if (hasScanSmapsRollup() != other.hasScanSmapsRollup()) return false;
      if (hasScanSmapsRollup()) {
        if (getScanSmapsRollup()
            != other.getScanSmapsRollup()) return false;
      }
      if (hasRecordProcessAge() != other.hasRecordProcessAge()) return false;
      if (hasRecordProcessAge()) {
        if (getRecordProcessAge()
            != other.getRecordProcessAge()) return false;
      }
      if (hasRecordProcessRuntime() != other.hasRecordProcessRuntime()) return false;
      if (hasRecordProcessRuntime()) {
        if (getRecordProcessRuntime()
            != other.getRecordProcessRuntime()) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getQuirksCount() > 0) {
        hash = (37 * hash) + QUIRKS_FIELD_NUMBER;
        hash = (53 * hash) + quirks_.hashCode();
      }
      if (hasScanAllProcessesOnStart()) {
        hash = (37 * hash) + SCAN_ALL_PROCESSES_ON_START_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getScanAllProcessesOnStart());
      }
      if (hasRecordThreadNames()) {
        hash = (37 * hash) + RECORD_THREAD_NAMES_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getRecordThreadNames());
      }
      if (hasProcStatsPollMs()) {
        hash = (37 * hash) + PROC_STATS_POLL_MS_FIELD_NUMBER;
        hash = (53 * hash) + getProcStatsPollMs();
      }
      if (hasProcStatsCacheTtlMs()) {
        hash = (37 * hash) + PROC_STATS_CACHE_TTL_MS_FIELD_NUMBER;
        hash = (53 * hash) + getProcStatsCacheTtlMs();
      }
      if (hasResolveProcessFds()) {
        hash = (37 * hash) + RESOLVE_PROCESS_FDS_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getResolveProcessFds());
      }
      if (hasScanSmapsRollup()) {
        hash = (37 * hash) + SCAN_SMAPS_ROLLUP_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getScanSmapsRollup());
      }
      if (hasRecordProcessAge()) {
        hash = (37 * hash) + RECORD_PROCESS_AGE_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getRecordProcessAge());
      }
      if (hasRecordProcessRuntime()) {
        hash = (37 * hash) + RECORD_PROCESS_RUNTIME_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getRecordProcessRuntime());
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static perfetto.protos.ProcessStatsConfigOuterClass.ProcessStatsConfig parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static perfetto.protos.ProcessStatsConfigOuterClass.ProcessStatsConfig parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static perfetto.protos.ProcessStatsConfigOuterClass.ProcessStatsConfig parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static perfetto.protos.ProcessStatsConfigOuterClass.ProcessStatsConfig parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static perfetto.protos.ProcessStatsConfigOuterClass.ProcessStatsConfig parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static perfetto.protos.ProcessStatsConfigOuterClass.ProcessStatsConfig parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static perfetto.protos.ProcessStatsConfigOuterClass.ProcessStatsConfig parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static perfetto.protos.ProcessStatsConfigOuterClass.ProcessStatsConfig parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static perfetto.protos.ProcessStatsConfigOuterClass.ProcessStatsConfig parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static perfetto.protos.ProcessStatsConfigOuterClass.ProcessStatsConfig parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static perfetto.protos.ProcessStatsConfigOuterClass.ProcessStatsConfig parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static perfetto.protos.ProcessStatsConfigOuterClass.ProcessStatsConfig parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(perfetto.protos.ProcessStatsConfigOuterClass.ProcessStatsConfig prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code perfetto.protos.ProcessStatsConfig}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:perfetto.protos.ProcessStatsConfig)
        perfetto.protos.ProcessStatsConfigOuterClass.ProcessStatsConfigOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return perfetto.protos.ProcessStatsConfigOuterClass.internal_static_perfetto_protos_ProcessStatsConfig_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return perfetto.protos.ProcessStatsConfigOuterClass.internal_static_perfetto_protos_ProcessStatsConfig_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                perfetto.protos.ProcessStatsConfigOuterClass.ProcessStatsConfig.class, perfetto.protos.ProcessStatsConfigOuterClass.ProcessStatsConfig.Builder.class);
      }

      // Construct using perfetto.protos.ProcessStatsConfigOuterClass.ProcessStatsConfig.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        quirks_ = emptyIntList();
        bitField0_ = (bitField0_ & ~0x00000001);
        scanAllProcessesOnStart_ = false;
        recordThreadNames_ = false;
        procStatsPollMs_ = 0;
        procStatsCacheTtlMs_ = 0;
        resolveProcessFds_ = false;
        scanSmapsRollup_ = false;
        recordProcessAge_ = false;
        recordProcessRuntime_ = false;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return perfetto.protos.ProcessStatsConfigOuterClass.internal_static_perfetto_protos_ProcessStatsConfig_descriptor;
      }

      @java.lang.Override
      public perfetto.protos.ProcessStatsConfigOuterClass.ProcessStatsConfig getDefaultInstanceForType() {
        return perfetto.protos.ProcessStatsConfigOuterClass.ProcessStatsConfig.getDefaultInstance();
      }

      @java.lang.Override
      public perfetto.protos.ProcessStatsConfigOuterClass.ProcessStatsConfig build() {
        perfetto.protos.ProcessStatsConfigOuterClass.ProcessStatsConfig result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public perfetto.protos.ProcessStatsConfigOuterClass.ProcessStatsConfig buildPartial() {
        perfetto.protos.ProcessStatsConfigOuterClass.ProcessStatsConfig result = new perfetto.protos.ProcessStatsConfigOuterClass.ProcessStatsConfig(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(perfetto.protos.ProcessStatsConfigOuterClass.ProcessStatsConfig result) {
        if (((bitField0_ & 0x00000001) != 0)) {
          quirks_.makeImmutable();
          bitField0_ = (bitField0_ & ~0x00000001);
        }
        result.quirks_ = quirks_;
      }

      private void buildPartial0(perfetto.protos.ProcessStatsConfigOuterClass.ProcessStatsConfig result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.scanAllProcessesOnStart_ = scanAllProcessesOnStart_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.recordThreadNames_ = recordThreadNames_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.procStatsPollMs_ = procStatsPollMs_;
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.procStatsCacheTtlMs_ = procStatsCacheTtlMs_;
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          result.resolveProcessFds_ = resolveProcessFds_;
          to_bitField0_ |= 0x00000010;
        }
        if (((from_bitField0_ & 0x00000040) != 0)) {
          result.scanSmapsRollup_ = scanSmapsRollup_;
          to_bitField0_ |= 0x00000020;
        }
        if (((from_bitField0_ & 0x00000080) != 0)) {
          result.recordProcessAge_ = recordProcessAge_;
          to_bitField0_ |= 0x00000040;
        }
        if (((from_bitField0_ & 0x00000100) != 0)) {
          result.recordProcessRuntime_ = recordProcessRuntime_;
          to_bitField0_ |= 0x00000080;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof perfetto.protos.ProcessStatsConfigOuterClass.ProcessStatsConfig) {
          return mergeFrom((perfetto.protos.ProcessStatsConfigOuterClass.ProcessStatsConfig)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(perfetto.protos.ProcessStatsConfigOuterClass.ProcessStatsConfig other) {
        if (other == perfetto.protos.ProcessStatsConfigOuterClass.ProcessStatsConfig.getDefaultInstance()) return this;
        if (!other.quirks_.isEmpty()) {
          if (quirks_.isEmpty()) {
            quirks_ = other.quirks_;
            bitField0_ = (bitField0_ & ~0x00000001);
          } else {
            ensureQuirksIsMutable();
            quirks_.addAll(other.quirks_);
          }
          onChanged();
        }
        if (other.hasScanAllProcessesOnStart()) {
          setScanAllProcessesOnStart(other.getScanAllProcessesOnStart());
        }
        if (other.hasRecordThreadNames()) {
          setRecordThreadNames(other.getRecordThreadNames());
        }
        if (other.hasProcStatsPollMs()) {
          setProcStatsPollMs(other.getProcStatsPollMs());
        }
        if (other.hasProcStatsCacheTtlMs()) {
          setProcStatsCacheTtlMs(other.getProcStatsCacheTtlMs());
        }
        if (other.hasResolveProcessFds()) {
          setResolveProcessFds(other.getResolveProcessFds());
        }
        if (other.hasScanSmapsRollup()) {
          setScanSmapsRollup(other.getScanSmapsRollup());
        }
        if (other.hasRecordProcessAge()) {
          setRecordProcessAge(other.getRecordProcessAge());
        }
        if (other.hasRecordProcessRuntime()) {
          setRecordProcessRuntime(other.getRecordProcessRuntime());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                int tmpRaw = input.readEnum();
                perfetto.protos.ProcessStatsConfigOuterClass.ProcessStatsConfig.Quirks tmpValue =
                    perfetto.protos.ProcessStatsConfigOuterClass.ProcessStatsConfig.Quirks.forNumber(tmpRaw);
                if (tmpValue == null) {
                  mergeUnknownVarintField(1, tmpRaw);
                } else {
                  ensureQuirksIsMutable();
                  quirks_.addInt(tmpRaw);
                }
                break;
              } // case 8
              case 10: {
                int length = input.readRawVarint32();
                int oldLimit = input.pushLimit(length);
                while(input.getBytesUntilLimit() > 0) {
                  int tmpRaw = input.readEnum();
                  perfetto.protos.ProcessStatsConfigOuterClass.ProcessStatsConfig.Quirks tmpValue =
                      perfetto.protos.ProcessStatsConfigOuterClass.ProcessStatsConfig.Quirks.forNumber(tmpRaw);
                  if (tmpValue == null) {
                    mergeUnknownVarintField(1, tmpRaw);
                  } else {
                    ensureQuirksIsMutable();
                    quirks_.addInt(tmpRaw);
                  }
                }
                input.popLimit(oldLimit);
                break;
              } // case 10
              case 16: {
                scanAllProcessesOnStart_ = input.readBool();
                bitField0_ |= 0x00000002;
                break;
              } // case 16
              case 24: {
                recordThreadNames_ = input.readBool();
                bitField0_ |= 0x00000004;
                break;
              } // case 24
              case 32: {
                procStatsPollMs_ = input.readUInt32();
                bitField0_ |= 0x00000008;
                break;
              } // case 32
              case 48: {
                procStatsCacheTtlMs_ = input.readUInt32();
                bitField0_ |= 0x00000010;
                break;
              } // case 48
              case 72: {
                resolveProcessFds_ = input.readBool();
                bitField0_ |= 0x00000020;
                break;
              } // case 72
              case 80: {
                scanSmapsRollup_ = input.readBool();
                bitField0_ |= 0x00000040;
                break;
              } // case 80
              case 88: {
                recordProcessAge_ = input.readBool();
                bitField0_ |= 0x00000080;
                break;
              } // case 88
              case 96: {
                recordProcessRuntime_ = input.readBool();
                bitField0_ |= 0x00000100;
                break;
              } // case 96
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private com.google.protobuf.Internal.IntList quirks_ =
        emptyIntList();
      private void ensureQuirksIsMutable() {
        if (!((bitField0_ & 0x00000001) != 0)) {
          quirks_ = makeMutableCopy(quirks_);
          bitField0_ |= 0x00000001;
        }
      }
      /**
       * <code>repeated .perfetto.protos.ProcessStatsConfig.Quirks quirks = 1;</code>
       * @return A list containing the quirks.
       */
      public java.util.List<perfetto.protos.ProcessStatsConfigOuterClass.ProcessStatsConfig.Quirks> getQuirksList() {
        return new com.google.protobuf.Internal.IntListAdapter<
            perfetto.protos.ProcessStatsConfigOuterClass.ProcessStatsConfig.Quirks>(quirks_, quirks_converter_);
      }
      /**
       * <code>repeated .perfetto.protos.ProcessStatsConfig.Quirks quirks = 1;</code>
       * @return The count of quirks.
       */
      public int getQuirksCount() {
        return quirks_.size();
      }
      /**
       * <code>repeated .perfetto.protos.ProcessStatsConfig.Quirks quirks = 1;</code>
       * @param index The index of the element to return.
       * @return The quirks at the given index.
       */
      public perfetto.protos.ProcessStatsConfigOuterClass.ProcessStatsConfig.Quirks getQuirks(int index) {
        return quirks_converter_.convert(quirks_.getInt(index));
      }
      /**
       * <code>repeated .perfetto.protos.ProcessStatsConfig.Quirks quirks = 1;</code>
       * @param index The index to set the value at.
       * @param value The quirks to set.
       * @return This builder for chaining.
       */
      public Builder setQuirks(
          int index, perfetto.protos.ProcessStatsConfigOuterClass.ProcessStatsConfig.Quirks value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureQuirksIsMutable();
        quirks_.setInt(index, value.getNumber());
        onChanged();
        return this;
      }
      /**
       * <code>repeated .perfetto.protos.ProcessStatsConfig.Quirks quirks = 1;</code>
       * @param value The quirks to add.
       * @return This builder for chaining.
       */
      public Builder addQuirks(perfetto.protos.ProcessStatsConfigOuterClass.ProcessStatsConfig.Quirks value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureQuirksIsMutable();
        quirks_.addInt(value.getNumber());
        onChanged();
        return this;
      }
      /**
       * <code>repeated .perfetto.protos.ProcessStatsConfig.Quirks quirks = 1;</code>
       * @param values The quirks to add.
       * @return This builder for chaining.
       */
      public Builder addAllQuirks(
          java.lang.Iterable<? extends perfetto.protos.ProcessStatsConfigOuterClass.ProcessStatsConfig.Quirks> values) {
        ensureQuirksIsMutable();
        for (perfetto.protos.ProcessStatsConfigOuterClass.ProcessStatsConfig.Quirks value : values) {
          quirks_.addInt(value.getNumber());
        }
        onChanged();
        return this;
      }
      /**
       * <code>repeated .perfetto.protos.ProcessStatsConfig.Quirks quirks = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearQuirks() {
        quirks_ = emptyIntList();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }

      private boolean scanAllProcessesOnStart_ ;
      /**
       * <pre>
       * If enabled all processes will be scanned and dumped when the trace starts.
       * </pre>
       *
       * <code>optional bool scan_all_processes_on_start = 2;</code>
       * @return Whether the scanAllProcessesOnStart field is set.
       */
      @java.lang.Override
      public boolean hasScanAllProcessesOnStart() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * If enabled all processes will be scanned and dumped when the trace starts.
       * </pre>
       *
       * <code>optional bool scan_all_processes_on_start = 2;</code>
       * @return The scanAllProcessesOnStart.
       */
      @java.lang.Override
      public boolean getScanAllProcessesOnStart() {
        return scanAllProcessesOnStart_;
      }
      /**
       * <pre>
       * If enabled all processes will be scanned and dumped when the trace starts.
       * </pre>
       *
       * <code>optional bool scan_all_processes_on_start = 2;</code>
       * @param value The scanAllProcessesOnStart to set.
       * @return This builder for chaining.
       */
      public Builder setScanAllProcessesOnStart(boolean value) {

        scanAllProcessesOnStart_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If enabled all processes will be scanned and dumped when the trace starts.
       * </pre>
       *
       * <code>optional bool scan_all_processes_on_start = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearScanAllProcessesOnStart() {
        bitField0_ = (bitField0_ & ~0x00000002);
        scanAllProcessesOnStart_ = false;
        onChanged();
        return this;
      }

      private boolean recordThreadNames_ ;
      /**
       * <pre>
       * If enabled thread names are also recoded (this is redundant if sched_switch
       * is enabled).
       * </pre>
       *
       * <code>optional bool record_thread_names = 3;</code>
       * @return Whether the recordThreadNames field is set.
       */
      @java.lang.Override
      public boolean hasRecordThreadNames() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * If enabled thread names are also recoded (this is redundant if sched_switch
       * is enabled).
       * </pre>
       *
       * <code>optional bool record_thread_names = 3;</code>
       * @return The recordThreadNames.
       */
      @java.lang.Override
      public boolean getRecordThreadNames() {
        return recordThreadNames_;
      }
      /**
       * <pre>
       * If enabled thread names are also recoded (this is redundant if sched_switch
       * is enabled).
       * </pre>
       *
       * <code>optional bool record_thread_names = 3;</code>
       * @param value The recordThreadNames to set.
       * @return This builder for chaining.
       */
      public Builder setRecordThreadNames(boolean value) {

        recordThreadNames_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If enabled thread names are also recoded (this is redundant if sched_switch
       * is enabled).
       * </pre>
       *
       * <code>optional bool record_thread_names = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearRecordThreadNames() {
        bitField0_ = (bitField0_ & ~0x00000004);
        recordThreadNames_ = false;
        onChanged();
        return this;
      }

      private int procStatsPollMs_ ;
      /**
       * <pre>
       * If &gt; 0 samples counters (see process_stats.proto) from
       * /proc/pid/status and oom_score_adj every X ms.
       * It will also sample /proc/pid/smaps_rollup if scan_smaps_rollup = true.
       * This is required to be &gt; 100ms to avoid excessive CPU usage.
       * </pre>
       *
       * <code>optional uint32 proc_stats_poll_ms = 4;</code>
       * @return Whether the procStatsPollMs field is set.
       */
      @java.lang.Override
      public boolean hasProcStatsPollMs() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * If &gt; 0 samples counters (see process_stats.proto) from
       * /proc/pid/status and oom_score_adj every X ms.
       * It will also sample /proc/pid/smaps_rollup if scan_smaps_rollup = true.
       * This is required to be &gt; 100ms to avoid excessive CPU usage.
       * </pre>
       *
       * <code>optional uint32 proc_stats_poll_ms = 4;</code>
       * @return The procStatsPollMs.
       */
      @java.lang.Override
      public int getProcStatsPollMs() {
        return procStatsPollMs_;
      }
      /**
       * <pre>
       * If &gt; 0 samples counters (see process_stats.proto) from
       * /proc/pid/status and oom_score_adj every X ms.
       * It will also sample /proc/pid/smaps_rollup if scan_smaps_rollup = true.
       * This is required to be &gt; 100ms to avoid excessive CPU usage.
       * </pre>
       *
       * <code>optional uint32 proc_stats_poll_ms = 4;</code>
       * @param value The procStatsPollMs to set.
       * @return This builder for chaining.
       */
      public Builder setProcStatsPollMs(int value) {

        procStatsPollMs_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If &gt; 0 samples counters (see process_stats.proto) from
       * /proc/pid/status and oom_score_adj every X ms.
       * It will also sample /proc/pid/smaps_rollup if scan_smaps_rollup = true.
       * This is required to be &gt; 100ms to avoid excessive CPU usage.
       * </pre>
       *
       * <code>optional uint32 proc_stats_poll_ms = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearProcStatsPollMs() {
        bitField0_ = (bitField0_ & ~0x00000008);
        procStatsPollMs_ = 0;
        onChanged();
        return this;
      }

      private int procStatsCacheTtlMs_ ;
      /**
       * <pre>
       * This is required to be either = 0 or a multiple of |proc_stats_poll_ms|
       * (default: |proc_stats_poll_ms|). If = 0, will be set to
       * |proc_stats_poll_ms|. Non-multiples will be rounded down to the nearest
       * multiple.
       * </pre>
       *
       * <code>optional uint32 proc_stats_cache_ttl_ms = 6;</code>
       * @return Whether the procStatsCacheTtlMs field is set.
       */
      @java.lang.Override
      public boolean hasProcStatsCacheTtlMs() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * This is required to be either = 0 or a multiple of |proc_stats_poll_ms|
       * (default: |proc_stats_poll_ms|). If = 0, will be set to
       * |proc_stats_poll_ms|. Non-multiples will be rounded down to the nearest
       * multiple.
       * </pre>
       *
       * <code>optional uint32 proc_stats_cache_ttl_ms = 6;</code>
       * @return The procStatsCacheTtlMs.
       */
      @java.lang.Override
      public int getProcStatsCacheTtlMs() {
        return procStatsCacheTtlMs_;
      }
      /**
       * <pre>
       * This is required to be either = 0 or a multiple of |proc_stats_poll_ms|
       * (default: |proc_stats_poll_ms|). If = 0, will be set to
       * |proc_stats_poll_ms|. Non-multiples will be rounded down to the nearest
       * multiple.
       * </pre>
       *
       * <code>optional uint32 proc_stats_cache_ttl_ms = 6;</code>
       * @param value The procStatsCacheTtlMs to set.
       * @return This builder for chaining.
       */
      public Builder setProcStatsCacheTtlMs(int value) {

        procStatsCacheTtlMs_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * This is required to be either = 0 or a multiple of |proc_stats_poll_ms|
       * (default: |proc_stats_poll_ms|). If = 0, will be set to
       * |proc_stats_poll_ms|. Non-multiples will be rounded down to the nearest
       * multiple.
       * </pre>
       *
       * <code>optional uint32 proc_stats_cache_ttl_ms = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearProcStatsCacheTtlMs() {
        bitField0_ = (bitField0_ & ~0x00000010);
        procStatsCacheTtlMs_ = 0;
        onChanged();
        return this;
      }

      private boolean resolveProcessFds_ ;
      /**
       * <pre>
       * Niche feature: If true this will resolve file descriptors for each process
       * so these can be mapped to their actual device or file.
       * Requires raw_syscalls/sys_{enter,exit} ftrace events to be enabled or
       * new fds opened after initially scanning a process will not be
       * recognized.
       * </pre>
       *
       * <code>optional bool resolve_process_fds = 9;</code>
       * @return Whether the resolveProcessFds field is set.
       */
      @java.lang.Override
      public boolean hasResolveProcessFds() {
        return ((bitField0_ & 0x00000020) != 0);
      }
      /**
       * <pre>
       * Niche feature: If true this will resolve file descriptors for each process
       * so these can be mapped to their actual device or file.
       * Requires raw_syscalls/sys_{enter,exit} ftrace events to be enabled or
       * new fds opened after initially scanning a process will not be
       * recognized.
       * </pre>
       *
       * <code>optional bool resolve_process_fds = 9;</code>
       * @return The resolveProcessFds.
       */
      @java.lang.Override
      public boolean getResolveProcessFds() {
        return resolveProcessFds_;
      }
      /**
       * <pre>
       * Niche feature: If true this will resolve file descriptors for each process
       * so these can be mapped to their actual device or file.
       * Requires raw_syscalls/sys_{enter,exit} ftrace events to be enabled or
       * new fds opened after initially scanning a process will not be
       * recognized.
       * </pre>
       *
       * <code>optional bool resolve_process_fds = 9;</code>
       * @param value The resolveProcessFds to set.
       * @return This builder for chaining.
       */
      public Builder setResolveProcessFds(boolean value) {

        resolveProcessFds_ = value;
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Niche feature: If true this will resolve file descriptors for each process
       * so these can be mapped to their actual device or file.
       * Requires raw_syscalls/sys_{enter,exit} ftrace events to be enabled or
       * new fds opened after initially scanning a process will not be
       * recognized.
       * </pre>
       *
       * <code>optional bool resolve_process_fds = 9;</code>
       * @return This builder for chaining.
       */
      public Builder clearResolveProcessFds() {
        bitField0_ = (bitField0_ & ~0x00000020);
        resolveProcessFds_ = false;
        onChanged();
        return this;
      }

      private boolean scanSmapsRollup_ ;
      /**
       * <pre>
       * If true, output will include memory stats from /proc/pid/smaps_rollup.
       * </pre>
       *
       * <code>optional bool scan_smaps_rollup = 10;</code>
       * @return Whether the scanSmapsRollup field is set.
       */
      @java.lang.Override
      public boolean hasScanSmapsRollup() {
        return ((bitField0_ & 0x00000040) != 0);
      }
      /**
       * <pre>
       * If true, output will include memory stats from /proc/pid/smaps_rollup.
       * </pre>
       *
       * <code>optional bool scan_smaps_rollup = 10;</code>
       * @return The scanSmapsRollup.
       */
      @java.lang.Override
      public boolean getScanSmapsRollup() {
        return scanSmapsRollup_;
      }
      /**
       * <pre>
       * If true, output will include memory stats from /proc/pid/smaps_rollup.
       * </pre>
       *
       * <code>optional bool scan_smaps_rollup = 10;</code>
       * @param value The scanSmapsRollup to set.
       * @return This builder for chaining.
       */
      public Builder setScanSmapsRollup(boolean value) {

        scanSmapsRollup_ = value;
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If true, output will include memory stats from /proc/pid/smaps_rollup.
       * </pre>
       *
       * <code>optional bool scan_smaps_rollup = 10;</code>
       * @return This builder for chaining.
       */
      public Builder clearScanSmapsRollup() {
        bitField0_ = (bitField0_ & ~0x00000040);
        scanSmapsRollup_ = false;
        onChanged();
        return this;
      }

      private boolean recordProcessAge_ ;
      /**
       * <pre>
       * If true: process descriptions will include process age (starttime in
       * /proc/pid/stat).
       * Introduced in: perfetto v44.
       * </pre>
       *
       * <code>optional bool record_process_age = 11;</code>
       * @return Whether the recordProcessAge field is set.
       */
      @java.lang.Override
      public boolean hasRecordProcessAge() {
        return ((bitField0_ & 0x00000080) != 0);
      }
      /**
       * <pre>
       * If true: process descriptions will include process age (starttime in
       * /proc/pid/stat).
       * Introduced in: perfetto v44.
       * </pre>
       *
       * <code>optional bool record_process_age = 11;</code>
       * @return The recordProcessAge.
       */
      @java.lang.Override
      public boolean getRecordProcessAge() {
        return recordProcessAge_;
      }
      /**
       * <pre>
       * If true: process descriptions will include process age (starttime in
       * /proc/pid/stat).
       * Introduced in: perfetto v44.
       * </pre>
       *
       * <code>optional bool record_process_age = 11;</code>
       * @param value The recordProcessAge to set.
       * @return This builder for chaining.
       */
      public Builder setRecordProcessAge(boolean value) {

        recordProcessAge_ = value;
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If true: process descriptions will include process age (starttime in
       * /proc/pid/stat).
       * Introduced in: perfetto v44.
       * </pre>
       *
       * <code>optional bool record_process_age = 11;</code>
       * @return This builder for chaining.
       */
      public Builder clearRecordProcessAge() {
        bitField0_ = (bitField0_ & ~0x00000080);
        recordProcessAge_ = false;
        onChanged();
        return this;
      }

      private boolean recordProcessRuntime_ ;
      /**
       * <pre>
       * If true and |proc_stats_poll_ms| is true, process stats will include time
       * spent running in user/kernel mode (utime/stime in /proc/pid/stat).
       * Introduced in: perfetto v44.
       * </pre>
       *
       * <code>optional bool record_process_runtime = 12;</code>
       * @return Whether the recordProcessRuntime field is set.
       */
      @java.lang.Override
      public boolean hasRecordProcessRuntime() {
        return ((bitField0_ & 0x00000100) != 0);
      }
      /**
       * <pre>
       * If true and |proc_stats_poll_ms| is true, process stats will include time
       * spent running in user/kernel mode (utime/stime in /proc/pid/stat).
       * Introduced in: perfetto v44.
       * </pre>
       *
       * <code>optional bool record_process_runtime = 12;</code>
       * @return The recordProcessRuntime.
       */
      @java.lang.Override
      public boolean getRecordProcessRuntime() {
        return recordProcessRuntime_;
      }
      /**
       * <pre>
       * If true and |proc_stats_poll_ms| is true, process stats will include time
       * spent running in user/kernel mode (utime/stime in /proc/pid/stat).
       * Introduced in: perfetto v44.
       * </pre>
       *
       * <code>optional bool record_process_runtime = 12;</code>
       * @param value The recordProcessRuntime to set.
       * @return This builder for chaining.
       */
      public Builder setRecordProcessRuntime(boolean value) {

        recordProcessRuntime_ = value;
        bitField0_ |= 0x00000100;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If true and |proc_stats_poll_ms| is true, process stats will include time
       * spent running in user/kernel mode (utime/stime in /proc/pid/stat).
       * Introduced in: perfetto v44.
       * </pre>
       *
       * <code>optional bool record_process_runtime = 12;</code>
       * @return This builder for chaining.
       */
      public Builder clearRecordProcessRuntime() {
        bitField0_ = (bitField0_ & ~0x00000100);
        recordProcessRuntime_ = false;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:perfetto.protos.ProcessStatsConfig)
    }

    // @@protoc_insertion_point(class_scope:perfetto.protos.ProcessStatsConfig)
    private static final perfetto.protos.ProcessStatsConfigOuterClass.ProcessStatsConfig DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new perfetto.protos.ProcessStatsConfigOuterClass.ProcessStatsConfig();
    }

    public static perfetto.protos.ProcessStatsConfigOuterClass.ProcessStatsConfig getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ProcessStatsConfig>
        PARSER = new com.google.protobuf.AbstractParser<ProcessStatsConfig>() {
      @java.lang.Override
      public ProcessStatsConfig parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<ProcessStatsConfig> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ProcessStatsConfig> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public perfetto.protos.ProcessStatsConfigOuterClass.ProcessStatsConfig getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_perfetto_protos_ProcessStatsConfig_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_perfetto_protos_ProcessStatsConfig_fieldAccessorTable;

  public static com.google.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
    return descriptor;
  }
  private static  com.google.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
    java.lang.String[] descriptorData = {
      "\n?protos/perfetto/config/process_stats/p" +
      "rocess_stats_config.proto\022\017perfetto.prot" +
      "os\"\246\003\n\022ProcessStatsConfig\022:\n\006quirks\030\001 \003(" +
      "\0162*.perfetto.protos.ProcessStatsConfig.Q" +
      "uirks\022#\n\033scan_all_processes_on_start\030\002 \001" +
      "(\010\022\033\n\023record_thread_names\030\003 \001(\010\022\032\n\022proc_" +
      "stats_poll_ms\030\004 \001(\r\022\037\n\027proc_stats_cache_" +
      "ttl_ms\030\006 \001(\r\022\033\n\023resolve_process_fds\030\t \001(" +
      "\010\022\031\n\021scan_smaps_rollup\030\n \001(\010\022\032\n\022record_p" +
      "rocess_age\030\013 \001(\010\022\036\n\026record_process_runti" +
      "me\030\014 \001(\010\"U\n\006Quirks\022\026\n\022QUIRKS_UNSPECIFIED" +
      "\020\000\022\034\n\024DISABLE_INITIAL_DUMP\020\001\032\002\010\001\022\025\n\021DISA" +
      "BLE_ON_DEMAND\020\002J\004\010\007\020\010J\004\010\010\020\t"
    };
    descriptor = com.google.protobuf.Descriptors.FileDescriptor
      .internalBuildGeneratedFileFrom(descriptorData,
        new com.google.protobuf.Descriptors.FileDescriptor[] {
        });
    internal_static_perfetto_protos_ProcessStatsConfig_descriptor =
      getDescriptor().getMessageTypes().get(0);
    internal_static_perfetto_protos_ProcessStatsConfig_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_perfetto_protos_ProcessStatsConfig_descriptor,
        new java.lang.String[] { "Quirks", "ScanAllProcessesOnStart", "RecordThreadNames", "ProcStatsPollMs", "ProcStatsCacheTtlMs", "ResolveProcessFds", "ScanSmapsRollup", "RecordProcessAge", "RecordProcessRuntime", });
    descriptor.resolveAllFeaturesImmutable();
  }

  // @@protoc_insertion_point(outer_class_scope)
}
