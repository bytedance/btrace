// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/common/sys_stats_counters.proto

package perfetto.protos;

public final class SysStatsCounters {
  private SysStatsCounters() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }

  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistry registry) {
    registerAllExtensions(
        (com.google.protobuf.ExtensionRegistryLite) registry);
  }
  /**
   * <pre>
   * Counter definitions for Linux's /proc/meminfo.
   * </pre>
   *
   * Protobuf enum {@code perfetto.protos.MeminfoCounters}
   */
  public enum MeminfoCounters
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>MEMINFO_UNSPECIFIED = 0;</code>
     */
    MEMINFO_UNSPECIFIED(0),
    /**
     * <code>MEMINFO_MEM_TOTAL = 1;</code>
     */
    MEMINFO_MEM_TOTAL(1),
    /**
     * <code>MEMINFO_MEM_FREE = 2;</code>
     */
    MEMINFO_MEM_FREE(2),
    /**
     * <code>MEMINFO_MEM_AVAILABLE = 3;</code>
     */
    MEMINFO_MEM_AVAILABLE(3),
    /**
     * <code>MEMINFO_BUFFERS = 4;</code>
     */
    MEMINFO_BUFFERS(4),
    /**
     * <code>MEMINFO_CACHED = 5;</code>
     */
    MEMINFO_CACHED(5),
    /**
     * <code>MEMINFO_SWAP_CACHED = 6;</code>
     */
    MEMINFO_SWAP_CACHED(6),
    /**
     * <code>MEMINFO_ACTIVE = 7;</code>
     */
    MEMINFO_ACTIVE(7),
    /**
     * <code>MEMINFO_INACTIVE = 8;</code>
     */
    MEMINFO_INACTIVE(8),
    /**
     * <code>MEMINFO_ACTIVE_ANON = 9;</code>
     */
    MEMINFO_ACTIVE_ANON(9),
    /**
     * <code>MEMINFO_INACTIVE_ANON = 10;</code>
     */
    MEMINFO_INACTIVE_ANON(10),
    /**
     * <code>MEMINFO_ACTIVE_FILE = 11;</code>
     */
    MEMINFO_ACTIVE_FILE(11),
    /**
     * <code>MEMINFO_INACTIVE_FILE = 12;</code>
     */
    MEMINFO_INACTIVE_FILE(12),
    /**
     * <code>MEMINFO_UNEVICTABLE = 13;</code>
     */
    MEMINFO_UNEVICTABLE(13),
    /**
     * <code>MEMINFO_MLOCKED = 14;</code>
     */
    MEMINFO_MLOCKED(14),
    /**
     * <code>MEMINFO_SWAP_TOTAL = 15;</code>
     */
    MEMINFO_SWAP_TOTAL(15),
    /**
     * <code>MEMINFO_SWAP_FREE = 16;</code>
     */
    MEMINFO_SWAP_FREE(16),
    /**
     * <code>MEMINFO_DIRTY = 17;</code>
     */
    MEMINFO_DIRTY(17),
    /**
     * <code>MEMINFO_WRITEBACK = 18;</code>
     */
    MEMINFO_WRITEBACK(18),
    /**
     * <code>MEMINFO_ANON_PAGES = 19;</code>
     */
    MEMINFO_ANON_PAGES(19),
    /**
     * <code>MEMINFO_MAPPED = 20;</code>
     */
    MEMINFO_MAPPED(20),
    /**
     * <code>MEMINFO_SHMEM = 21;</code>
     */
    MEMINFO_SHMEM(21),
    /**
     * <code>MEMINFO_SLAB = 22;</code>
     */
    MEMINFO_SLAB(22),
    /**
     * <code>MEMINFO_SLAB_RECLAIMABLE = 23;</code>
     */
    MEMINFO_SLAB_RECLAIMABLE(23),
    /**
     * <code>MEMINFO_SLAB_UNRECLAIMABLE = 24;</code>
     */
    MEMINFO_SLAB_UNRECLAIMABLE(24),
    /**
     * <code>MEMINFO_KERNEL_STACK = 25;</code>
     */
    MEMINFO_KERNEL_STACK(25),
    /**
     * <code>MEMINFO_PAGE_TABLES = 26;</code>
     */
    MEMINFO_PAGE_TABLES(26),
    /**
     * <code>MEMINFO_COMMIT_LIMIT = 27;</code>
     */
    MEMINFO_COMMIT_LIMIT(27),
    /**
     * <code>MEMINFO_COMMITED_AS = 28;</code>
     */
    MEMINFO_COMMITED_AS(28),
    /**
     * <code>MEMINFO_VMALLOC_TOTAL = 29;</code>
     */
    MEMINFO_VMALLOC_TOTAL(29),
    /**
     * <code>MEMINFO_VMALLOC_USED = 30;</code>
     */
    MEMINFO_VMALLOC_USED(30),
    /**
     * <code>MEMINFO_VMALLOC_CHUNK = 31;</code>
     */
    MEMINFO_VMALLOC_CHUNK(31),
    /**
     * <code>MEMINFO_CMA_TOTAL = 32;</code>
     */
    MEMINFO_CMA_TOTAL(32),
    /**
     * <code>MEMINFO_CMA_FREE = 33;</code>
     */
    MEMINFO_CMA_FREE(33),
    ;

    /**
     * <code>MEMINFO_UNSPECIFIED = 0;</code>
     */
    public static final int MEMINFO_UNSPECIFIED_VALUE = 0;
    /**
     * <code>MEMINFO_MEM_TOTAL = 1;</code>
     */
    public static final int MEMINFO_MEM_TOTAL_VALUE = 1;
    /**
     * <code>MEMINFO_MEM_FREE = 2;</code>
     */
    public static final int MEMINFO_MEM_FREE_VALUE = 2;
    /**
     * <code>MEMINFO_MEM_AVAILABLE = 3;</code>
     */
    public static final int MEMINFO_MEM_AVAILABLE_VALUE = 3;
    /**
     * <code>MEMINFO_BUFFERS = 4;</code>
     */
    public static final int MEMINFO_BUFFERS_VALUE = 4;
    /**
     * <code>MEMINFO_CACHED = 5;</code>
     */
    public static final int MEMINFO_CACHED_VALUE = 5;
    /**
     * <code>MEMINFO_SWAP_CACHED = 6;</code>
     */
    public static final int MEMINFO_SWAP_CACHED_VALUE = 6;
    /**
     * <code>MEMINFO_ACTIVE = 7;</code>
     */
    public static final int MEMINFO_ACTIVE_VALUE = 7;
    /**
     * <code>MEMINFO_INACTIVE = 8;</code>
     */
    public static final int MEMINFO_INACTIVE_VALUE = 8;
    /**
     * <code>MEMINFO_ACTIVE_ANON = 9;</code>
     */
    public static final int MEMINFO_ACTIVE_ANON_VALUE = 9;
    /**
     * <code>MEMINFO_INACTIVE_ANON = 10;</code>
     */
    public static final int MEMINFO_INACTIVE_ANON_VALUE = 10;
    /**
     * <code>MEMINFO_ACTIVE_FILE = 11;</code>
     */
    public static final int MEMINFO_ACTIVE_FILE_VALUE = 11;
    /**
     * <code>MEMINFO_INACTIVE_FILE = 12;</code>
     */
    public static final int MEMINFO_INACTIVE_FILE_VALUE = 12;
    /**
     * <code>MEMINFO_UNEVICTABLE = 13;</code>
     */
    public static final int MEMINFO_UNEVICTABLE_VALUE = 13;
    /**
     * <code>MEMINFO_MLOCKED = 14;</code>
     */
    public static final int MEMINFO_MLOCKED_VALUE = 14;
    /**
     * <code>MEMINFO_SWAP_TOTAL = 15;</code>
     */
    public static final int MEMINFO_SWAP_TOTAL_VALUE = 15;
    /**
     * <code>MEMINFO_SWAP_FREE = 16;</code>
     */
    public static final int MEMINFO_SWAP_FREE_VALUE = 16;
    /**
     * <code>MEMINFO_DIRTY = 17;</code>
     */
    public static final int MEMINFO_DIRTY_VALUE = 17;
    /**
     * <code>MEMINFO_WRITEBACK = 18;</code>
     */
    public static final int MEMINFO_WRITEBACK_VALUE = 18;
    /**
     * <code>MEMINFO_ANON_PAGES = 19;</code>
     */
    public static final int MEMINFO_ANON_PAGES_VALUE = 19;
    /**
     * <code>MEMINFO_MAPPED = 20;</code>
     */
    public static final int MEMINFO_MAPPED_VALUE = 20;
    /**
     * <code>MEMINFO_SHMEM = 21;</code>
     */
    public static final int MEMINFO_SHMEM_VALUE = 21;
    /**
     * <code>MEMINFO_SLAB = 22;</code>
     */
    public static final int MEMINFO_SLAB_VALUE = 22;
    /**
     * <code>MEMINFO_SLAB_RECLAIMABLE = 23;</code>
     */
    public static final int MEMINFO_SLAB_RECLAIMABLE_VALUE = 23;
    /**
     * <code>MEMINFO_SLAB_UNRECLAIMABLE = 24;</code>
     */
    public static final int MEMINFO_SLAB_UNRECLAIMABLE_VALUE = 24;
    /**
     * <code>MEMINFO_KERNEL_STACK = 25;</code>
     */
    public static final int MEMINFO_KERNEL_STACK_VALUE = 25;
    /**
     * <code>MEMINFO_PAGE_TABLES = 26;</code>
     */
    public static final int MEMINFO_PAGE_TABLES_VALUE = 26;
    /**
     * <code>MEMINFO_COMMIT_LIMIT = 27;</code>
     */
    public static final int MEMINFO_COMMIT_LIMIT_VALUE = 27;
    /**
     * <code>MEMINFO_COMMITED_AS = 28;</code>
     */
    public static final int MEMINFO_COMMITED_AS_VALUE = 28;
    /**
     * <code>MEMINFO_VMALLOC_TOTAL = 29;</code>
     */
    public static final int MEMINFO_VMALLOC_TOTAL_VALUE = 29;
    /**
     * <code>MEMINFO_VMALLOC_USED = 30;</code>
     */
    public static final int MEMINFO_VMALLOC_USED_VALUE = 30;
    /**
     * <code>MEMINFO_VMALLOC_CHUNK = 31;</code>
     */
    public static final int MEMINFO_VMALLOC_CHUNK_VALUE = 31;
    /**
     * <code>MEMINFO_CMA_TOTAL = 32;</code>
     */
    public static final int MEMINFO_CMA_TOTAL_VALUE = 32;
    /**
     * <code>MEMINFO_CMA_FREE = 33;</code>
     */
    public static final int MEMINFO_CMA_FREE_VALUE = 33;


    public final int getNumber() {
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static MeminfoCounters valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static MeminfoCounters forNumber(int value) {
      switch (value) {
        case 0: return MEMINFO_UNSPECIFIED;
        case 1: return MEMINFO_MEM_TOTAL;
        case 2: return MEMINFO_MEM_FREE;
        case 3: return MEMINFO_MEM_AVAILABLE;
        case 4: return MEMINFO_BUFFERS;
        case 5: return MEMINFO_CACHED;
        case 6: return MEMINFO_SWAP_CACHED;
        case 7: return MEMINFO_ACTIVE;
        case 8: return MEMINFO_INACTIVE;
        case 9: return MEMINFO_ACTIVE_ANON;
        case 10: return MEMINFO_INACTIVE_ANON;
        case 11: return MEMINFO_ACTIVE_FILE;
        case 12: return MEMINFO_INACTIVE_FILE;
        case 13: return MEMINFO_UNEVICTABLE;
        case 14: return MEMINFO_MLOCKED;
        case 15: return MEMINFO_SWAP_TOTAL;
        case 16: return MEMINFO_SWAP_FREE;
        case 17: return MEMINFO_DIRTY;
        case 18: return MEMINFO_WRITEBACK;
        case 19: return MEMINFO_ANON_PAGES;
        case 20: return MEMINFO_MAPPED;
        case 21: return MEMINFO_SHMEM;
        case 22: return MEMINFO_SLAB;
        case 23: return MEMINFO_SLAB_RECLAIMABLE;
        case 24: return MEMINFO_SLAB_UNRECLAIMABLE;
        case 25: return MEMINFO_KERNEL_STACK;
        case 26: return MEMINFO_PAGE_TABLES;
        case 27: return MEMINFO_COMMIT_LIMIT;
        case 28: return MEMINFO_COMMITED_AS;
        case 29: return MEMINFO_VMALLOC_TOTAL;
        case 30: return MEMINFO_VMALLOC_USED;
        case 31: return MEMINFO_VMALLOC_CHUNK;
        case 32: return MEMINFO_CMA_TOTAL;
        case 33: return MEMINFO_CMA_FREE;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<MeminfoCounters>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        MeminfoCounters> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<MeminfoCounters>() {
            public MeminfoCounters findValueByNumber(int number) {
              return MeminfoCounters.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return perfetto.protos.SysStatsCounters.getDescriptor().getEnumTypes().get(0);
    }

    private static final MeminfoCounters[] VALUES = values();

    public static MeminfoCounters valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private MeminfoCounters(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:perfetto.protos.MeminfoCounters)
  }

  /**
   * <pre>
   * Counter definitions for Linux's /proc/vmstat.
   * </pre>
   *
   * Protobuf enum {@code perfetto.protos.VmstatCounters}
   */
  public enum VmstatCounters
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>VMSTAT_UNSPECIFIED = 0;</code>
     */
    VMSTAT_UNSPECIFIED(0),
    /**
     * <code>VMSTAT_NR_FREE_PAGES = 1;</code>
     */
    VMSTAT_NR_FREE_PAGES(1),
    /**
     * <code>VMSTAT_NR_ALLOC_BATCH = 2;</code>
     */
    VMSTAT_NR_ALLOC_BATCH(2),
    /**
     * <code>VMSTAT_NR_INACTIVE_ANON = 3;</code>
     */
    VMSTAT_NR_INACTIVE_ANON(3),
    /**
     * <code>VMSTAT_NR_ACTIVE_ANON = 4;</code>
     */
    VMSTAT_NR_ACTIVE_ANON(4),
    /**
     * <code>VMSTAT_NR_INACTIVE_FILE = 5;</code>
     */
    VMSTAT_NR_INACTIVE_FILE(5),
    /**
     * <code>VMSTAT_NR_ACTIVE_FILE = 6;</code>
     */
    VMSTAT_NR_ACTIVE_FILE(6),
    /**
     * <code>VMSTAT_NR_UNEVICTABLE = 7;</code>
     */
    VMSTAT_NR_UNEVICTABLE(7),
    /**
     * <code>VMSTAT_NR_MLOCK = 8;</code>
     */
    VMSTAT_NR_MLOCK(8),
    /**
     * <code>VMSTAT_NR_ANON_PAGES = 9;</code>
     */
    VMSTAT_NR_ANON_PAGES(9),
    /**
     * <code>VMSTAT_NR_MAPPED = 10;</code>
     */
    VMSTAT_NR_MAPPED(10),
    /**
     * <code>VMSTAT_NR_FILE_PAGES = 11;</code>
     */
    VMSTAT_NR_FILE_PAGES(11),
    /**
     * <code>VMSTAT_NR_DIRTY = 12;</code>
     */
    VMSTAT_NR_DIRTY(12),
    /**
     * <code>VMSTAT_NR_WRITEBACK = 13;</code>
     */
    VMSTAT_NR_WRITEBACK(13),
    /**
     * <code>VMSTAT_NR_SLAB_RECLAIMABLE = 14;</code>
     */
    VMSTAT_NR_SLAB_RECLAIMABLE(14),
    /**
     * <code>VMSTAT_NR_SLAB_UNRECLAIMABLE = 15;</code>
     */
    VMSTAT_NR_SLAB_UNRECLAIMABLE(15),
    /**
     * <code>VMSTAT_NR_PAGE_TABLE_PAGES = 16;</code>
     */
    VMSTAT_NR_PAGE_TABLE_PAGES(16),
    /**
     * <code>VMSTAT_NR_KERNEL_STACK = 17;</code>
     */
    VMSTAT_NR_KERNEL_STACK(17),
    /**
     * <code>VMSTAT_NR_OVERHEAD = 18;</code>
     */
    VMSTAT_NR_OVERHEAD(18),
    /**
     * <code>VMSTAT_NR_UNSTABLE = 19;</code>
     */
    VMSTAT_NR_UNSTABLE(19),
    /**
     * <code>VMSTAT_NR_BOUNCE = 20;</code>
     */
    VMSTAT_NR_BOUNCE(20),
    /**
     * <code>VMSTAT_NR_VMSCAN_WRITE = 21;</code>
     */
    VMSTAT_NR_VMSCAN_WRITE(21),
    /**
     * <code>VMSTAT_NR_VMSCAN_IMMEDIATE_RECLAIM = 22;</code>
     */
    VMSTAT_NR_VMSCAN_IMMEDIATE_RECLAIM(22),
    /**
     * <code>VMSTAT_NR_WRITEBACK_TEMP = 23;</code>
     */
    VMSTAT_NR_WRITEBACK_TEMP(23),
    /**
     * <code>VMSTAT_NR_ISOLATED_ANON = 24;</code>
     */
    VMSTAT_NR_ISOLATED_ANON(24),
    /**
     * <code>VMSTAT_NR_ISOLATED_FILE = 25;</code>
     */
    VMSTAT_NR_ISOLATED_FILE(25),
    /**
     * <code>VMSTAT_NR_SHMEM = 26;</code>
     */
    VMSTAT_NR_SHMEM(26),
    /**
     * <code>VMSTAT_NR_DIRTIED = 27;</code>
     */
    VMSTAT_NR_DIRTIED(27),
    /**
     * <code>VMSTAT_NR_WRITTEN = 28;</code>
     */
    VMSTAT_NR_WRITTEN(28),
    /**
     * <code>VMSTAT_NR_PAGES_SCANNED = 29;</code>
     */
    VMSTAT_NR_PAGES_SCANNED(29),
    /**
     * <code>VMSTAT_WORKINGSET_REFAULT = 30;</code>
     */
    VMSTAT_WORKINGSET_REFAULT(30),
    /**
     * <code>VMSTAT_WORKINGSET_ACTIVATE = 31;</code>
     */
    VMSTAT_WORKINGSET_ACTIVATE(31),
    /**
     * <code>VMSTAT_WORKINGSET_NODERECLAIM = 32;</code>
     */
    VMSTAT_WORKINGSET_NODERECLAIM(32),
    /**
     * <code>VMSTAT_NR_ANON_TRANSPARENT_HUGEPAGES = 33;</code>
     */
    VMSTAT_NR_ANON_TRANSPARENT_HUGEPAGES(33),
    /**
     * <code>VMSTAT_NR_FREE_CMA = 34;</code>
     */
    VMSTAT_NR_FREE_CMA(34),
    /**
     * <code>VMSTAT_NR_SWAPCACHE = 35;</code>
     */
    VMSTAT_NR_SWAPCACHE(35),
    /**
     * <code>VMSTAT_NR_DIRTY_THRESHOLD = 36;</code>
     */
    VMSTAT_NR_DIRTY_THRESHOLD(36),
    /**
     * <code>VMSTAT_NR_DIRTY_BACKGROUND_THRESHOLD = 37;</code>
     */
    VMSTAT_NR_DIRTY_BACKGROUND_THRESHOLD(37),
    /**
     * <code>VMSTAT_PGPGIN = 38;</code>
     */
    VMSTAT_PGPGIN(38),
    /**
     * <code>VMSTAT_PGPGOUT = 39;</code>
     */
    VMSTAT_PGPGOUT(39),
    /**
     * <code>VMSTAT_PGPGOUTCLEAN = 40;</code>
     */
    VMSTAT_PGPGOUTCLEAN(40),
    /**
     * <code>VMSTAT_PSWPIN = 41;</code>
     */
    VMSTAT_PSWPIN(41),
    /**
     * <code>VMSTAT_PSWPOUT = 42;</code>
     */
    VMSTAT_PSWPOUT(42),
    /**
     * <code>VMSTAT_PGALLOC_DMA = 43;</code>
     */
    VMSTAT_PGALLOC_DMA(43),
    /**
     * <code>VMSTAT_PGALLOC_NORMAL = 44;</code>
     */
    VMSTAT_PGALLOC_NORMAL(44),
    /**
     * <code>VMSTAT_PGALLOC_MOVABLE = 45;</code>
     */
    VMSTAT_PGALLOC_MOVABLE(45),
    /**
     * <code>VMSTAT_PGFREE = 46;</code>
     */
    VMSTAT_PGFREE(46),
    /**
     * <code>VMSTAT_PGACTIVATE = 47;</code>
     */
    VMSTAT_PGACTIVATE(47),
    /**
     * <code>VMSTAT_PGDEACTIVATE = 48;</code>
     */
    VMSTAT_PGDEACTIVATE(48),
    /**
     * <code>VMSTAT_PGFAULT = 49;</code>
     */
    VMSTAT_PGFAULT(49),
    /**
     * <code>VMSTAT_PGMAJFAULT = 50;</code>
     */
    VMSTAT_PGMAJFAULT(50),
    /**
     * <code>VMSTAT_PGREFILL_DMA = 51;</code>
     */
    VMSTAT_PGREFILL_DMA(51),
    /**
     * <code>VMSTAT_PGREFILL_NORMAL = 52;</code>
     */
    VMSTAT_PGREFILL_NORMAL(52),
    /**
     * <code>VMSTAT_PGREFILL_MOVABLE = 53;</code>
     */
    VMSTAT_PGREFILL_MOVABLE(53),
    /**
     * <code>VMSTAT_PGSTEAL_KSWAPD_DMA = 54;</code>
     */
    VMSTAT_PGSTEAL_KSWAPD_DMA(54),
    /**
     * <code>VMSTAT_PGSTEAL_KSWAPD_NORMAL = 55;</code>
     */
    VMSTAT_PGSTEAL_KSWAPD_NORMAL(55),
    /**
     * <code>VMSTAT_PGSTEAL_KSWAPD_MOVABLE = 56;</code>
     */
    VMSTAT_PGSTEAL_KSWAPD_MOVABLE(56),
    /**
     * <code>VMSTAT_PGSTEAL_DIRECT_DMA = 57;</code>
     */
    VMSTAT_PGSTEAL_DIRECT_DMA(57),
    /**
     * <code>VMSTAT_PGSTEAL_DIRECT_NORMAL = 58;</code>
     */
    VMSTAT_PGSTEAL_DIRECT_NORMAL(58),
    /**
     * <code>VMSTAT_PGSTEAL_DIRECT_MOVABLE = 59;</code>
     */
    VMSTAT_PGSTEAL_DIRECT_MOVABLE(59),
    /**
     * <code>VMSTAT_PGSCAN_KSWAPD_DMA = 60;</code>
     */
    VMSTAT_PGSCAN_KSWAPD_DMA(60),
    /**
     * <code>VMSTAT_PGSCAN_KSWAPD_NORMAL = 61;</code>
     */
    VMSTAT_PGSCAN_KSWAPD_NORMAL(61),
    /**
     * <code>VMSTAT_PGSCAN_KSWAPD_MOVABLE = 62;</code>
     */
    VMSTAT_PGSCAN_KSWAPD_MOVABLE(62),
    /**
     * <code>VMSTAT_PGSCAN_DIRECT_DMA = 63;</code>
     */
    VMSTAT_PGSCAN_DIRECT_DMA(63),
    /**
     * <code>VMSTAT_PGSCAN_DIRECT_NORMAL = 64;</code>
     */
    VMSTAT_PGSCAN_DIRECT_NORMAL(64),
    /**
     * <code>VMSTAT_PGSCAN_DIRECT_MOVABLE = 65;</code>
     */
    VMSTAT_PGSCAN_DIRECT_MOVABLE(65),
    /**
     * <code>VMSTAT_PGSCAN_DIRECT_THROTTLE = 66;</code>
     */
    VMSTAT_PGSCAN_DIRECT_THROTTLE(66),
    /**
     * <code>VMSTAT_PGINODESTEAL = 67;</code>
     */
    VMSTAT_PGINODESTEAL(67),
    /**
     * <code>VMSTAT_SLABS_SCANNED = 68;</code>
     */
    VMSTAT_SLABS_SCANNED(68),
    /**
     * <code>VMSTAT_KSWAPD_INODESTEAL = 69;</code>
     */
    VMSTAT_KSWAPD_INODESTEAL(69),
    /**
     * <code>VMSTAT_KSWAPD_LOW_WMARK_HIT_QUICKLY = 70;</code>
     */
    VMSTAT_KSWAPD_LOW_WMARK_HIT_QUICKLY(70),
    /**
     * <code>VMSTAT_KSWAPD_HIGH_WMARK_HIT_QUICKLY = 71;</code>
     */
    VMSTAT_KSWAPD_HIGH_WMARK_HIT_QUICKLY(71),
    /**
     * <code>VMSTAT_PAGEOUTRUN = 72;</code>
     */
    VMSTAT_PAGEOUTRUN(72),
    /**
     * <code>VMSTAT_ALLOCSTALL = 73;</code>
     */
    VMSTAT_ALLOCSTALL(73),
    /**
     * <code>VMSTAT_PGROTATED = 74;</code>
     */
    VMSTAT_PGROTATED(74),
    /**
     * <code>VMSTAT_DROP_PAGECACHE = 75;</code>
     */
    VMSTAT_DROP_PAGECACHE(75),
    /**
     * <code>VMSTAT_DROP_SLAB = 76;</code>
     */
    VMSTAT_DROP_SLAB(76),
    /**
     * <code>VMSTAT_PGMIGRATE_SUCCESS = 77;</code>
     */
    VMSTAT_PGMIGRATE_SUCCESS(77),
    /**
     * <code>VMSTAT_PGMIGRATE_FAIL = 78;</code>
     */
    VMSTAT_PGMIGRATE_FAIL(78),
    /**
     * <code>VMSTAT_COMPACT_MIGRATE_SCANNED = 79;</code>
     */
    VMSTAT_COMPACT_MIGRATE_SCANNED(79),
    /**
     * <code>VMSTAT_COMPACT_FREE_SCANNED = 80;</code>
     */
    VMSTAT_COMPACT_FREE_SCANNED(80),
    /**
     * <code>VMSTAT_COMPACT_ISOLATED = 81;</code>
     */
    VMSTAT_COMPACT_ISOLATED(81),
    /**
     * <code>VMSTAT_COMPACT_STALL = 82;</code>
     */
    VMSTAT_COMPACT_STALL(82),
    /**
     * <code>VMSTAT_COMPACT_FAIL = 83;</code>
     */
    VMSTAT_COMPACT_FAIL(83),
    /**
     * <code>VMSTAT_COMPACT_SUCCESS = 84;</code>
     */
    VMSTAT_COMPACT_SUCCESS(84),
    /**
     * <code>VMSTAT_COMPACT_DAEMON_WAKE = 85;</code>
     */
    VMSTAT_COMPACT_DAEMON_WAKE(85),
    /**
     * <code>VMSTAT_UNEVICTABLE_PGS_CULLED = 86;</code>
     */
    VMSTAT_UNEVICTABLE_PGS_CULLED(86),
    /**
     * <code>VMSTAT_UNEVICTABLE_PGS_SCANNED = 87;</code>
     */
    VMSTAT_UNEVICTABLE_PGS_SCANNED(87),
    /**
     * <code>VMSTAT_UNEVICTABLE_PGS_RESCUED = 88;</code>
     */
    VMSTAT_UNEVICTABLE_PGS_RESCUED(88),
    /**
     * <code>VMSTAT_UNEVICTABLE_PGS_MLOCKED = 89;</code>
     */
    VMSTAT_UNEVICTABLE_PGS_MLOCKED(89),
    /**
     * <code>VMSTAT_UNEVICTABLE_PGS_MUNLOCKED = 90;</code>
     */
    VMSTAT_UNEVICTABLE_PGS_MUNLOCKED(90),
    /**
     * <code>VMSTAT_UNEVICTABLE_PGS_CLEARED = 91;</code>
     */
    VMSTAT_UNEVICTABLE_PGS_CLEARED(91),
    /**
     * <code>VMSTAT_UNEVICTABLE_PGS_STRANDED = 92;</code>
     */
    VMSTAT_UNEVICTABLE_PGS_STRANDED(92),
    /**
     * <code>VMSTAT_NR_ZSPAGES = 93;</code>
     */
    VMSTAT_NR_ZSPAGES(93),
    /**
     * <code>VMSTAT_NR_ION_HEAP = 94;</code>
     */
    VMSTAT_NR_ION_HEAP(94),
    /**
     * <code>VMSTAT_NR_GPU_HEAP = 95;</code>
     */
    VMSTAT_NR_GPU_HEAP(95),
    /**
     * <code>VMSTAT_ALLOCSTALL_DMA = 96;</code>
     */
    VMSTAT_ALLOCSTALL_DMA(96),
    /**
     * <code>VMSTAT_ALLOCSTALL_MOVABLE = 97;</code>
     */
    VMSTAT_ALLOCSTALL_MOVABLE(97),
    /**
     * <code>VMSTAT_ALLOCSTALL_NORMAL = 98;</code>
     */
    VMSTAT_ALLOCSTALL_NORMAL(98),
    /**
     * <code>VMSTAT_COMPACT_DAEMON_FREE_SCANNED = 99;</code>
     */
    VMSTAT_COMPACT_DAEMON_FREE_SCANNED(99),
    /**
     * <code>VMSTAT_COMPACT_DAEMON_MIGRATE_SCANNED = 100;</code>
     */
    VMSTAT_COMPACT_DAEMON_MIGRATE_SCANNED(100),
    /**
     * <code>VMSTAT_NR_FASTRPC = 101;</code>
     */
    VMSTAT_NR_FASTRPC(101),
    /**
     * <code>VMSTAT_NR_INDIRECTLY_RECLAIMABLE = 102;</code>
     */
    VMSTAT_NR_INDIRECTLY_RECLAIMABLE(102),
    /**
     * <code>VMSTAT_NR_ION_HEAP_POOL = 103;</code>
     */
    VMSTAT_NR_ION_HEAP_POOL(103),
    /**
     * <code>VMSTAT_NR_KERNEL_MISC_RECLAIMABLE = 104;</code>
     */
    VMSTAT_NR_KERNEL_MISC_RECLAIMABLE(104),
    /**
     * <code>VMSTAT_NR_SHADOW_CALL_STACK_BYTES = 105;</code>
     */
    VMSTAT_NR_SHADOW_CALL_STACK_BYTES(105),
    /**
     * <code>VMSTAT_NR_SHMEM_HUGEPAGES = 106;</code>
     */
    VMSTAT_NR_SHMEM_HUGEPAGES(106),
    /**
     * <code>VMSTAT_NR_SHMEM_PMDMAPPED = 107;</code>
     */
    VMSTAT_NR_SHMEM_PMDMAPPED(107),
    /**
     * <code>VMSTAT_NR_UNRECLAIMABLE_PAGES = 108;</code>
     */
    VMSTAT_NR_UNRECLAIMABLE_PAGES(108),
    /**
     * <code>VMSTAT_NR_ZONE_ACTIVE_ANON = 109;</code>
     */
    VMSTAT_NR_ZONE_ACTIVE_ANON(109),
    /**
     * <code>VMSTAT_NR_ZONE_ACTIVE_FILE = 110;</code>
     */
    VMSTAT_NR_ZONE_ACTIVE_FILE(110),
    /**
     * <code>VMSTAT_NR_ZONE_INACTIVE_ANON = 111;</code>
     */
    VMSTAT_NR_ZONE_INACTIVE_ANON(111),
    /**
     * <code>VMSTAT_NR_ZONE_INACTIVE_FILE = 112;</code>
     */
    VMSTAT_NR_ZONE_INACTIVE_FILE(112),
    /**
     * <code>VMSTAT_NR_ZONE_UNEVICTABLE = 113;</code>
     */
    VMSTAT_NR_ZONE_UNEVICTABLE(113),
    /**
     * <code>VMSTAT_NR_ZONE_WRITE_PENDING = 114;</code>
     */
    VMSTAT_NR_ZONE_WRITE_PENDING(114),
    /**
     * <code>VMSTAT_OOM_KILL = 115;</code>
     */
    VMSTAT_OOM_KILL(115),
    /**
     * <code>VMSTAT_PGLAZYFREE = 116;</code>
     */
    VMSTAT_PGLAZYFREE(116),
    /**
     * <code>VMSTAT_PGLAZYFREED = 117;</code>
     */
    VMSTAT_PGLAZYFREED(117),
    /**
     * <code>VMSTAT_PGREFILL = 118;</code>
     */
    VMSTAT_PGREFILL(118),
    /**
     * <code>VMSTAT_PGSCAN_DIRECT = 119;</code>
     */
    VMSTAT_PGSCAN_DIRECT(119),
    /**
     * <code>VMSTAT_PGSCAN_KSWAPD = 120;</code>
     */
    VMSTAT_PGSCAN_KSWAPD(120),
    /**
     * <code>VMSTAT_PGSKIP_DMA = 121;</code>
     */
    VMSTAT_PGSKIP_DMA(121),
    /**
     * <code>VMSTAT_PGSKIP_MOVABLE = 122;</code>
     */
    VMSTAT_PGSKIP_MOVABLE(122),
    /**
     * <code>VMSTAT_PGSKIP_NORMAL = 123;</code>
     */
    VMSTAT_PGSKIP_NORMAL(123),
    /**
     * <code>VMSTAT_PGSTEAL_DIRECT = 124;</code>
     */
    VMSTAT_PGSTEAL_DIRECT(124),
    /**
     * <code>VMSTAT_PGSTEAL_KSWAPD = 125;</code>
     */
    VMSTAT_PGSTEAL_KSWAPD(125),
    /**
     * <code>VMSTAT_SWAP_RA = 126;</code>
     */
    VMSTAT_SWAP_RA(126),
    /**
     * <code>VMSTAT_SWAP_RA_HIT = 127;</code>
     */
    VMSTAT_SWAP_RA_HIT(127),
    /**
     * <code>VMSTAT_WORKINGSET_RESTORE = 128;</code>
     */
    VMSTAT_WORKINGSET_RESTORE(128),
    ;

    /**
     * <code>VMSTAT_UNSPECIFIED = 0;</code>
     */
    public static final int VMSTAT_UNSPECIFIED_VALUE = 0;
    /**
     * <code>VMSTAT_NR_FREE_PAGES = 1;</code>
     */
    public static final int VMSTAT_NR_FREE_PAGES_VALUE = 1;
    /**
     * <code>VMSTAT_NR_ALLOC_BATCH = 2;</code>
     */
    public static final int VMSTAT_NR_ALLOC_BATCH_VALUE = 2;
    /**
     * <code>VMSTAT_NR_INACTIVE_ANON = 3;</code>
     */
    public static final int VMSTAT_NR_INACTIVE_ANON_VALUE = 3;
    /**
     * <code>VMSTAT_NR_ACTIVE_ANON = 4;</code>
     */
    public static final int VMSTAT_NR_ACTIVE_ANON_VALUE = 4;
    /**
     * <code>VMSTAT_NR_INACTIVE_FILE = 5;</code>
     */
    public static final int VMSTAT_NR_INACTIVE_FILE_VALUE = 5;
    /**
     * <code>VMSTAT_NR_ACTIVE_FILE = 6;</code>
     */
    public static final int VMSTAT_NR_ACTIVE_FILE_VALUE = 6;
    /**
     * <code>VMSTAT_NR_UNEVICTABLE = 7;</code>
     */
    public static final int VMSTAT_NR_UNEVICTABLE_VALUE = 7;
    /**
     * <code>VMSTAT_NR_MLOCK = 8;</code>
     */
    public static final int VMSTAT_NR_MLOCK_VALUE = 8;
    /**
     * <code>VMSTAT_NR_ANON_PAGES = 9;</code>
     */
    public static final int VMSTAT_NR_ANON_PAGES_VALUE = 9;
    /**
     * <code>VMSTAT_NR_MAPPED = 10;</code>
     */
    public static final int VMSTAT_NR_MAPPED_VALUE = 10;
    /**
     * <code>VMSTAT_NR_FILE_PAGES = 11;</code>
     */
    public static final int VMSTAT_NR_FILE_PAGES_VALUE = 11;
    /**
     * <code>VMSTAT_NR_DIRTY = 12;</code>
     */
    public static final int VMSTAT_NR_DIRTY_VALUE = 12;
    /**
     * <code>VMSTAT_NR_WRITEBACK = 13;</code>
     */
    public static final int VMSTAT_NR_WRITEBACK_VALUE = 13;
    /**
     * <code>VMSTAT_NR_SLAB_RECLAIMABLE = 14;</code>
     */
    public static final int VMSTAT_NR_SLAB_RECLAIMABLE_VALUE = 14;
    /**
     * <code>VMSTAT_NR_SLAB_UNRECLAIMABLE = 15;</code>
     */
    public static final int VMSTAT_NR_SLAB_UNRECLAIMABLE_VALUE = 15;
    /**
     * <code>VMSTAT_NR_PAGE_TABLE_PAGES = 16;</code>
     */
    public static final int VMSTAT_NR_PAGE_TABLE_PAGES_VALUE = 16;
    /**
     * <code>VMSTAT_NR_KERNEL_STACK = 17;</code>
     */
    public static final int VMSTAT_NR_KERNEL_STACK_VALUE = 17;
    /**
     * <code>VMSTAT_NR_OVERHEAD = 18;</code>
     */
    public static final int VMSTAT_NR_OVERHEAD_VALUE = 18;
    /**
     * <code>VMSTAT_NR_UNSTABLE = 19;</code>
     */
    public static final int VMSTAT_NR_UNSTABLE_VALUE = 19;
    /**
     * <code>VMSTAT_NR_BOUNCE = 20;</code>
     */
    public static final int VMSTAT_NR_BOUNCE_VALUE = 20;
    /**
     * <code>VMSTAT_NR_VMSCAN_WRITE = 21;</code>
     */
    public static final int VMSTAT_NR_VMSCAN_WRITE_VALUE = 21;
    /**
     * <code>VMSTAT_NR_VMSCAN_IMMEDIATE_RECLAIM = 22;</code>
     */
    public static final int VMSTAT_NR_VMSCAN_IMMEDIATE_RECLAIM_VALUE = 22;
    /**
     * <code>VMSTAT_NR_WRITEBACK_TEMP = 23;</code>
     */
    public static final int VMSTAT_NR_WRITEBACK_TEMP_VALUE = 23;
    /**
     * <code>VMSTAT_NR_ISOLATED_ANON = 24;</code>
     */
    public static final int VMSTAT_NR_ISOLATED_ANON_VALUE = 24;
    /**
     * <code>VMSTAT_NR_ISOLATED_FILE = 25;</code>
     */
    public static final int VMSTAT_NR_ISOLATED_FILE_VALUE = 25;
    /**
     * <code>VMSTAT_NR_SHMEM = 26;</code>
     */
    public static final int VMSTAT_NR_SHMEM_VALUE = 26;
    /**
     * <code>VMSTAT_NR_DIRTIED = 27;</code>
     */
    public static final int VMSTAT_NR_DIRTIED_VALUE = 27;
    /**
     * <code>VMSTAT_NR_WRITTEN = 28;</code>
     */
    public static final int VMSTAT_NR_WRITTEN_VALUE = 28;
    /**
     * <code>VMSTAT_NR_PAGES_SCANNED = 29;</code>
     */
    public static final int VMSTAT_NR_PAGES_SCANNED_VALUE = 29;
    /**
     * <code>VMSTAT_WORKINGSET_REFAULT = 30;</code>
     */
    public static final int VMSTAT_WORKINGSET_REFAULT_VALUE = 30;
    /**
     * <code>VMSTAT_WORKINGSET_ACTIVATE = 31;</code>
     */
    public static final int VMSTAT_WORKINGSET_ACTIVATE_VALUE = 31;
    /**
     * <code>VMSTAT_WORKINGSET_NODERECLAIM = 32;</code>
     */
    public static final int VMSTAT_WORKINGSET_NODERECLAIM_VALUE = 32;
    /**
     * <code>VMSTAT_NR_ANON_TRANSPARENT_HUGEPAGES = 33;</code>
     */
    public static final int VMSTAT_NR_ANON_TRANSPARENT_HUGEPAGES_VALUE = 33;
    /**
     * <code>VMSTAT_NR_FREE_CMA = 34;</code>
     */
    public static final int VMSTAT_NR_FREE_CMA_VALUE = 34;
    /**
     * <code>VMSTAT_NR_SWAPCACHE = 35;</code>
     */
    public static final int VMSTAT_NR_SWAPCACHE_VALUE = 35;
    /**
     * <code>VMSTAT_NR_DIRTY_THRESHOLD = 36;</code>
     */
    public static final int VMSTAT_NR_DIRTY_THRESHOLD_VALUE = 36;
    /**
     * <code>VMSTAT_NR_DIRTY_BACKGROUND_THRESHOLD = 37;</code>
     */
    public static final int VMSTAT_NR_DIRTY_BACKGROUND_THRESHOLD_VALUE = 37;
    /**
     * <code>VMSTAT_PGPGIN = 38;</code>
     */
    public static final int VMSTAT_PGPGIN_VALUE = 38;
    /**
     * <code>VMSTAT_PGPGOUT = 39;</code>
     */
    public static final int VMSTAT_PGPGOUT_VALUE = 39;
    /**
     * <code>VMSTAT_PGPGOUTCLEAN = 40;</code>
     */
    public static final int VMSTAT_PGPGOUTCLEAN_VALUE = 40;
    /**
     * <code>VMSTAT_PSWPIN = 41;</code>
     */
    public static final int VMSTAT_PSWPIN_VALUE = 41;
    /**
     * <code>VMSTAT_PSWPOUT = 42;</code>
     */
    public static final int VMSTAT_PSWPOUT_VALUE = 42;
    /**
     * <code>VMSTAT_PGALLOC_DMA = 43;</code>
     */
    public static final int VMSTAT_PGALLOC_DMA_VALUE = 43;
    /**
     * <code>VMSTAT_PGALLOC_NORMAL = 44;</code>
     */
    public static final int VMSTAT_PGALLOC_NORMAL_VALUE = 44;
    /**
     * <code>VMSTAT_PGALLOC_MOVABLE = 45;</code>
     */
    public static final int VMSTAT_PGALLOC_MOVABLE_VALUE = 45;
    /**
     * <code>VMSTAT_PGFREE = 46;</code>
     */
    public static final int VMSTAT_PGFREE_VALUE = 46;
    /**
     * <code>VMSTAT_PGACTIVATE = 47;</code>
     */
    public static final int VMSTAT_PGACTIVATE_VALUE = 47;
    /**
     * <code>VMSTAT_PGDEACTIVATE = 48;</code>
     */
    public static final int VMSTAT_PGDEACTIVATE_VALUE = 48;
    /**
     * <code>VMSTAT_PGFAULT = 49;</code>
     */
    public static final int VMSTAT_PGFAULT_VALUE = 49;
    /**
     * <code>VMSTAT_PGMAJFAULT = 50;</code>
     */
    public static final int VMSTAT_PGMAJFAULT_VALUE = 50;
    /**
     * <code>VMSTAT_PGREFILL_DMA = 51;</code>
     */
    public static final int VMSTAT_PGREFILL_DMA_VALUE = 51;
    /**
     * <code>VMSTAT_PGREFILL_NORMAL = 52;</code>
     */
    public static final int VMSTAT_PGREFILL_NORMAL_VALUE = 52;
    /**
     * <code>VMSTAT_PGREFILL_MOVABLE = 53;</code>
     */
    public static final int VMSTAT_PGREFILL_MOVABLE_VALUE = 53;
    /**
     * <code>VMSTAT_PGSTEAL_KSWAPD_DMA = 54;</code>
     */
    public static final int VMSTAT_PGSTEAL_KSWAPD_DMA_VALUE = 54;
    /**
     * <code>VMSTAT_PGSTEAL_KSWAPD_NORMAL = 55;</code>
     */
    public static final int VMSTAT_PGSTEAL_KSWAPD_NORMAL_VALUE = 55;
    /**
     * <code>VMSTAT_PGSTEAL_KSWAPD_MOVABLE = 56;</code>
     */
    public static final int VMSTAT_PGSTEAL_KSWAPD_MOVABLE_VALUE = 56;
    /**
     * <code>VMSTAT_PGSTEAL_DIRECT_DMA = 57;</code>
     */
    public static final int VMSTAT_PGSTEAL_DIRECT_DMA_VALUE = 57;
    /**
     * <code>VMSTAT_PGSTEAL_DIRECT_NORMAL = 58;</code>
     */
    public static final int VMSTAT_PGSTEAL_DIRECT_NORMAL_VALUE = 58;
    /**
     * <code>VMSTAT_PGSTEAL_DIRECT_MOVABLE = 59;</code>
     */
    public static final int VMSTAT_PGSTEAL_DIRECT_MOVABLE_VALUE = 59;
    /**
     * <code>VMSTAT_PGSCAN_KSWAPD_DMA = 60;</code>
     */
    public static final int VMSTAT_PGSCAN_KSWAPD_DMA_VALUE = 60;
    /**
     * <code>VMSTAT_PGSCAN_KSWAPD_NORMAL = 61;</code>
     */
    public static final int VMSTAT_PGSCAN_KSWAPD_NORMAL_VALUE = 61;
    /**
     * <code>VMSTAT_PGSCAN_KSWAPD_MOVABLE = 62;</code>
     */
    public static final int VMSTAT_PGSCAN_KSWAPD_MOVABLE_VALUE = 62;
    /**
     * <code>VMSTAT_PGSCAN_DIRECT_DMA = 63;</code>
     */
    public static final int VMSTAT_PGSCAN_DIRECT_DMA_VALUE = 63;
    /**
     * <code>VMSTAT_PGSCAN_DIRECT_NORMAL = 64;</code>
     */
    public static final int VMSTAT_PGSCAN_DIRECT_NORMAL_VALUE = 64;
    /**
     * <code>VMSTAT_PGSCAN_DIRECT_MOVABLE = 65;</code>
     */
    public static final int VMSTAT_PGSCAN_DIRECT_MOVABLE_VALUE = 65;
    /**
     * <code>VMSTAT_PGSCAN_DIRECT_THROTTLE = 66;</code>
     */
    public static final int VMSTAT_PGSCAN_DIRECT_THROTTLE_VALUE = 66;
    /**
     * <code>VMSTAT_PGINODESTEAL = 67;</code>
     */
    public static final int VMSTAT_PGINODESTEAL_VALUE = 67;
    /**
     * <code>VMSTAT_SLABS_SCANNED = 68;</code>
     */
    public static final int VMSTAT_SLABS_SCANNED_VALUE = 68;
    /**
     * <code>VMSTAT_KSWAPD_INODESTEAL = 69;</code>
     */
    public static final int VMSTAT_KSWAPD_INODESTEAL_VALUE = 69;
    /**
     * <code>VMSTAT_KSWAPD_LOW_WMARK_HIT_QUICKLY = 70;</code>
     */
    public static final int VMSTAT_KSWAPD_LOW_WMARK_HIT_QUICKLY_VALUE = 70;
    /**
     * <code>VMSTAT_KSWAPD_HIGH_WMARK_HIT_QUICKLY = 71;</code>
     */
    public static final int VMSTAT_KSWAPD_HIGH_WMARK_HIT_QUICKLY_VALUE = 71;
    /**
     * <code>VMSTAT_PAGEOUTRUN = 72;</code>
     */
    public static final int VMSTAT_PAGEOUTRUN_VALUE = 72;
    /**
     * <code>VMSTAT_ALLOCSTALL = 73;</code>
     */
    public static final int VMSTAT_ALLOCSTALL_VALUE = 73;
    /**
     * <code>VMSTAT_PGROTATED = 74;</code>
     */
    public static final int VMSTAT_PGROTATED_VALUE = 74;
    /**
     * <code>VMSTAT_DROP_PAGECACHE = 75;</code>
     */
    public static final int VMSTAT_DROP_PAGECACHE_VALUE = 75;
    /**
     * <code>VMSTAT_DROP_SLAB = 76;</code>
     */
    public static final int VMSTAT_DROP_SLAB_VALUE = 76;
    /**
     * <code>VMSTAT_PGMIGRATE_SUCCESS = 77;</code>
     */
    public static final int VMSTAT_PGMIGRATE_SUCCESS_VALUE = 77;
    /**
     * <code>VMSTAT_PGMIGRATE_FAIL = 78;</code>
     */
    public static final int VMSTAT_PGMIGRATE_FAIL_VALUE = 78;
    /**
     * <code>VMSTAT_COMPACT_MIGRATE_SCANNED = 79;</code>
     */
    public static final int VMSTAT_COMPACT_MIGRATE_SCANNED_VALUE = 79;
    /**
     * <code>VMSTAT_COMPACT_FREE_SCANNED = 80;</code>
     */
    public static final int VMSTAT_COMPACT_FREE_SCANNED_VALUE = 80;
    /**
     * <code>VMSTAT_COMPACT_ISOLATED = 81;</code>
     */
    public static final int VMSTAT_COMPACT_ISOLATED_VALUE = 81;
    /**
     * <code>VMSTAT_COMPACT_STALL = 82;</code>
     */
    public static final int VMSTAT_COMPACT_STALL_VALUE = 82;
    /**
     * <code>VMSTAT_COMPACT_FAIL = 83;</code>
     */
    public static final int VMSTAT_COMPACT_FAIL_VALUE = 83;
    /**
     * <code>VMSTAT_COMPACT_SUCCESS = 84;</code>
     */
    public static final int VMSTAT_COMPACT_SUCCESS_VALUE = 84;
    /**
     * <code>VMSTAT_COMPACT_DAEMON_WAKE = 85;</code>
     */
    public static final int VMSTAT_COMPACT_DAEMON_WAKE_VALUE = 85;
    /**
     * <code>VMSTAT_UNEVICTABLE_PGS_CULLED = 86;</code>
     */
    public static final int VMSTAT_UNEVICTABLE_PGS_CULLED_VALUE = 86;
    /**
     * <code>VMSTAT_UNEVICTABLE_PGS_SCANNED = 87;</code>
     */
    public static final int VMSTAT_UNEVICTABLE_PGS_SCANNED_VALUE = 87;
    /**
     * <code>VMSTAT_UNEVICTABLE_PGS_RESCUED = 88;</code>
     */
    public static final int VMSTAT_UNEVICTABLE_PGS_RESCUED_VALUE = 88;
    /**
     * <code>VMSTAT_UNEVICTABLE_PGS_MLOCKED = 89;</code>
     */
    public static final int VMSTAT_UNEVICTABLE_PGS_MLOCKED_VALUE = 89;
    /**
     * <code>VMSTAT_UNEVICTABLE_PGS_MUNLOCKED = 90;</code>
     */
    public static final int VMSTAT_UNEVICTABLE_PGS_MUNLOCKED_VALUE = 90;
    /**
     * <code>VMSTAT_UNEVICTABLE_PGS_CLEARED = 91;</code>
     */
    public static final int VMSTAT_UNEVICTABLE_PGS_CLEARED_VALUE = 91;
    /**
     * <code>VMSTAT_UNEVICTABLE_PGS_STRANDED = 92;</code>
     */
    public static final int VMSTAT_UNEVICTABLE_PGS_STRANDED_VALUE = 92;
    /**
     * <code>VMSTAT_NR_ZSPAGES = 93;</code>
     */
    public static final int VMSTAT_NR_ZSPAGES_VALUE = 93;
    /**
     * <code>VMSTAT_NR_ION_HEAP = 94;</code>
     */
    public static final int VMSTAT_NR_ION_HEAP_VALUE = 94;
    /**
     * <code>VMSTAT_NR_GPU_HEAP = 95;</code>
     */
    public static final int VMSTAT_NR_GPU_HEAP_VALUE = 95;
    /**
     * <code>VMSTAT_ALLOCSTALL_DMA = 96;</code>
     */
    public static final int VMSTAT_ALLOCSTALL_DMA_VALUE = 96;
    /**
     * <code>VMSTAT_ALLOCSTALL_MOVABLE = 97;</code>
     */
    public static final int VMSTAT_ALLOCSTALL_MOVABLE_VALUE = 97;
    /**
     * <code>VMSTAT_ALLOCSTALL_NORMAL = 98;</code>
     */
    public static final int VMSTAT_ALLOCSTALL_NORMAL_VALUE = 98;
    /**
     * <code>VMSTAT_COMPACT_DAEMON_FREE_SCANNED = 99;</code>
     */
    public static final int VMSTAT_COMPACT_DAEMON_FREE_SCANNED_VALUE = 99;
    /**
     * <code>VMSTAT_COMPACT_DAEMON_MIGRATE_SCANNED = 100;</code>
     */
    public static final int VMSTAT_COMPACT_DAEMON_MIGRATE_SCANNED_VALUE = 100;
    /**
     * <code>VMSTAT_NR_FASTRPC = 101;</code>
     */
    public static final int VMSTAT_NR_FASTRPC_VALUE = 101;
    /**
     * <code>VMSTAT_NR_INDIRECTLY_RECLAIMABLE = 102;</code>
     */
    public static final int VMSTAT_NR_INDIRECTLY_RECLAIMABLE_VALUE = 102;
    /**
     * <code>VMSTAT_NR_ION_HEAP_POOL = 103;</code>
     */
    public static final int VMSTAT_NR_ION_HEAP_POOL_VALUE = 103;
    /**
     * <code>VMSTAT_NR_KERNEL_MISC_RECLAIMABLE = 104;</code>
     */
    public static final int VMSTAT_NR_KERNEL_MISC_RECLAIMABLE_VALUE = 104;
    /**
     * <code>VMSTAT_NR_SHADOW_CALL_STACK_BYTES = 105;</code>
     */
    public static final int VMSTAT_NR_SHADOW_CALL_STACK_BYTES_VALUE = 105;
    /**
     * <code>VMSTAT_NR_SHMEM_HUGEPAGES = 106;</code>
     */
    public static final int VMSTAT_NR_SHMEM_HUGEPAGES_VALUE = 106;
    /**
     * <code>VMSTAT_NR_SHMEM_PMDMAPPED = 107;</code>
     */
    public static final int VMSTAT_NR_SHMEM_PMDMAPPED_VALUE = 107;
    /**
     * <code>VMSTAT_NR_UNRECLAIMABLE_PAGES = 108;</code>
     */
    public static final int VMSTAT_NR_UNRECLAIMABLE_PAGES_VALUE = 108;
    /**
     * <code>VMSTAT_NR_ZONE_ACTIVE_ANON = 109;</code>
     */
    public static final int VMSTAT_NR_ZONE_ACTIVE_ANON_VALUE = 109;
    /**
     * <code>VMSTAT_NR_ZONE_ACTIVE_FILE = 110;</code>
     */
    public static final int VMSTAT_NR_ZONE_ACTIVE_FILE_VALUE = 110;
    /**
     * <code>VMSTAT_NR_ZONE_INACTIVE_ANON = 111;</code>
     */
    public static final int VMSTAT_NR_ZONE_INACTIVE_ANON_VALUE = 111;
    /**
     * <code>VMSTAT_NR_ZONE_INACTIVE_FILE = 112;</code>
     */
    public static final int VMSTAT_NR_ZONE_INACTIVE_FILE_VALUE = 112;
    /**
     * <code>VMSTAT_NR_ZONE_UNEVICTABLE = 113;</code>
     */
    public static final int VMSTAT_NR_ZONE_UNEVICTABLE_VALUE = 113;
    /**
     * <code>VMSTAT_NR_ZONE_WRITE_PENDING = 114;</code>
     */
    public static final int VMSTAT_NR_ZONE_WRITE_PENDING_VALUE = 114;
    /**
     * <code>VMSTAT_OOM_KILL = 115;</code>
     */
    public static final int VMSTAT_OOM_KILL_VALUE = 115;
    /**
     * <code>VMSTAT_PGLAZYFREE = 116;</code>
     */
    public static final int VMSTAT_PGLAZYFREE_VALUE = 116;
    /**
     * <code>VMSTAT_PGLAZYFREED = 117;</code>
     */
    public static final int VMSTAT_PGLAZYFREED_VALUE = 117;
    /**
     * <code>VMSTAT_PGREFILL = 118;</code>
     */
    public static final int VMSTAT_PGREFILL_VALUE = 118;
    /**
     * <code>VMSTAT_PGSCAN_DIRECT = 119;</code>
     */
    public static final int VMSTAT_PGSCAN_DIRECT_VALUE = 119;
    /**
     * <code>VMSTAT_PGSCAN_KSWAPD = 120;</code>
     */
    public static final int VMSTAT_PGSCAN_KSWAPD_VALUE = 120;
    /**
     * <code>VMSTAT_PGSKIP_DMA = 121;</code>
     */
    public static final int VMSTAT_PGSKIP_DMA_VALUE = 121;
    /**
     * <code>VMSTAT_PGSKIP_MOVABLE = 122;</code>
     */
    public static final int VMSTAT_PGSKIP_MOVABLE_VALUE = 122;
    /**
     * <code>VMSTAT_PGSKIP_NORMAL = 123;</code>
     */
    public static final int VMSTAT_PGSKIP_NORMAL_VALUE = 123;
    /**
     * <code>VMSTAT_PGSTEAL_DIRECT = 124;</code>
     */
    public static final int VMSTAT_PGSTEAL_DIRECT_VALUE = 124;
    /**
     * <code>VMSTAT_PGSTEAL_KSWAPD = 125;</code>
     */
    public static final int VMSTAT_PGSTEAL_KSWAPD_VALUE = 125;
    /**
     * <code>VMSTAT_SWAP_RA = 126;</code>
     */
    public static final int VMSTAT_SWAP_RA_VALUE = 126;
    /**
     * <code>VMSTAT_SWAP_RA_HIT = 127;</code>
     */
    public static final int VMSTAT_SWAP_RA_HIT_VALUE = 127;
    /**
     * <code>VMSTAT_WORKINGSET_RESTORE = 128;</code>
     */
    public static final int VMSTAT_WORKINGSET_RESTORE_VALUE = 128;


    public final int getNumber() {
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static VmstatCounters valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static VmstatCounters forNumber(int value) {
      switch (value) {
        case 0: return VMSTAT_UNSPECIFIED;
        case 1: return VMSTAT_NR_FREE_PAGES;
        case 2: return VMSTAT_NR_ALLOC_BATCH;
        case 3: return VMSTAT_NR_INACTIVE_ANON;
        case 4: return VMSTAT_NR_ACTIVE_ANON;
        case 5: return VMSTAT_NR_INACTIVE_FILE;
        case 6: return VMSTAT_NR_ACTIVE_FILE;
        case 7: return VMSTAT_NR_UNEVICTABLE;
        case 8: return VMSTAT_NR_MLOCK;
        case 9: return VMSTAT_NR_ANON_PAGES;
        case 10: return VMSTAT_NR_MAPPED;
        case 11: return VMSTAT_NR_FILE_PAGES;
        case 12: return VMSTAT_NR_DIRTY;
        case 13: return VMSTAT_NR_WRITEBACK;
        case 14: return VMSTAT_NR_SLAB_RECLAIMABLE;
        case 15: return VMSTAT_NR_SLAB_UNRECLAIMABLE;
        case 16: return VMSTAT_NR_PAGE_TABLE_PAGES;
        case 17: return VMSTAT_NR_KERNEL_STACK;
        case 18: return VMSTAT_NR_OVERHEAD;
        case 19: return VMSTAT_NR_UNSTABLE;
        case 20: return VMSTAT_NR_BOUNCE;
        case 21: return VMSTAT_NR_VMSCAN_WRITE;
        case 22: return VMSTAT_NR_VMSCAN_IMMEDIATE_RECLAIM;
        case 23: return VMSTAT_NR_WRITEBACK_TEMP;
        case 24: return VMSTAT_NR_ISOLATED_ANON;
        case 25: return VMSTAT_NR_ISOLATED_FILE;
        case 26: return VMSTAT_NR_SHMEM;
        case 27: return VMSTAT_NR_DIRTIED;
        case 28: return VMSTAT_NR_WRITTEN;
        case 29: return VMSTAT_NR_PAGES_SCANNED;
        case 30: return VMSTAT_WORKINGSET_REFAULT;
        case 31: return VMSTAT_WORKINGSET_ACTIVATE;
        case 32: return VMSTAT_WORKINGSET_NODERECLAIM;
        case 33: return VMSTAT_NR_ANON_TRANSPARENT_HUGEPAGES;
        case 34: return VMSTAT_NR_FREE_CMA;
        case 35: return VMSTAT_NR_SWAPCACHE;
        case 36: return VMSTAT_NR_DIRTY_THRESHOLD;
        case 37: return VMSTAT_NR_DIRTY_BACKGROUND_THRESHOLD;
        case 38: return VMSTAT_PGPGIN;
        case 39: return VMSTAT_PGPGOUT;
        case 40: return VMSTAT_PGPGOUTCLEAN;
        case 41: return VMSTAT_PSWPIN;
        case 42: return VMSTAT_PSWPOUT;
        case 43: return VMSTAT_PGALLOC_DMA;
        case 44: return VMSTAT_PGALLOC_NORMAL;
        case 45: return VMSTAT_PGALLOC_MOVABLE;
        case 46: return VMSTAT_PGFREE;
        case 47: return VMSTAT_PGACTIVATE;
        case 48: return VMSTAT_PGDEACTIVATE;
        case 49: return VMSTAT_PGFAULT;
        case 50: return VMSTAT_PGMAJFAULT;
        case 51: return VMSTAT_PGREFILL_DMA;
        case 52: return VMSTAT_PGREFILL_NORMAL;
        case 53: return VMSTAT_PGREFILL_MOVABLE;
        case 54: return VMSTAT_PGSTEAL_KSWAPD_DMA;
        case 55: return VMSTAT_PGSTEAL_KSWAPD_NORMAL;
        case 56: return VMSTAT_PGSTEAL_KSWAPD_MOVABLE;
        case 57: return VMSTAT_PGSTEAL_DIRECT_DMA;
        case 58: return VMSTAT_PGSTEAL_DIRECT_NORMAL;
        case 59: return VMSTAT_PGSTEAL_DIRECT_MOVABLE;
        case 60: return VMSTAT_PGSCAN_KSWAPD_DMA;
        case 61: return VMSTAT_PGSCAN_KSWAPD_NORMAL;
        case 62: return VMSTAT_PGSCAN_KSWAPD_MOVABLE;
        case 63: return VMSTAT_PGSCAN_DIRECT_DMA;
        case 64: return VMSTAT_PGSCAN_DIRECT_NORMAL;
        case 65: return VMSTAT_PGSCAN_DIRECT_MOVABLE;
        case 66: return VMSTAT_PGSCAN_DIRECT_THROTTLE;
        case 67: return VMSTAT_PGINODESTEAL;
        case 68: return VMSTAT_SLABS_SCANNED;
        case 69: return VMSTAT_KSWAPD_INODESTEAL;
        case 70: return VMSTAT_KSWAPD_LOW_WMARK_HIT_QUICKLY;
        case 71: return VMSTAT_KSWAPD_HIGH_WMARK_HIT_QUICKLY;
        case 72: return VMSTAT_PAGEOUTRUN;
        case 73: return VMSTAT_ALLOCSTALL;
        case 74: return VMSTAT_PGROTATED;
        case 75: return VMSTAT_DROP_PAGECACHE;
        case 76: return VMSTAT_DROP_SLAB;
        case 77: return VMSTAT_PGMIGRATE_SUCCESS;
        case 78: return VMSTAT_PGMIGRATE_FAIL;
        case 79: return VMSTAT_COMPACT_MIGRATE_SCANNED;
        case 80: return VMSTAT_COMPACT_FREE_SCANNED;
        case 81: return VMSTAT_COMPACT_ISOLATED;
        case 82: return VMSTAT_COMPACT_STALL;
        case 83: return VMSTAT_COMPACT_FAIL;
        case 84: return VMSTAT_COMPACT_SUCCESS;
        case 85: return VMSTAT_COMPACT_DAEMON_WAKE;
        case 86: return VMSTAT_UNEVICTABLE_PGS_CULLED;
        case 87: return VMSTAT_UNEVICTABLE_PGS_SCANNED;
        case 88: return VMSTAT_UNEVICTABLE_PGS_RESCUED;
        case 89: return VMSTAT_UNEVICTABLE_PGS_MLOCKED;
        case 90: return VMSTAT_UNEVICTABLE_PGS_MUNLOCKED;
        case 91: return VMSTAT_UNEVICTABLE_PGS_CLEARED;
        case 92: return VMSTAT_UNEVICTABLE_PGS_STRANDED;
        case 93: return VMSTAT_NR_ZSPAGES;
        case 94: return VMSTAT_NR_ION_HEAP;
        case 95: return VMSTAT_NR_GPU_HEAP;
        case 96: return VMSTAT_ALLOCSTALL_DMA;
        case 97: return VMSTAT_ALLOCSTALL_MOVABLE;
        case 98: return VMSTAT_ALLOCSTALL_NORMAL;
        case 99: return VMSTAT_COMPACT_DAEMON_FREE_SCANNED;
        case 100: return VMSTAT_COMPACT_DAEMON_MIGRATE_SCANNED;
        case 101: return VMSTAT_NR_FASTRPC;
        case 102: return VMSTAT_NR_INDIRECTLY_RECLAIMABLE;
        case 103: return VMSTAT_NR_ION_HEAP_POOL;
        case 104: return VMSTAT_NR_KERNEL_MISC_RECLAIMABLE;
        case 105: return VMSTAT_NR_SHADOW_CALL_STACK_BYTES;
        case 106: return VMSTAT_NR_SHMEM_HUGEPAGES;
        case 107: return VMSTAT_NR_SHMEM_PMDMAPPED;
        case 108: return VMSTAT_NR_UNRECLAIMABLE_PAGES;
        case 109: return VMSTAT_NR_ZONE_ACTIVE_ANON;
        case 110: return VMSTAT_NR_ZONE_ACTIVE_FILE;
        case 111: return VMSTAT_NR_ZONE_INACTIVE_ANON;
        case 112: return VMSTAT_NR_ZONE_INACTIVE_FILE;
        case 113: return VMSTAT_NR_ZONE_UNEVICTABLE;
        case 114: return VMSTAT_NR_ZONE_WRITE_PENDING;
        case 115: return VMSTAT_OOM_KILL;
        case 116: return VMSTAT_PGLAZYFREE;
        case 117: return VMSTAT_PGLAZYFREED;
        case 118: return VMSTAT_PGREFILL;
        case 119: return VMSTAT_PGSCAN_DIRECT;
        case 120: return VMSTAT_PGSCAN_KSWAPD;
        case 121: return VMSTAT_PGSKIP_DMA;
        case 122: return VMSTAT_PGSKIP_MOVABLE;
        case 123: return VMSTAT_PGSKIP_NORMAL;
        case 124: return VMSTAT_PGSTEAL_DIRECT;
        case 125: return VMSTAT_PGSTEAL_KSWAPD;
        case 126: return VMSTAT_SWAP_RA;
        case 127: return VMSTAT_SWAP_RA_HIT;
        case 128: return VMSTAT_WORKINGSET_RESTORE;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<VmstatCounters>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        VmstatCounters> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<VmstatCounters>() {
            public VmstatCounters findValueByNumber(int number) {
              return VmstatCounters.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return perfetto.protos.SysStatsCounters.getDescriptor().getEnumTypes().get(1);
    }

    private static final VmstatCounters[] VALUES = values();

    public static VmstatCounters valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private VmstatCounters(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:perfetto.protos.VmstatCounters)
  }


  public static com.google.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
    return descriptor;
  }
  private static  com.google.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
    java.lang.String[] descriptorData = {
      "\n/protos/perfetto/common/sys_stats_count" +
      "ers.proto\022\017perfetto.protos*\277\006\n\017MeminfoCo" +
      "unters\022\027\n\023MEMINFO_UNSPECIFIED\020\000\022\025\n\021MEMIN" +
      "FO_MEM_TOTAL\020\001\022\024\n\020MEMINFO_MEM_FREE\020\002\022\031\n\025" +
      "MEMINFO_MEM_AVAILABLE\020\003\022\023\n\017MEMINFO_BUFFE" +
      "RS\020\004\022\022\n\016MEMINFO_CACHED\020\005\022\027\n\023MEMINFO_SWAP" +
      "_CACHED\020\006\022\022\n\016MEMINFO_ACTIVE\020\007\022\024\n\020MEMINFO" +
      "_INACTIVE\020\010\022\027\n\023MEMINFO_ACTIVE_ANON\020\t\022\031\n\025" +
      "MEMINFO_INACTIVE_ANON\020\n\022\027\n\023MEMINFO_ACTIV" +
      "E_FILE\020\013\022\031\n\025MEMINFO_INACTIVE_FILE\020\014\022\027\n\023M" +
      "EMINFO_UNEVICTABLE\020\r\022\023\n\017MEMINFO_MLOCKED\020" +
      "\016\022\026\n\022MEMINFO_SWAP_TOTAL\020\017\022\025\n\021MEMINFO_SWA" +
      "P_FREE\020\020\022\021\n\rMEMINFO_DIRTY\020\021\022\025\n\021MEMINFO_W" +
      "RITEBACK\020\022\022\026\n\022MEMINFO_ANON_PAGES\020\023\022\022\n\016ME" +
      "MINFO_MAPPED\020\024\022\021\n\rMEMINFO_SHMEM\020\025\022\020\n\014MEM" +
      "INFO_SLAB\020\026\022\034\n\030MEMINFO_SLAB_RECLAIMABLE\020" +
      "\027\022\036\n\032MEMINFO_SLAB_UNRECLAIMABLE\020\030\022\030\n\024MEM" +
      "INFO_KERNEL_STACK\020\031\022\027\n\023MEMINFO_PAGE_TABL" +
      "ES\020\032\022\030\n\024MEMINFO_COMMIT_LIMIT\020\033\022\027\n\023MEMINF" +
      "O_COMMITED_AS\020\034\022\031\n\025MEMINFO_VMALLOC_TOTAL" +
      "\020\035\022\030\n\024MEMINFO_VMALLOC_USED\020\036\022\031\n\025MEMINFO_" +
      "VMALLOC_CHUNK\020\037\022\025\n\021MEMINFO_CMA_TOTAL\020 \022\024" +
      "\n\020MEMINFO_CMA_FREE\020!*\233\035\n\016VmstatCounters\022" +
      "\026\n\022VMSTAT_UNSPECIFIED\020\000\022\030\n\024VMSTAT_NR_FRE" +
      "E_PAGES\020\001\022\031\n\025VMSTAT_NR_ALLOC_BATCH\020\002\022\033\n\027" +
      "VMSTAT_NR_INACTIVE_ANON\020\003\022\031\n\025VMSTAT_NR_A" +
      "CTIVE_ANON\020\004\022\033\n\027VMSTAT_NR_INACTIVE_FILE\020" +
      "\005\022\031\n\025VMSTAT_NR_ACTIVE_FILE\020\006\022\031\n\025VMSTAT_N" +
      "R_UNEVICTABLE\020\007\022\023\n\017VMSTAT_NR_MLOCK\020\010\022\030\n\024" +
      "VMSTAT_NR_ANON_PAGES\020\t\022\024\n\020VMSTAT_NR_MAPP" +
      "ED\020\n\022\030\n\024VMSTAT_NR_FILE_PAGES\020\013\022\023\n\017VMSTAT" +
      "_NR_DIRTY\020\014\022\027\n\023VMSTAT_NR_WRITEBACK\020\r\022\036\n\032" +
      "VMSTAT_NR_SLAB_RECLAIMABLE\020\016\022 \n\034VMSTAT_N" +
      "R_SLAB_UNRECLAIMABLE\020\017\022\036\n\032VMSTAT_NR_PAGE" +
      "_TABLE_PAGES\020\020\022\032\n\026VMSTAT_NR_KERNEL_STACK" +
      "\020\021\022\026\n\022VMSTAT_NR_OVERHEAD\020\022\022\026\n\022VMSTAT_NR_" +
      "UNSTABLE\020\023\022\024\n\020VMSTAT_NR_BOUNCE\020\024\022\032\n\026VMST" +
      "AT_NR_VMSCAN_WRITE\020\025\022&\n\"VMSTAT_NR_VMSCAN" +
      "_IMMEDIATE_RECLAIM\020\026\022\034\n\030VMSTAT_NR_WRITEB" +
      "ACK_TEMP\020\027\022\033\n\027VMSTAT_NR_ISOLATED_ANON\020\030\022" +
      "\033\n\027VMSTAT_NR_ISOLATED_FILE\020\031\022\023\n\017VMSTAT_N" +
      "R_SHMEM\020\032\022\025\n\021VMSTAT_NR_DIRTIED\020\033\022\025\n\021VMST" +
      "AT_NR_WRITTEN\020\034\022\033\n\027VMSTAT_NR_PAGES_SCANN" +
      "ED\020\035\022\035\n\031VMSTAT_WORKINGSET_REFAULT\020\036\022\036\n\032V" +
      "MSTAT_WORKINGSET_ACTIVATE\020\037\022!\n\035VMSTAT_WO" +
      "RKINGSET_NODERECLAIM\020 \022(\n$VMSTAT_NR_ANON" +
      "_TRANSPARENT_HUGEPAGES\020!\022\026\n\022VMSTAT_NR_FR" +
      "EE_CMA\020\"\022\027\n\023VMSTAT_NR_SWAPCACHE\020#\022\035\n\031VMS" +
      "TAT_NR_DIRTY_THRESHOLD\020$\022(\n$VMSTAT_NR_DI" +
      "RTY_BACKGROUND_THRESHOLD\020%\022\021\n\rVMSTAT_PGP" +
      "GIN\020&\022\022\n\016VMSTAT_PGPGOUT\020\'\022\027\n\023VMSTAT_PGPG" +
      "OUTCLEAN\020(\022\021\n\rVMSTAT_PSWPIN\020)\022\022\n\016VMSTAT_" +
      "PSWPOUT\020*\022\026\n\022VMSTAT_PGALLOC_DMA\020+\022\031\n\025VMS" +
      "TAT_PGALLOC_NORMAL\020,\022\032\n\026VMSTAT_PGALLOC_M" +
      "OVABLE\020-\022\021\n\rVMSTAT_PGFREE\020.\022\025\n\021VMSTAT_PG" +
      "ACTIVATE\020/\022\027\n\023VMSTAT_PGDEACTIVATE\0200\022\022\n\016V" +
      "MSTAT_PGFAULT\0201\022\025\n\021VMSTAT_PGMAJFAULT\0202\022\027" +
      "\n\023VMSTAT_PGREFILL_DMA\0203\022\032\n\026VMSTAT_PGREFI" +
      "LL_NORMAL\0204\022\033\n\027VMSTAT_PGREFILL_MOVABLE\0205" +
      "\022\035\n\031VMSTAT_PGSTEAL_KSWAPD_DMA\0206\022 \n\034VMSTA" +
      "T_PGSTEAL_KSWAPD_NORMAL\0207\022!\n\035VMSTAT_PGST" +
      "EAL_KSWAPD_MOVABLE\0208\022\035\n\031VMSTAT_PGSTEAL_D" +
      "IRECT_DMA\0209\022 \n\034VMSTAT_PGSTEAL_DIRECT_NOR" +
      "MAL\020:\022!\n\035VMSTAT_PGSTEAL_DIRECT_MOVABLE\020;" +
      "\022\034\n\030VMSTAT_PGSCAN_KSWAPD_DMA\020<\022\037\n\033VMSTAT" +
      "_PGSCAN_KSWAPD_NORMAL\020=\022 \n\034VMSTAT_PGSCAN" +
      "_KSWAPD_MOVABLE\020>\022\034\n\030VMSTAT_PGSCAN_DIREC" +
      "T_DMA\020?\022\037\n\033VMSTAT_PGSCAN_DIRECT_NORMAL\020@" +
      "\022 \n\034VMSTAT_PGSCAN_DIRECT_MOVABLE\020A\022!\n\035VM" +
      "STAT_PGSCAN_DIRECT_THROTTLE\020B\022\027\n\023VMSTAT_" +
      "PGINODESTEAL\020C\022\030\n\024VMSTAT_SLABS_SCANNED\020D" +
      "\022\034\n\030VMSTAT_KSWAPD_INODESTEAL\020E\022\'\n#VMSTAT" +
      "_KSWAPD_LOW_WMARK_HIT_QUICKLY\020F\022(\n$VMSTA" +
      "T_KSWAPD_HIGH_WMARK_HIT_QUICKLY\020G\022\025\n\021VMS" +
      "TAT_PAGEOUTRUN\020H\022\025\n\021VMSTAT_ALLOCSTALL\020I\022" +
      "\024\n\020VMSTAT_PGROTATED\020J\022\031\n\025VMSTAT_DROP_PAG" +
      "ECACHE\020K\022\024\n\020VMSTAT_DROP_SLAB\020L\022\034\n\030VMSTAT" +
      "_PGMIGRATE_SUCCESS\020M\022\031\n\025VMSTAT_PGMIGRATE" +
      "_FAIL\020N\022\"\n\036VMSTAT_COMPACT_MIGRATE_SCANNE" +
      "D\020O\022\037\n\033VMSTAT_COMPACT_FREE_SCANNED\020P\022\033\n\027" +
      "VMSTAT_COMPACT_ISOLATED\020Q\022\030\n\024VMSTAT_COMP" +
      "ACT_STALL\020R\022\027\n\023VMSTAT_COMPACT_FAIL\020S\022\032\n\026" +
      "VMSTAT_COMPACT_SUCCESS\020T\022\036\n\032VMSTAT_COMPA" +
      "CT_DAEMON_WAKE\020U\022!\n\035VMSTAT_UNEVICTABLE_P" +
      "GS_CULLED\020V\022\"\n\036VMSTAT_UNEVICTABLE_PGS_SC" +
      "ANNED\020W\022\"\n\036VMSTAT_UNEVICTABLE_PGS_RESCUE" +
      "D\020X\022\"\n\036VMSTAT_UNEVICTABLE_PGS_MLOCKED\020Y\022" +
      "$\n VMSTAT_UNEVICTABLE_PGS_MUNLOCKED\020Z\022\"\n" +
      "\036VMSTAT_UNEVICTABLE_PGS_CLEARED\020[\022#\n\037VMS" +
      "TAT_UNEVICTABLE_PGS_STRANDED\020\\\022\025\n\021VMSTAT" +
      "_NR_ZSPAGES\020]\022\026\n\022VMSTAT_NR_ION_HEAP\020^\022\026\n" +
      "\022VMSTAT_NR_GPU_HEAP\020_\022\031\n\025VMSTAT_ALLOCSTA" +
      "LL_DMA\020`\022\035\n\031VMSTAT_ALLOCSTALL_MOVABLE\020a\022" +
      "\034\n\030VMSTAT_ALLOCSTALL_NORMAL\020b\022&\n\"VMSTAT_" +
      "COMPACT_DAEMON_FREE_SCANNED\020c\022)\n%VMSTAT_" +
      "COMPACT_DAEMON_MIGRATE_SCANNED\020d\022\025\n\021VMST" +
      "AT_NR_FASTRPC\020e\022$\n VMSTAT_NR_INDIRECTLY_" +
      "RECLAIMABLE\020f\022\033\n\027VMSTAT_NR_ION_HEAP_POOL" +
      "\020g\022%\n!VMSTAT_NR_KERNEL_MISC_RECLAIMABLE\020" +
      "h\022%\n!VMSTAT_NR_SHADOW_CALL_STACK_BYTES\020i" +
      "\022\035\n\031VMSTAT_NR_SHMEM_HUGEPAGES\020j\022\035\n\031VMSTA" +
      "T_NR_SHMEM_PMDMAPPED\020k\022!\n\035VMSTAT_NR_UNRE" +
      "CLAIMABLE_PAGES\020l\022\036\n\032VMSTAT_NR_ZONE_ACTI" +
      "VE_ANON\020m\022\036\n\032VMSTAT_NR_ZONE_ACTIVE_FILE\020" +
      "n\022 \n\034VMSTAT_NR_ZONE_INACTIVE_ANON\020o\022 \n\034V" +
      "MSTAT_NR_ZONE_INACTIVE_FILE\020p\022\036\n\032VMSTAT_" +
      "NR_ZONE_UNEVICTABLE\020q\022 \n\034VMSTAT_NR_ZONE_" +
      "WRITE_PENDING\020r\022\023\n\017VMSTAT_OOM_KILL\020s\022\025\n\021" +
      "VMSTAT_PGLAZYFREE\020t\022\026\n\022VMSTAT_PGLAZYFREE" +
      "D\020u\022\023\n\017VMSTAT_PGREFILL\020v\022\030\n\024VMSTAT_PGSCA" +
      "N_DIRECT\020w\022\030\n\024VMSTAT_PGSCAN_KSWAPD\020x\022\025\n\021" +
      "VMSTAT_PGSKIP_DMA\020y\022\031\n\025VMSTAT_PGSKIP_MOV" +
      "ABLE\020z\022\030\n\024VMSTAT_PGSKIP_NORMAL\020{\022\031\n\025VMST" +
      "AT_PGSTEAL_DIRECT\020|\022\031\n\025VMSTAT_PGSTEAL_KS" +
      "WAPD\020}\022\022\n\016VMSTAT_SWAP_RA\020~\022\026\n\022VMSTAT_SWA" +
      "P_RA_HIT\020\177\022\036\n\031VMSTAT_WORKINGSET_RESTORE\020" +
      "\200\001"
    };
    descriptor = com.google.protobuf.Descriptors.FileDescriptor
      .internalBuildGeneratedFileFrom(descriptorData,
        new com.google.protobuf.Descriptors.FileDescriptor[] {
        });
  }

  // @@protoc_insertion_point(outer_class_scope)
}
