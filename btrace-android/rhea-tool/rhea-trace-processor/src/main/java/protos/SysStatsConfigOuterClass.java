// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/config/sys_stats/sys_stats_config.proto

package perfetto.protos;

public final class SysStatsConfigOuterClass {
  private SysStatsConfigOuterClass() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }

  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistry registry) {
    registerAllExtensions(
        (com.google.protobuf.ExtensionRegistryLite) registry);
  }
  public interface SysStatsConfigOrBuilder extends
      // @@protoc_insertion_point(interface_extends:perfetto.protos.SysStatsConfig)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Polls /proc/meminfo every X ms, if non-zero.
     * This is required to be &gt; 10ms to avoid excessive CPU usage.
     * Cost: 0.3 ms [read] + 0.07 ms [parse + trace injection]
     * </pre>
     *
     * <code>optional uint32 meminfo_period_ms = 1;</code>
     * @return Whether the meminfoPeriodMs field is set.
     */
    boolean hasMeminfoPeriodMs();
    /**
     * <pre>
     * Polls /proc/meminfo every X ms, if non-zero.
     * This is required to be &gt; 10ms to avoid excessive CPU usage.
     * Cost: 0.3 ms [read] + 0.07 ms [parse + trace injection]
     * </pre>
     *
     * <code>optional uint32 meminfo_period_ms = 1;</code>
     * @return The meminfoPeriodMs.
     */
    int getMeminfoPeriodMs();

    /**
     * <pre>
     * If empty all known counters are reported. Otherwise, only the counters
     * specified below are reported.
     * </pre>
     *
     * <code>repeated .perfetto.protos.MeminfoCounters meminfo_counters = 2;</code>
     * @return A list containing the meminfoCounters.
     */
    java.util.List<perfetto.protos.SysStatsCounters.MeminfoCounters> getMeminfoCountersList();
    /**
     * <pre>
     * If empty all known counters are reported. Otherwise, only the counters
     * specified below are reported.
     * </pre>
     *
     * <code>repeated .perfetto.protos.MeminfoCounters meminfo_counters = 2;</code>
     * @return The count of meminfoCounters.
     */
    int getMeminfoCountersCount();
    /**
     * <pre>
     * If empty all known counters are reported. Otherwise, only the counters
     * specified below are reported.
     * </pre>
     *
     * <code>repeated .perfetto.protos.MeminfoCounters meminfo_counters = 2;</code>
     * @param index The index of the element to return.
     * @return The meminfoCounters at the given index.
     */
    perfetto.protos.SysStatsCounters.MeminfoCounters getMeminfoCounters(int index);

    /**
     * <pre>
     * Polls /proc/vmstat every X ms, if non-zero.
     * This is required to be &gt; 10ms to avoid excessive CPU usage.
     * Cost: 0.2 ms [read] + 0.3 ms [parse + trace injection]
     * </pre>
     *
     * <code>optional uint32 vmstat_period_ms = 3;</code>
     * @return Whether the vmstatPeriodMs field is set.
     */
    boolean hasVmstatPeriodMs();
    /**
     * <pre>
     * Polls /proc/vmstat every X ms, if non-zero.
     * This is required to be &gt; 10ms to avoid excessive CPU usage.
     * Cost: 0.2 ms [read] + 0.3 ms [parse + trace injection]
     * </pre>
     *
     * <code>optional uint32 vmstat_period_ms = 3;</code>
     * @return The vmstatPeriodMs.
     */
    int getVmstatPeriodMs();

    /**
     * <code>repeated .perfetto.protos.VmstatCounters vmstat_counters = 4;</code>
     * @return A list containing the vmstatCounters.
     */
    java.util.List<perfetto.protos.SysStatsCounters.VmstatCounters> getVmstatCountersList();
    /**
     * <code>repeated .perfetto.protos.VmstatCounters vmstat_counters = 4;</code>
     * @return The count of vmstatCounters.
     */
    int getVmstatCountersCount();
    /**
     * <code>repeated .perfetto.protos.VmstatCounters vmstat_counters = 4;</code>
     * @param index The index of the element to return.
     * @return The vmstatCounters at the given index.
     */
    perfetto.protos.SysStatsCounters.VmstatCounters getVmstatCounters(int index);

    /**
     * <pre>
     * Pols /proc/stat every X ms, if non-zero.
     * This is required to be &gt; 10ms to avoid excessive CPU usage.
     * Cost: 4.1 ms [read] + 1.9 ms [parse + trace injection]
     * </pre>
     *
     * <code>optional uint32 stat_period_ms = 5;</code>
     * @return Whether the statPeriodMs field is set.
     */
    boolean hasStatPeriodMs();
    /**
     * <pre>
     * Pols /proc/stat every X ms, if non-zero.
     * This is required to be &gt; 10ms to avoid excessive CPU usage.
     * Cost: 4.1 ms [read] + 1.9 ms [parse + trace injection]
     * </pre>
     *
     * <code>optional uint32 stat_period_ms = 5;</code>
     * @return The statPeriodMs.
     */
    int getStatPeriodMs();

    /**
     * <code>repeated .perfetto.protos.SysStatsConfig.StatCounters stat_counters = 6;</code>
     * @return A list containing the statCounters.
     */
    java.util.List<perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig.StatCounters> getStatCountersList();
    /**
     * <code>repeated .perfetto.protos.SysStatsConfig.StatCounters stat_counters = 6;</code>
     * @return The count of statCounters.
     */
    int getStatCountersCount();
    /**
     * <code>repeated .perfetto.protos.SysStatsConfig.StatCounters stat_counters = 6;</code>
     * @param index The index of the element to return.
     * @return The statCounters at the given index.
     */
    perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig.StatCounters getStatCounters(int index);

    /**
     * <pre>
     * Polls /sys/devfreq/&#42;&#47;curfreq every X ms, if non-zero.
     * This is required to be &gt; 10ms to avoid excessive CPU usage.
     * This option can be used to record unchanging values.
     * Updates from frequency changes can come from ftrace/set_clock_rate.
     * </pre>
     *
     * <code>optional uint32 devfreq_period_ms = 7;</code>
     * @return Whether the devfreqPeriodMs field is set.
     */
    boolean hasDevfreqPeriodMs();
    /**
     * <pre>
     * Polls /sys/devfreq/&#42;&#47;curfreq every X ms, if non-zero.
     * This is required to be &gt; 10ms to avoid excessive CPU usage.
     * This option can be used to record unchanging values.
     * Updates from frequency changes can come from ftrace/set_clock_rate.
     * </pre>
     *
     * <code>optional uint32 devfreq_period_ms = 7;</code>
     * @return The devfreqPeriodMs.
     */
    int getDevfreqPeriodMs();

    /**
     * <pre>
     * Polls /sys/devices/system/cpu/cpu*&#47;cpufreq/cpuinfo_cur_freq every X ms.
     * This is required to be &gt; 10ms to avoid excessive CPU usage.
     * </pre>
     *
     * <code>optional uint32 cpufreq_period_ms = 8;</code>
     * @return Whether the cpufreqPeriodMs field is set.
     */
    boolean hasCpufreqPeriodMs();
    /**
     * <pre>
     * Polls /sys/devices/system/cpu/cpu*&#47;cpufreq/cpuinfo_cur_freq every X ms.
     * This is required to be &gt; 10ms to avoid excessive CPU usage.
     * </pre>
     *
     * <code>optional uint32 cpufreq_period_ms = 8;</code>
     * @return The cpufreqPeriodMs.
     */
    int getCpufreqPeriodMs();

    /**
     * <pre>
     * Polls /proc/buddyinfo every X ms, if non-zero.
     * This is required to be &gt; 10ms to avoid excessive CPU usage.
     * </pre>
     *
     * <code>optional uint32 buddyinfo_period_ms = 9;</code>
     * @return Whether the buddyinfoPeriodMs field is set.
     */
    boolean hasBuddyinfoPeriodMs();
    /**
     * <pre>
     * Polls /proc/buddyinfo every X ms, if non-zero.
     * This is required to be &gt; 10ms to avoid excessive CPU usage.
     * </pre>
     *
     * <code>optional uint32 buddyinfo_period_ms = 9;</code>
     * @return The buddyinfoPeriodMs.
     */
    int getBuddyinfoPeriodMs();

    /**
     * <pre>
     * Polls /proc/diskstats every X ms, if non-zero.
     * This is required to be &gt; 10ms to avoid excessive CPU usage.
     * </pre>
     *
     * <code>optional uint32 diskstat_period_ms = 10;</code>
     * @return Whether the diskstatPeriodMs field is set.
     */
    boolean hasDiskstatPeriodMs();
    /**
     * <pre>
     * Polls /proc/diskstats every X ms, if non-zero.
     * This is required to be &gt; 10ms to avoid excessive CPU usage.
     * </pre>
     *
     * <code>optional uint32 diskstat_period_ms = 10;</code>
     * @return The diskstatPeriodMs.
     */
    int getDiskstatPeriodMs();
  }
  /**
   * <pre>
   * This file defines the configuration for the Linux /proc poller data source,
   * which injects counters in the trace.
   * Counters that are needed in the trace must be explicitly listed in the
   * *_counters fields. This is to avoid spamming the trace with all counters
   * at all times.
   * The sampling rate is configurable. All polling rates (*_period_ms) need
   * to be integer multiples of each other.
   * OK:     [10ms, 10ms, 10ms],  [10ms, 20ms, 10ms],  [10ms, 20ms, 60ms]
   * Not OK: [10ms, 10ms, 11ms],  [10ms, 15ms, 20ms]
   * </pre>
   *
   * Protobuf type {@code perfetto.protos.SysStatsConfig}
   */
  public static final class SysStatsConfig extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:perfetto.protos.SysStatsConfig)
      SysStatsConfigOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use SysStatsConfig.newBuilder() to construct.
    private SysStatsConfig(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private SysStatsConfig() {
      meminfoCounters_ = java.util.Collections.emptyList();
      vmstatCounters_ = java.util.Collections.emptyList();
      statCounters_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new SysStatsConfig();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return perfetto.protos.SysStatsConfigOuterClass.internal_static_perfetto_protos_SysStatsConfig_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return perfetto.protos.SysStatsConfigOuterClass.internal_static_perfetto_protos_SysStatsConfig_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig.class, perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig.Builder.class);
    }

    /**
     * Protobuf enum {@code perfetto.protos.SysStatsConfig.StatCounters}
     */
    public enum StatCounters
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <code>STAT_UNSPECIFIED = 0;</code>
       */
      STAT_UNSPECIFIED(0),
      /**
       * <code>STAT_CPU_TIMES = 1;</code>
       */
      STAT_CPU_TIMES(1),
      /**
       * <code>STAT_IRQ_COUNTS = 2;</code>
       */
      STAT_IRQ_COUNTS(2),
      /**
       * <code>STAT_SOFTIRQ_COUNTS = 3;</code>
       */
      STAT_SOFTIRQ_COUNTS(3),
      /**
       * <code>STAT_FORK_COUNT = 4;</code>
       */
      STAT_FORK_COUNT(4),
      ;

      /**
       * <code>STAT_UNSPECIFIED = 0;</code>
       */
      public static final int STAT_UNSPECIFIED_VALUE = 0;
      /**
       * <code>STAT_CPU_TIMES = 1;</code>
       */
      public static final int STAT_CPU_TIMES_VALUE = 1;
      /**
       * <code>STAT_IRQ_COUNTS = 2;</code>
       */
      public static final int STAT_IRQ_COUNTS_VALUE = 2;
      /**
       * <code>STAT_SOFTIRQ_COUNTS = 3;</code>
       */
      public static final int STAT_SOFTIRQ_COUNTS_VALUE = 3;
      /**
       * <code>STAT_FORK_COUNT = 4;</code>
       */
      public static final int STAT_FORK_COUNT_VALUE = 4;


      public final int getNumber() {
        return value;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static StatCounters valueOf(int value) {
        return forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       */
      public static StatCounters forNumber(int value) {
        switch (value) {
          case 0: return STAT_UNSPECIFIED;
          case 1: return STAT_CPU_TIMES;
          case 2: return STAT_IRQ_COUNTS;
          case 3: return STAT_SOFTIRQ_COUNTS;
          case 4: return STAT_FORK_COUNT;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<StatCounters>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          StatCounters> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<StatCounters>() {
              public StatCounters findValueByNumber(int number) {
                return StatCounters.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig.getDescriptor().getEnumTypes().get(0);
      }

      private static final StatCounters[] VALUES = values();

      public static StatCounters valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private StatCounters(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:perfetto.protos.SysStatsConfig.StatCounters)
    }

    private int bitField0_;
    public static final int MEMINFO_PERIOD_MS_FIELD_NUMBER = 1;
    private int meminfoPeriodMs_ = 0;
    /**
     * <pre>
     * Polls /proc/meminfo every X ms, if non-zero.
     * This is required to be &gt; 10ms to avoid excessive CPU usage.
     * Cost: 0.3 ms [read] + 0.07 ms [parse + trace injection]
     * </pre>
     *
     * <code>optional uint32 meminfo_period_ms = 1;</code>
     * @return Whether the meminfoPeriodMs field is set.
     */
    @java.lang.Override
    public boolean hasMeminfoPeriodMs() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Polls /proc/meminfo every X ms, if non-zero.
     * This is required to be &gt; 10ms to avoid excessive CPU usage.
     * Cost: 0.3 ms [read] + 0.07 ms [parse + trace injection]
     * </pre>
     *
     * <code>optional uint32 meminfo_period_ms = 1;</code>
     * @return The meminfoPeriodMs.
     */
    @java.lang.Override
    public int getMeminfoPeriodMs() {
      return meminfoPeriodMs_;
    }

    public static final int MEMINFO_COUNTERS_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private java.util.List<java.lang.Integer> meminfoCounters_;
    private static final com.google.protobuf.Internal.ListAdapter.Converter<
        java.lang.Integer, perfetto.protos.SysStatsCounters.MeminfoCounters> meminfoCounters_converter_ =
            new com.google.protobuf.Internal.ListAdapter.Converter<
                java.lang.Integer, perfetto.protos.SysStatsCounters.MeminfoCounters>() {
              public perfetto.protos.SysStatsCounters.MeminfoCounters convert(java.lang.Integer from) {
                perfetto.protos.SysStatsCounters.MeminfoCounters result = perfetto.protos.SysStatsCounters.MeminfoCounters.forNumber(from);
                return result == null ? perfetto.protos.SysStatsCounters.MeminfoCounters.MEMINFO_UNSPECIFIED : result;
              }
            };
    /**
     * <pre>
     * If empty all known counters are reported. Otherwise, only the counters
     * specified below are reported.
     * </pre>
     *
     * <code>repeated .perfetto.protos.MeminfoCounters meminfo_counters = 2;</code>
     * @return A list containing the meminfoCounters.
     */
    @java.lang.Override
    public java.util.List<perfetto.protos.SysStatsCounters.MeminfoCounters> getMeminfoCountersList() {
      return new com.google.protobuf.Internal.ListAdapter<
          java.lang.Integer, perfetto.protos.SysStatsCounters.MeminfoCounters>(meminfoCounters_, meminfoCounters_converter_);
    }
    /**
     * <pre>
     * If empty all known counters are reported. Otherwise, only the counters
     * specified below are reported.
     * </pre>
     *
     * <code>repeated .perfetto.protos.MeminfoCounters meminfo_counters = 2;</code>
     * @return The count of meminfoCounters.
     */
    @java.lang.Override
    public int getMeminfoCountersCount() {
      return meminfoCounters_.size();
    }
    /**
     * <pre>
     * If empty all known counters are reported. Otherwise, only the counters
     * specified below are reported.
     * </pre>
     *
     * <code>repeated .perfetto.protos.MeminfoCounters meminfo_counters = 2;</code>
     * @param index The index of the element to return.
     * @return The meminfoCounters at the given index.
     */
    @java.lang.Override
    public perfetto.protos.SysStatsCounters.MeminfoCounters getMeminfoCounters(int index) {
      return meminfoCounters_converter_.convert(meminfoCounters_.get(index));
    }

    public static final int VMSTAT_PERIOD_MS_FIELD_NUMBER = 3;
    private int vmstatPeriodMs_ = 0;
    /**
     * <pre>
     * Polls /proc/vmstat every X ms, if non-zero.
     * This is required to be &gt; 10ms to avoid excessive CPU usage.
     * Cost: 0.2 ms [read] + 0.3 ms [parse + trace injection]
     * </pre>
     *
     * <code>optional uint32 vmstat_period_ms = 3;</code>
     * @return Whether the vmstatPeriodMs field is set.
     */
    @java.lang.Override
    public boolean hasVmstatPeriodMs() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Polls /proc/vmstat every X ms, if non-zero.
     * This is required to be &gt; 10ms to avoid excessive CPU usage.
     * Cost: 0.2 ms [read] + 0.3 ms [parse + trace injection]
     * </pre>
     *
     * <code>optional uint32 vmstat_period_ms = 3;</code>
     * @return The vmstatPeriodMs.
     */
    @java.lang.Override
    public int getVmstatPeriodMs() {
      return vmstatPeriodMs_;
    }

    public static final int VMSTAT_COUNTERS_FIELD_NUMBER = 4;
    @SuppressWarnings("serial")
    private java.util.List<java.lang.Integer> vmstatCounters_;
    private static final com.google.protobuf.Internal.ListAdapter.Converter<
        java.lang.Integer, perfetto.protos.SysStatsCounters.VmstatCounters> vmstatCounters_converter_ =
            new com.google.protobuf.Internal.ListAdapter.Converter<
                java.lang.Integer, perfetto.protos.SysStatsCounters.VmstatCounters>() {
              public perfetto.protos.SysStatsCounters.VmstatCounters convert(java.lang.Integer from) {
                perfetto.protos.SysStatsCounters.VmstatCounters result = perfetto.protos.SysStatsCounters.VmstatCounters.forNumber(from);
                return result == null ? perfetto.protos.SysStatsCounters.VmstatCounters.VMSTAT_UNSPECIFIED : result;
              }
            };
    /**
     * <code>repeated .perfetto.protos.VmstatCounters vmstat_counters = 4;</code>
     * @return A list containing the vmstatCounters.
     */
    @java.lang.Override
    public java.util.List<perfetto.protos.SysStatsCounters.VmstatCounters> getVmstatCountersList() {
      return new com.google.protobuf.Internal.ListAdapter<
          java.lang.Integer, perfetto.protos.SysStatsCounters.VmstatCounters>(vmstatCounters_, vmstatCounters_converter_);
    }
    /**
     * <code>repeated .perfetto.protos.VmstatCounters vmstat_counters = 4;</code>
     * @return The count of vmstatCounters.
     */
    @java.lang.Override
    public int getVmstatCountersCount() {
      return vmstatCounters_.size();
    }
    /**
     * <code>repeated .perfetto.protos.VmstatCounters vmstat_counters = 4;</code>
     * @param index The index of the element to return.
     * @return The vmstatCounters at the given index.
     */
    @java.lang.Override
    public perfetto.protos.SysStatsCounters.VmstatCounters getVmstatCounters(int index) {
      return vmstatCounters_converter_.convert(vmstatCounters_.get(index));
    }

    public static final int STAT_PERIOD_MS_FIELD_NUMBER = 5;
    private int statPeriodMs_ = 0;
    /**
     * <pre>
     * Pols /proc/stat every X ms, if non-zero.
     * This is required to be &gt; 10ms to avoid excessive CPU usage.
     * Cost: 4.1 ms [read] + 1.9 ms [parse + trace injection]
     * </pre>
     *
     * <code>optional uint32 stat_period_ms = 5;</code>
     * @return Whether the statPeriodMs field is set.
     */
    @java.lang.Override
    public boolean hasStatPeriodMs() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * Pols /proc/stat every X ms, if non-zero.
     * This is required to be &gt; 10ms to avoid excessive CPU usage.
     * Cost: 4.1 ms [read] + 1.9 ms [parse + trace injection]
     * </pre>
     *
     * <code>optional uint32 stat_period_ms = 5;</code>
     * @return The statPeriodMs.
     */
    @java.lang.Override
    public int getStatPeriodMs() {
      return statPeriodMs_;
    }

    public static final int STAT_COUNTERS_FIELD_NUMBER = 6;
    @SuppressWarnings("serial")
    private java.util.List<java.lang.Integer> statCounters_;
    private static final com.google.protobuf.Internal.ListAdapter.Converter<
        java.lang.Integer, perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig.StatCounters> statCounters_converter_ =
            new com.google.protobuf.Internal.ListAdapter.Converter<
                java.lang.Integer, perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig.StatCounters>() {
              public perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig.StatCounters convert(java.lang.Integer from) {
                perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig.StatCounters result = perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig.StatCounters.forNumber(from);
                return result == null ? perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig.StatCounters.STAT_UNSPECIFIED : result;
              }
            };
    /**
     * <code>repeated .perfetto.protos.SysStatsConfig.StatCounters stat_counters = 6;</code>
     * @return A list containing the statCounters.
     */
    @java.lang.Override
    public java.util.List<perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig.StatCounters> getStatCountersList() {
      return new com.google.protobuf.Internal.ListAdapter<
          java.lang.Integer, perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig.StatCounters>(statCounters_, statCounters_converter_);
    }
    /**
     * <code>repeated .perfetto.protos.SysStatsConfig.StatCounters stat_counters = 6;</code>
     * @return The count of statCounters.
     */
    @java.lang.Override
    public int getStatCountersCount() {
      return statCounters_.size();
    }
    /**
     * <code>repeated .perfetto.protos.SysStatsConfig.StatCounters stat_counters = 6;</code>
     * @param index The index of the element to return.
     * @return The statCounters at the given index.
     */
    @java.lang.Override
    public perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig.StatCounters getStatCounters(int index) {
      return statCounters_converter_.convert(statCounters_.get(index));
    }

    public static final int DEVFREQ_PERIOD_MS_FIELD_NUMBER = 7;
    private int devfreqPeriodMs_ = 0;
    /**
     * <pre>
     * Polls /sys/devfreq/&#42;&#47;curfreq every X ms, if non-zero.
     * This is required to be &gt; 10ms to avoid excessive CPU usage.
     * This option can be used to record unchanging values.
     * Updates from frequency changes can come from ftrace/set_clock_rate.
     * </pre>
     *
     * <code>optional uint32 devfreq_period_ms = 7;</code>
     * @return Whether the devfreqPeriodMs field is set.
     */
    @java.lang.Override
    public boolean hasDevfreqPeriodMs() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * Polls /sys/devfreq/&#42;&#47;curfreq every X ms, if non-zero.
     * This is required to be &gt; 10ms to avoid excessive CPU usage.
     * This option can be used to record unchanging values.
     * Updates from frequency changes can come from ftrace/set_clock_rate.
     * </pre>
     *
     * <code>optional uint32 devfreq_period_ms = 7;</code>
     * @return The devfreqPeriodMs.
     */
    @java.lang.Override
    public int getDevfreqPeriodMs() {
      return devfreqPeriodMs_;
    }

    public static final int CPUFREQ_PERIOD_MS_FIELD_NUMBER = 8;
    private int cpufreqPeriodMs_ = 0;
    /**
     * <pre>
     * Polls /sys/devices/system/cpu/cpu*&#47;cpufreq/cpuinfo_cur_freq every X ms.
     * This is required to be &gt; 10ms to avoid excessive CPU usage.
     * </pre>
     *
     * <code>optional uint32 cpufreq_period_ms = 8;</code>
     * @return Whether the cpufreqPeriodMs field is set.
     */
    @java.lang.Override
    public boolean hasCpufreqPeriodMs() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * Polls /sys/devices/system/cpu/cpu*&#47;cpufreq/cpuinfo_cur_freq every X ms.
     * This is required to be &gt; 10ms to avoid excessive CPU usage.
     * </pre>
     *
     * <code>optional uint32 cpufreq_period_ms = 8;</code>
     * @return The cpufreqPeriodMs.
     */
    @java.lang.Override
    public int getCpufreqPeriodMs() {
      return cpufreqPeriodMs_;
    }

    public static final int BUDDYINFO_PERIOD_MS_FIELD_NUMBER = 9;
    private int buddyinfoPeriodMs_ = 0;
    /**
     * <pre>
     * Polls /proc/buddyinfo every X ms, if non-zero.
     * This is required to be &gt; 10ms to avoid excessive CPU usage.
     * </pre>
     *
     * <code>optional uint32 buddyinfo_period_ms = 9;</code>
     * @return Whether the buddyinfoPeriodMs field is set.
     */
    @java.lang.Override
    public boolean hasBuddyinfoPeriodMs() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * Polls /proc/buddyinfo every X ms, if non-zero.
     * This is required to be &gt; 10ms to avoid excessive CPU usage.
     * </pre>
     *
     * <code>optional uint32 buddyinfo_period_ms = 9;</code>
     * @return The buddyinfoPeriodMs.
     */
    @java.lang.Override
    public int getBuddyinfoPeriodMs() {
      return buddyinfoPeriodMs_;
    }

    public static final int DISKSTAT_PERIOD_MS_FIELD_NUMBER = 10;
    private int diskstatPeriodMs_ = 0;
    /**
     * <pre>
     * Polls /proc/diskstats every X ms, if non-zero.
     * This is required to be &gt; 10ms to avoid excessive CPU usage.
     * </pre>
     *
     * <code>optional uint32 diskstat_period_ms = 10;</code>
     * @return Whether the diskstatPeriodMs field is set.
     */
    @java.lang.Override
    public boolean hasDiskstatPeriodMs() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <pre>
     * Polls /proc/diskstats every X ms, if non-zero.
     * This is required to be &gt; 10ms to avoid excessive CPU usage.
     * </pre>
     *
     * <code>optional uint32 diskstat_period_ms = 10;</code>
     * @return The diskstatPeriodMs.
     */
    @java.lang.Override
    public int getDiskstatPeriodMs() {
      return diskstatPeriodMs_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeUInt32(1, meminfoPeriodMs_);
      }
      for (int i = 0; i < meminfoCounters_.size(); i++) {
        output.writeEnum(2, meminfoCounters_.get(i));
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeUInt32(3, vmstatPeriodMs_);
      }
      for (int i = 0; i < vmstatCounters_.size(); i++) {
        output.writeEnum(4, vmstatCounters_.get(i));
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeUInt32(5, statPeriodMs_);
      }
      for (int i = 0; i < statCounters_.size(); i++) {
        output.writeEnum(6, statCounters_.get(i));
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        output.writeUInt32(7, devfreqPeriodMs_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        output.writeUInt32(8, cpufreqPeriodMs_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        output.writeUInt32(9, buddyinfoPeriodMs_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        output.writeUInt32(10, diskstatPeriodMs_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(1, meminfoPeriodMs_);
      }
      {
        int dataSize = 0;
        for (int i = 0; i < meminfoCounters_.size(); i++) {
          dataSize += com.google.protobuf.CodedOutputStream
            .computeEnumSizeNoTag(meminfoCounters_.get(i));
        }
        size += dataSize;
        size += 1 * meminfoCounters_.size();
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(3, vmstatPeriodMs_);
      }
      {
        int dataSize = 0;
        for (int i = 0; i < vmstatCounters_.size(); i++) {
          dataSize += com.google.protobuf.CodedOutputStream
            .computeEnumSizeNoTag(vmstatCounters_.get(i));
        }
        size += dataSize;
        size += 1 * vmstatCounters_.size();
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(5, statPeriodMs_);
      }
      {
        int dataSize = 0;
        for (int i = 0; i < statCounters_.size(); i++) {
          dataSize += com.google.protobuf.CodedOutputStream
            .computeEnumSizeNoTag(statCounters_.get(i));
        }
        size += dataSize;
        size += 1 * statCounters_.size();
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(7, devfreqPeriodMs_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(8, cpufreqPeriodMs_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(9, buddyinfoPeriodMs_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(10, diskstatPeriodMs_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig)) {
        return super.equals(obj);
      }
      perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig other = (perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig) obj;

      if (hasMeminfoPeriodMs() != other.hasMeminfoPeriodMs()) return false;
      if (hasMeminfoPeriodMs()) {
        if (getMeminfoPeriodMs()
            != other.getMeminfoPeriodMs()) return false;
      }
      if (!meminfoCounters_.equals(other.meminfoCounters_)) return false;
      if (hasVmstatPeriodMs() != other.hasVmstatPeriodMs()) return false;
      if (hasVmstatPeriodMs()) {
        if (getVmstatPeriodMs()
            != other.getVmstatPeriodMs()) return false;
      }
      if (!vmstatCounters_.equals(other.vmstatCounters_)) return false;
      if (hasStatPeriodMs() != other.hasStatPeriodMs()) return false;
      if (hasStatPeriodMs()) {
        if (getStatPeriodMs()
            != other.getStatPeriodMs()) return false;
      }
      if (!statCounters_.equals(other.statCounters_)) return false;
      if (hasDevfreqPeriodMs() != other.hasDevfreqPeriodMs()) return false;
      if (hasDevfreqPeriodMs()) {
        if (getDevfreqPeriodMs()
            != other.getDevfreqPeriodMs()) return false;
      }
      if (hasCpufreqPeriodMs() != other.hasCpufreqPeriodMs()) return false;
      if (hasCpufreqPeriodMs()) {
        if (getCpufreqPeriodMs()
            != other.getCpufreqPeriodMs()) return false;
      }
      if (hasBuddyinfoPeriodMs() != other.hasBuddyinfoPeriodMs()) return false;
      if (hasBuddyinfoPeriodMs()) {
        if (getBuddyinfoPeriodMs()
            != other.getBuddyinfoPeriodMs()) return false;
      }
      if (hasDiskstatPeriodMs() != other.hasDiskstatPeriodMs()) return false;
      if (hasDiskstatPeriodMs()) {
        if (getDiskstatPeriodMs()
            != other.getDiskstatPeriodMs()) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMeminfoPeriodMs()) {
        hash = (37 * hash) + MEMINFO_PERIOD_MS_FIELD_NUMBER;
        hash = (53 * hash) + getMeminfoPeriodMs();
      }
      if (getMeminfoCountersCount() > 0) {
        hash = (37 * hash) + MEMINFO_COUNTERS_FIELD_NUMBER;
        hash = (53 * hash) + meminfoCounters_.hashCode();
      }
      if (hasVmstatPeriodMs()) {
        hash = (37 * hash) + VMSTAT_PERIOD_MS_FIELD_NUMBER;
        hash = (53 * hash) + getVmstatPeriodMs();
      }
      if (getVmstatCountersCount() > 0) {
        hash = (37 * hash) + VMSTAT_COUNTERS_FIELD_NUMBER;
        hash = (53 * hash) + vmstatCounters_.hashCode();
      }
      if (hasStatPeriodMs()) {
        hash = (37 * hash) + STAT_PERIOD_MS_FIELD_NUMBER;
        hash = (53 * hash) + getStatPeriodMs();
      }
      if (getStatCountersCount() > 0) {
        hash = (37 * hash) + STAT_COUNTERS_FIELD_NUMBER;
        hash = (53 * hash) + statCounters_.hashCode();
      }
      if (hasDevfreqPeriodMs()) {
        hash = (37 * hash) + DEVFREQ_PERIOD_MS_FIELD_NUMBER;
        hash = (53 * hash) + getDevfreqPeriodMs();
      }
      if (hasCpufreqPeriodMs()) {
        hash = (37 * hash) + CPUFREQ_PERIOD_MS_FIELD_NUMBER;
        hash = (53 * hash) + getCpufreqPeriodMs();
      }
      if (hasBuddyinfoPeriodMs()) {
        hash = (37 * hash) + BUDDYINFO_PERIOD_MS_FIELD_NUMBER;
        hash = (53 * hash) + getBuddyinfoPeriodMs();
      }
      if (hasDiskstatPeriodMs()) {
        hash = (37 * hash) + DISKSTAT_PERIOD_MS_FIELD_NUMBER;
        hash = (53 * hash) + getDiskstatPeriodMs();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * This file defines the configuration for the Linux /proc poller data source,
     * which injects counters in the trace.
     * Counters that are needed in the trace must be explicitly listed in the
     * *_counters fields. This is to avoid spamming the trace with all counters
     * at all times.
     * The sampling rate is configurable. All polling rates (*_period_ms) need
     * to be integer multiples of each other.
     * OK:     [10ms, 10ms, 10ms],  [10ms, 20ms, 10ms],  [10ms, 20ms, 60ms]
     * Not OK: [10ms, 10ms, 11ms],  [10ms, 15ms, 20ms]
     * </pre>
     *
     * Protobuf type {@code perfetto.protos.SysStatsConfig}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:perfetto.protos.SysStatsConfig)
        perfetto.protos.SysStatsConfigOuterClass.SysStatsConfigOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return perfetto.protos.SysStatsConfigOuterClass.internal_static_perfetto_protos_SysStatsConfig_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return perfetto.protos.SysStatsConfigOuterClass.internal_static_perfetto_protos_SysStatsConfig_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig.class, perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig.Builder.class);
      }

      // Construct using perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        meminfoPeriodMs_ = 0;
        meminfoCounters_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000002);
        vmstatPeriodMs_ = 0;
        vmstatCounters_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000008);
        statPeriodMs_ = 0;
        statCounters_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000020);
        devfreqPeriodMs_ = 0;
        cpufreqPeriodMs_ = 0;
        buddyinfoPeriodMs_ = 0;
        diskstatPeriodMs_ = 0;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return perfetto.protos.SysStatsConfigOuterClass.internal_static_perfetto_protos_SysStatsConfig_descriptor;
      }

      @java.lang.Override
      public perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig getDefaultInstanceForType() {
        return perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig.getDefaultInstance();
      }

      @java.lang.Override
      public perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig build() {
        perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig buildPartial() {
        perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig result = new perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig result) {
        if (((bitField0_ & 0x00000002) != 0)) {
          meminfoCounters_ = java.util.Collections.unmodifiableList(meminfoCounters_);
          bitField0_ = (bitField0_ & ~0x00000002);
        }
        result.meminfoCounters_ = meminfoCounters_;
        if (((bitField0_ & 0x00000008) != 0)) {
          vmstatCounters_ = java.util.Collections.unmodifiableList(vmstatCounters_);
          bitField0_ = (bitField0_ & ~0x00000008);
        }
        result.vmstatCounters_ = vmstatCounters_;
        if (((bitField0_ & 0x00000020) != 0)) {
          statCounters_ = java.util.Collections.unmodifiableList(statCounters_);
          bitField0_ = (bitField0_ & ~0x00000020);
        }
        result.statCounters_ = statCounters_;
      }

      private void buildPartial0(perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.meminfoPeriodMs_ = meminfoPeriodMs_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.vmstatPeriodMs_ = vmstatPeriodMs_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.statPeriodMs_ = statPeriodMs_;
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000040) != 0)) {
          result.devfreqPeriodMs_ = devfreqPeriodMs_;
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000080) != 0)) {
          result.cpufreqPeriodMs_ = cpufreqPeriodMs_;
          to_bitField0_ |= 0x00000010;
        }
        if (((from_bitField0_ & 0x00000100) != 0)) {
          result.buddyinfoPeriodMs_ = buddyinfoPeriodMs_;
          to_bitField0_ |= 0x00000020;
        }
        if (((from_bitField0_ & 0x00000200) != 0)) {
          result.diskstatPeriodMs_ = diskstatPeriodMs_;
          to_bitField0_ |= 0x00000040;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig) {
          return mergeFrom((perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig other) {
        if (other == perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig.getDefaultInstance()) return this;
        if (other.hasMeminfoPeriodMs()) {
          setMeminfoPeriodMs(other.getMeminfoPeriodMs());
        }
        if (!other.meminfoCounters_.isEmpty()) {
          if (meminfoCounters_.isEmpty()) {
            meminfoCounters_ = other.meminfoCounters_;
            bitField0_ = (bitField0_ & ~0x00000002);
          } else {
            ensureMeminfoCountersIsMutable();
            meminfoCounters_.addAll(other.meminfoCounters_);
          }
          onChanged();
        }
        if (other.hasVmstatPeriodMs()) {
          setVmstatPeriodMs(other.getVmstatPeriodMs());
        }
        if (!other.vmstatCounters_.isEmpty()) {
          if (vmstatCounters_.isEmpty()) {
            vmstatCounters_ = other.vmstatCounters_;
            bitField0_ = (bitField0_ & ~0x00000008);
          } else {
            ensureVmstatCountersIsMutable();
            vmstatCounters_.addAll(other.vmstatCounters_);
          }
          onChanged();
        }
        if (other.hasStatPeriodMs()) {
          setStatPeriodMs(other.getStatPeriodMs());
        }
        if (!other.statCounters_.isEmpty()) {
          if (statCounters_.isEmpty()) {
            statCounters_ = other.statCounters_;
            bitField0_ = (bitField0_ & ~0x00000020);
          } else {
            ensureStatCountersIsMutable();
            statCounters_.addAll(other.statCounters_);
          }
          onChanged();
        }
        if (other.hasDevfreqPeriodMs()) {
          setDevfreqPeriodMs(other.getDevfreqPeriodMs());
        }
        if (other.hasCpufreqPeriodMs()) {
          setCpufreqPeriodMs(other.getCpufreqPeriodMs());
        }
        if (other.hasBuddyinfoPeriodMs()) {
          setBuddyinfoPeriodMs(other.getBuddyinfoPeriodMs());
        }
        if (other.hasDiskstatPeriodMs()) {
          setDiskstatPeriodMs(other.getDiskstatPeriodMs());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                meminfoPeriodMs_ = input.readUInt32();
                bitField0_ |= 0x00000001;
                break;
              } // case 8
              case 16: {
                int tmpRaw = input.readEnum();
                perfetto.protos.SysStatsCounters.MeminfoCounters tmpValue =
                    perfetto.protos.SysStatsCounters.MeminfoCounters.forNumber(tmpRaw);
                if (tmpValue == null) {
                  mergeUnknownVarintField(2, tmpRaw);
                } else {
                  ensureMeminfoCountersIsMutable();
                  meminfoCounters_.add(tmpRaw);
                }
                break;
              } // case 16
              case 18: {
                int length = input.readRawVarint32();
                int oldLimit = input.pushLimit(length);
                while(input.getBytesUntilLimit() > 0) {
                  int tmpRaw = input.readEnum();
                  perfetto.protos.SysStatsCounters.MeminfoCounters tmpValue =
                      perfetto.protos.SysStatsCounters.MeminfoCounters.forNumber(tmpRaw);
                  if (tmpValue == null) {
                    mergeUnknownVarintField(2, tmpRaw);
                  } else {
                    ensureMeminfoCountersIsMutable();
                    meminfoCounters_.add(tmpRaw);
                  }
                }
                input.popLimit(oldLimit);
                break;
              } // case 18
              case 24: {
                vmstatPeriodMs_ = input.readUInt32();
                bitField0_ |= 0x00000004;
                break;
              } // case 24
              case 32: {
                int tmpRaw = input.readEnum();
                perfetto.protos.SysStatsCounters.VmstatCounters tmpValue =
                    perfetto.protos.SysStatsCounters.VmstatCounters.forNumber(tmpRaw);
                if (tmpValue == null) {
                  mergeUnknownVarintField(4, tmpRaw);
                } else {
                  ensureVmstatCountersIsMutable();
                  vmstatCounters_.add(tmpRaw);
                }
                break;
              } // case 32
              case 34: {
                int length = input.readRawVarint32();
                int oldLimit = input.pushLimit(length);
                while(input.getBytesUntilLimit() > 0) {
                  int tmpRaw = input.readEnum();
                  perfetto.protos.SysStatsCounters.VmstatCounters tmpValue =
                      perfetto.protos.SysStatsCounters.VmstatCounters.forNumber(tmpRaw);
                  if (tmpValue == null) {
                    mergeUnknownVarintField(4, tmpRaw);
                  } else {
                    ensureVmstatCountersIsMutable();
                    vmstatCounters_.add(tmpRaw);
                  }
                }
                input.popLimit(oldLimit);
                break;
              } // case 34
              case 40: {
                statPeriodMs_ = input.readUInt32();
                bitField0_ |= 0x00000010;
                break;
              } // case 40
              case 48: {
                int tmpRaw = input.readEnum();
                perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig.StatCounters tmpValue =
                    perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig.StatCounters.forNumber(tmpRaw);
                if (tmpValue == null) {
                  mergeUnknownVarintField(6, tmpRaw);
                } else {
                  ensureStatCountersIsMutable();
                  statCounters_.add(tmpRaw);
                }
                break;
              } // case 48
              case 50: {
                int length = input.readRawVarint32();
                int oldLimit = input.pushLimit(length);
                while(input.getBytesUntilLimit() > 0) {
                  int tmpRaw = input.readEnum();
                  perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig.StatCounters tmpValue =
                      perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig.StatCounters.forNumber(tmpRaw);
                  if (tmpValue == null) {
                    mergeUnknownVarintField(6, tmpRaw);
                  } else {
                    ensureStatCountersIsMutable();
                    statCounters_.add(tmpRaw);
                  }
                }
                input.popLimit(oldLimit);
                break;
              } // case 50
              case 56: {
                devfreqPeriodMs_ = input.readUInt32();
                bitField0_ |= 0x00000040;
                break;
              } // case 56
              case 64: {
                cpufreqPeriodMs_ = input.readUInt32();
                bitField0_ |= 0x00000080;
                break;
              } // case 64
              case 72: {
                buddyinfoPeriodMs_ = input.readUInt32();
                bitField0_ |= 0x00000100;
                break;
              } // case 72
              case 80: {
                diskstatPeriodMs_ = input.readUInt32();
                bitField0_ |= 0x00000200;
                break;
              } // case 80
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private int meminfoPeriodMs_ ;
      /**
       * <pre>
       * Polls /proc/meminfo every X ms, if non-zero.
       * This is required to be &gt; 10ms to avoid excessive CPU usage.
       * Cost: 0.3 ms [read] + 0.07 ms [parse + trace injection]
       * </pre>
       *
       * <code>optional uint32 meminfo_period_ms = 1;</code>
       * @return Whether the meminfoPeriodMs field is set.
       */
      @java.lang.Override
      public boolean hasMeminfoPeriodMs() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Polls /proc/meminfo every X ms, if non-zero.
       * This is required to be &gt; 10ms to avoid excessive CPU usage.
       * Cost: 0.3 ms [read] + 0.07 ms [parse + trace injection]
       * </pre>
       *
       * <code>optional uint32 meminfo_period_ms = 1;</code>
       * @return The meminfoPeriodMs.
       */
      @java.lang.Override
      public int getMeminfoPeriodMs() {
        return meminfoPeriodMs_;
      }
      /**
       * <pre>
       * Polls /proc/meminfo every X ms, if non-zero.
       * This is required to be &gt; 10ms to avoid excessive CPU usage.
       * Cost: 0.3 ms [read] + 0.07 ms [parse + trace injection]
       * </pre>
       *
       * <code>optional uint32 meminfo_period_ms = 1;</code>
       * @param value The meminfoPeriodMs to set.
       * @return This builder for chaining.
       */
      public Builder setMeminfoPeriodMs(int value) {
        
        meminfoPeriodMs_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Polls /proc/meminfo every X ms, if non-zero.
       * This is required to be &gt; 10ms to avoid excessive CPU usage.
       * Cost: 0.3 ms [read] + 0.07 ms [parse + trace injection]
       * </pre>
       *
       * <code>optional uint32 meminfo_period_ms = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearMeminfoPeriodMs() {
        bitField0_ = (bitField0_ & ~0x00000001);
        meminfoPeriodMs_ = 0;
        onChanged();
        return this;
      }

      private java.util.List<java.lang.Integer> meminfoCounters_ =
        java.util.Collections.emptyList();
      private void ensureMeminfoCountersIsMutable() {
        if (!((bitField0_ & 0x00000002) != 0)) {
          meminfoCounters_ = new java.util.ArrayList<java.lang.Integer>(meminfoCounters_);
          bitField0_ |= 0x00000002;
        }
      }
      /**
       * <pre>
       * If empty all known counters are reported. Otherwise, only the counters
       * specified below are reported.
       * </pre>
       *
       * <code>repeated .perfetto.protos.MeminfoCounters meminfo_counters = 2;</code>
       * @return A list containing the meminfoCounters.
       */
      public java.util.List<perfetto.protos.SysStatsCounters.MeminfoCounters> getMeminfoCountersList() {
        return new com.google.protobuf.Internal.ListAdapter<
            java.lang.Integer, perfetto.protos.SysStatsCounters.MeminfoCounters>(meminfoCounters_, meminfoCounters_converter_);
      }
      /**
       * <pre>
       * If empty all known counters are reported. Otherwise, only the counters
       * specified below are reported.
       * </pre>
       *
       * <code>repeated .perfetto.protos.MeminfoCounters meminfo_counters = 2;</code>
       * @return The count of meminfoCounters.
       */
      public int getMeminfoCountersCount() {
        return meminfoCounters_.size();
      }
      /**
       * <pre>
       * If empty all known counters are reported. Otherwise, only the counters
       * specified below are reported.
       * </pre>
       *
       * <code>repeated .perfetto.protos.MeminfoCounters meminfo_counters = 2;</code>
       * @param index The index of the element to return.
       * @return The meminfoCounters at the given index.
       */
      public perfetto.protos.SysStatsCounters.MeminfoCounters getMeminfoCounters(int index) {
        return meminfoCounters_converter_.convert(meminfoCounters_.get(index));
      }
      /**
       * <pre>
       * If empty all known counters are reported. Otherwise, only the counters
       * specified below are reported.
       * </pre>
       *
       * <code>repeated .perfetto.protos.MeminfoCounters meminfo_counters = 2;</code>
       * @param index The index to set the value at.
       * @param value The meminfoCounters to set.
       * @return This builder for chaining.
       */
      public Builder setMeminfoCounters(
          int index, perfetto.protos.SysStatsCounters.MeminfoCounters value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureMeminfoCountersIsMutable();
        meminfoCounters_.set(index, value.getNumber());
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If empty all known counters are reported. Otherwise, only the counters
       * specified below are reported.
       * </pre>
       *
       * <code>repeated .perfetto.protos.MeminfoCounters meminfo_counters = 2;</code>
       * @param value The meminfoCounters to add.
       * @return This builder for chaining.
       */
      public Builder addMeminfoCounters(perfetto.protos.SysStatsCounters.MeminfoCounters value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureMeminfoCountersIsMutable();
        meminfoCounters_.add(value.getNumber());
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If empty all known counters are reported. Otherwise, only the counters
       * specified below are reported.
       * </pre>
       *
       * <code>repeated .perfetto.protos.MeminfoCounters meminfo_counters = 2;</code>
       * @param values The meminfoCounters to add.
       * @return This builder for chaining.
       */
      public Builder addAllMeminfoCounters(
          java.lang.Iterable<? extends perfetto.protos.SysStatsCounters.MeminfoCounters> values) {
        ensureMeminfoCountersIsMutable();
        for (perfetto.protos.SysStatsCounters.MeminfoCounters value : values) {
          meminfoCounters_.add(value.getNumber());
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If empty all known counters are reported. Otherwise, only the counters
       * specified below are reported.
       * </pre>
       *
       * <code>repeated .perfetto.protos.MeminfoCounters meminfo_counters = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearMeminfoCounters() {
        meminfoCounters_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }

      private int vmstatPeriodMs_ ;
      /**
       * <pre>
       * Polls /proc/vmstat every X ms, if non-zero.
       * This is required to be &gt; 10ms to avoid excessive CPU usage.
       * Cost: 0.2 ms [read] + 0.3 ms [parse + trace injection]
       * </pre>
       *
       * <code>optional uint32 vmstat_period_ms = 3;</code>
       * @return Whether the vmstatPeriodMs field is set.
       */
      @java.lang.Override
      public boolean hasVmstatPeriodMs() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * Polls /proc/vmstat every X ms, if non-zero.
       * This is required to be &gt; 10ms to avoid excessive CPU usage.
       * Cost: 0.2 ms [read] + 0.3 ms [parse + trace injection]
       * </pre>
       *
       * <code>optional uint32 vmstat_period_ms = 3;</code>
       * @return The vmstatPeriodMs.
       */
      @java.lang.Override
      public int getVmstatPeriodMs() {
        return vmstatPeriodMs_;
      }
      /**
       * <pre>
       * Polls /proc/vmstat every X ms, if non-zero.
       * This is required to be &gt; 10ms to avoid excessive CPU usage.
       * Cost: 0.2 ms [read] + 0.3 ms [parse + trace injection]
       * </pre>
       *
       * <code>optional uint32 vmstat_period_ms = 3;</code>
       * @param value The vmstatPeriodMs to set.
       * @return This builder for chaining.
       */
      public Builder setVmstatPeriodMs(int value) {
        
        vmstatPeriodMs_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Polls /proc/vmstat every X ms, if non-zero.
       * This is required to be &gt; 10ms to avoid excessive CPU usage.
       * Cost: 0.2 ms [read] + 0.3 ms [parse + trace injection]
       * </pre>
       *
       * <code>optional uint32 vmstat_period_ms = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearVmstatPeriodMs() {
        bitField0_ = (bitField0_ & ~0x00000004);
        vmstatPeriodMs_ = 0;
        onChanged();
        return this;
      }

      private java.util.List<java.lang.Integer> vmstatCounters_ =
        java.util.Collections.emptyList();
      private void ensureVmstatCountersIsMutable() {
        if (!((bitField0_ & 0x00000008) != 0)) {
          vmstatCounters_ = new java.util.ArrayList<java.lang.Integer>(vmstatCounters_);
          bitField0_ |= 0x00000008;
        }
      }
      /**
       * <code>repeated .perfetto.protos.VmstatCounters vmstat_counters = 4;</code>
       * @return A list containing the vmstatCounters.
       */
      public java.util.List<perfetto.protos.SysStatsCounters.VmstatCounters> getVmstatCountersList() {
        return new com.google.protobuf.Internal.ListAdapter<
            java.lang.Integer, perfetto.protos.SysStatsCounters.VmstatCounters>(vmstatCounters_, vmstatCounters_converter_);
      }
      /**
       * <code>repeated .perfetto.protos.VmstatCounters vmstat_counters = 4;</code>
       * @return The count of vmstatCounters.
       */
      public int getVmstatCountersCount() {
        return vmstatCounters_.size();
      }
      /**
       * <code>repeated .perfetto.protos.VmstatCounters vmstat_counters = 4;</code>
       * @param index The index of the element to return.
       * @return The vmstatCounters at the given index.
       */
      public perfetto.protos.SysStatsCounters.VmstatCounters getVmstatCounters(int index) {
        return vmstatCounters_converter_.convert(vmstatCounters_.get(index));
      }
      /**
       * <code>repeated .perfetto.protos.VmstatCounters vmstat_counters = 4;</code>
       * @param index The index to set the value at.
       * @param value The vmstatCounters to set.
       * @return This builder for chaining.
       */
      public Builder setVmstatCounters(
          int index, perfetto.protos.SysStatsCounters.VmstatCounters value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureVmstatCountersIsMutable();
        vmstatCounters_.set(index, value.getNumber());
        onChanged();
        return this;
      }
      /**
       * <code>repeated .perfetto.protos.VmstatCounters vmstat_counters = 4;</code>
       * @param value The vmstatCounters to add.
       * @return This builder for chaining.
       */
      public Builder addVmstatCounters(perfetto.protos.SysStatsCounters.VmstatCounters value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureVmstatCountersIsMutable();
        vmstatCounters_.add(value.getNumber());
        onChanged();
        return this;
      }
      /**
       * <code>repeated .perfetto.protos.VmstatCounters vmstat_counters = 4;</code>
       * @param values The vmstatCounters to add.
       * @return This builder for chaining.
       */
      public Builder addAllVmstatCounters(
          java.lang.Iterable<? extends perfetto.protos.SysStatsCounters.VmstatCounters> values) {
        ensureVmstatCountersIsMutable();
        for (perfetto.protos.SysStatsCounters.VmstatCounters value : values) {
          vmstatCounters_.add(value.getNumber());
        }
        onChanged();
        return this;
      }
      /**
       * <code>repeated .perfetto.protos.VmstatCounters vmstat_counters = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearVmstatCounters() {
        vmstatCounters_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000008);
        onChanged();
        return this;
      }

      private int statPeriodMs_ ;
      /**
       * <pre>
       * Pols /proc/stat every X ms, if non-zero.
       * This is required to be &gt; 10ms to avoid excessive CPU usage.
       * Cost: 4.1 ms [read] + 1.9 ms [parse + trace injection]
       * </pre>
       *
       * <code>optional uint32 stat_period_ms = 5;</code>
       * @return Whether the statPeriodMs field is set.
       */
      @java.lang.Override
      public boolean hasStatPeriodMs() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * Pols /proc/stat every X ms, if non-zero.
       * This is required to be &gt; 10ms to avoid excessive CPU usage.
       * Cost: 4.1 ms [read] + 1.9 ms [parse + trace injection]
       * </pre>
       *
       * <code>optional uint32 stat_period_ms = 5;</code>
       * @return The statPeriodMs.
       */
      @java.lang.Override
      public int getStatPeriodMs() {
        return statPeriodMs_;
      }
      /**
       * <pre>
       * Pols /proc/stat every X ms, if non-zero.
       * This is required to be &gt; 10ms to avoid excessive CPU usage.
       * Cost: 4.1 ms [read] + 1.9 ms [parse + trace injection]
       * </pre>
       *
       * <code>optional uint32 stat_period_ms = 5;</code>
       * @param value The statPeriodMs to set.
       * @return This builder for chaining.
       */
      public Builder setStatPeriodMs(int value) {
        
        statPeriodMs_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Pols /proc/stat every X ms, if non-zero.
       * This is required to be &gt; 10ms to avoid excessive CPU usage.
       * Cost: 4.1 ms [read] + 1.9 ms [parse + trace injection]
       * </pre>
       *
       * <code>optional uint32 stat_period_ms = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearStatPeriodMs() {
        bitField0_ = (bitField0_ & ~0x00000010);
        statPeriodMs_ = 0;
        onChanged();
        return this;
      }

      private java.util.List<java.lang.Integer> statCounters_ =
        java.util.Collections.emptyList();
      private void ensureStatCountersIsMutable() {
        if (!((bitField0_ & 0x00000020) != 0)) {
          statCounters_ = new java.util.ArrayList<java.lang.Integer>(statCounters_);
          bitField0_ |= 0x00000020;
        }
      }
      /**
       * <code>repeated .perfetto.protos.SysStatsConfig.StatCounters stat_counters = 6;</code>
       * @return A list containing the statCounters.
       */
      public java.util.List<perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig.StatCounters> getStatCountersList() {
        return new com.google.protobuf.Internal.ListAdapter<
            java.lang.Integer, perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig.StatCounters>(statCounters_, statCounters_converter_);
      }
      /**
       * <code>repeated .perfetto.protos.SysStatsConfig.StatCounters stat_counters = 6;</code>
       * @return The count of statCounters.
       */
      public int getStatCountersCount() {
        return statCounters_.size();
      }
      /**
       * <code>repeated .perfetto.protos.SysStatsConfig.StatCounters stat_counters = 6;</code>
       * @param index The index of the element to return.
       * @return The statCounters at the given index.
       */
      public perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig.StatCounters getStatCounters(int index) {
        return statCounters_converter_.convert(statCounters_.get(index));
      }
      /**
       * <code>repeated .perfetto.protos.SysStatsConfig.StatCounters stat_counters = 6;</code>
       * @param index The index to set the value at.
       * @param value The statCounters to set.
       * @return This builder for chaining.
       */
      public Builder setStatCounters(
          int index, perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig.StatCounters value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureStatCountersIsMutable();
        statCounters_.set(index, value.getNumber());
        onChanged();
        return this;
      }
      /**
       * <code>repeated .perfetto.protos.SysStatsConfig.StatCounters stat_counters = 6;</code>
       * @param value The statCounters to add.
       * @return This builder for chaining.
       */
      public Builder addStatCounters(perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig.StatCounters value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureStatCountersIsMutable();
        statCounters_.add(value.getNumber());
        onChanged();
        return this;
      }
      /**
       * <code>repeated .perfetto.protos.SysStatsConfig.StatCounters stat_counters = 6;</code>
       * @param values The statCounters to add.
       * @return This builder for chaining.
       */
      public Builder addAllStatCounters(
          java.lang.Iterable<? extends perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig.StatCounters> values) {
        ensureStatCountersIsMutable();
        for (perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig.StatCounters value : values) {
          statCounters_.add(value.getNumber());
        }
        onChanged();
        return this;
      }
      /**
       * <code>repeated .perfetto.protos.SysStatsConfig.StatCounters stat_counters = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearStatCounters() {
        statCounters_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000020);
        onChanged();
        return this;
      }

      private int devfreqPeriodMs_ ;
      /**
       * <pre>
       * Polls /sys/devfreq/&#42;&#47;curfreq every X ms, if non-zero.
       * This is required to be &gt; 10ms to avoid excessive CPU usage.
       * This option can be used to record unchanging values.
       * Updates from frequency changes can come from ftrace/set_clock_rate.
       * </pre>
       *
       * <code>optional uint32 devfreq_period_ms = 7;</code>
       * @return Whether the devfreqPeriodMs field is set.
       */
      @java.lang.Override
      public boolean hasDevfreqPeriodMs() {
        return ((bitField0_ & 0x00000040) != 0);
      }
      /**
       * <pre>
       * Polls /sys/devfreq/&#42;&#47;curfreq every X ms, if non-zero.
       * This is required to be &gt; 10ms to avoid excessive CPU usage.
       * This option can be used to record unchanging values.
       * Updates from frequency changes can come from ftrace/set_clock_rate.
       * </pre>
       *
       * <code>optional uint32 devfreq_period_ms = 7;</code>
       * @return The devfreqPeriodMs.
       */
      @java.lang.Override
      public int getDevfreqPeriodMs() {
        return devfreqPeriodMs_;
      }
      /**
       * <pre>
       * Polls /sys/devfreq/&#42;&#47;curfreq every X ms, if non-zero.
       * This is required to be &gt; 10ms to avoid excessive CPU usage.
       * This option can be used to record unchanging values.
       * Updates from frequency changes can come from ftrace/set_clock_rate.
       * </pre>
       *
       * <code>optional uint32 devfreq_period_ms = 7;</code>
       * @param value The devfreqPeriodMs to set.
       * @return This builder for chaining.
       */
      public Builder setDevfreqPeriodMs(int value) {
        
        devfreqPeriodMs_ = value;
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Polls /sys/devfreq/&#42;&#47;curfreq every X ms, if non-zero.
       * This is required to be &gt; 10ms to avoid excessive CPU usage.
       * This option can be used to record unchanging values.
       * Updates from frequency changes can come from ftrace/set_clock_rate.
       * </pre>
       *
       * <code>optional uint32 devfreq_period_ms = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearDevfreqPeriodMs() {
        bitField0_ = (bitField0_ & ~0x00000040);
        devfreqPeriodMs_ = 0;
        onChanged();
        return this;
      }

      private int cpufreqPeriodMs_ ;
      /**
       * <pre>
       * Polls /sys/devices/system/cpu/cpu*&#47;cpufreq/cpuinfo_cur_freq every X ms.
       * This is required to be &gt; 10ms to avoid excessive CPU usage.
       * </pre>
       *
       * <code>optional uint32 cpufreq_period_ms = 8;</code>
       * @return Whether the cpufreqPeriodMs field is set.
       */
      @java.lang.Override
      public boolean hasCpufreqPeriodMs() {
        return ((bitField0_ & 0x00000080) != 0);
      }
      /**
       * <pre>
       * Polls /sys/devices/system/cpu/cpu*&#47;cpufreq/cpuinfo_cur_freq every X ms.
       * This is required to be &gt; 10ms to avoid excessive CPU usage.
       * </pre>
       *
       * <code>optional uint32 cpufreq_period_ms = 8;</code>
       * @return The cpufreqPeriodMs.
       */
      @java.lang.Override
      public int getCpufreqPeriodMs() {
        return cpufreqPeriodMs_;
      }
      /**
       * <pre>
       * Polls /sys/devices/system/cpu/cpu*&#47;cpufreq/cpuinfo_cur_freq every X ms.
       * This is required to be &gt; 10ms to avoid excessive CPU usage.
       * </pre>
       *
       * <code>optional uint32 cpufreq_period_ms = 8;</code>
       * @param value The cpufreqPeriodMs to set.
       * @return This builder for chaining.
       */
      public Builder setCpufreqPeriodMs(int value) {
        
        cpufreqPeriodMs_ = value;
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Polls /sys/devices/system/cpu/cpu*&#47;cpufreq/cpuinfo_cur_freq every X ms.
       * This is required to be &gt; 10ms to avoid excessive CPU usage.
       * </pre>
       *
       * <code>optional uint32 cpufreq_period_ms = 8;</code>
       * @return This builder for chaining.
       */
      public Builder clearCpufreqPeriodMs() {
        bitField0_ = (bitField0_ & ~0x00000080);
        cpufreqPeriodMs_ = 0;
        onChanged();
        return this;
      }

      private int buddyinfoPeriodMs_ ;
      /**
       * <pre>
       * Polls /proc/buddyinfo every X ms, if non-zero.
       * This is required to be &gt; 10ms to avoid excessive CPU usage.
       * </pre>
       *
       * <code>optional uint32 buddyinfo_period_ms = 9;</code>
       * @return Whether the buddyinfoPeriodMs field is set.
       */
      @java.lang.Override
      public boolean hasBuddyinfoPeriodMs() {
        return ((bitField0_ & 0x00000100) != 0);
      }
      /**
       * <pre>
       * Polls /proc/buddyinfo every X ms, if non-zero.
       * This is required to be &gt; 10ms to avoid excessive CPU usage.
       * </pre>
       *
       * <code>optional uint32 buddyinfo_period_ms = 9;</code>
       * @return The buddyinfoPeriodMs.
       */
      @java.lang.Override
      public int getBuddyinfoPeriodMs() {
        return buddyinfoPeriodMs_;
      }
      /**
       * <pre>
       * Polls /proc/buddyinfo every X ms, if non-zero.
       * This is required to be &gt; 10ms to avoid excessive CPU usage.
       * </pre>
       *
       * <code>optional uint32 buddyinfo_period_ms = 9;</code>
       * @param value The buddyinfoPeriodMs to set.
       * @return This builder for chaining.
       */
      public Builder setBuddyinfoPeriodMs(int value) {
        
        buddyinfoPeriodMs_ = value;
        bitField0_ |= 0x00000100;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Polls /proc/buddyinfo every X ms, if non-zero.
       * This is required to be &gt; 10ms to avoid excessive CPU usage.
       * </pre>
       *
       * <code>optional uint32 buddyinfo_period_ms = 9;</code>
       * @return This builder for chaining.
       */
      public Builder clearBuddyinfoPeriodMs() {
        bitField0_ = (bitField0_ & ~0x00000100);
        buddyinfoPeriodMs_ = 0;
        onChanged();
        return this;
      }

      private int diskstatPeriodMs_ ;
      /**
       * <pre>
       * Polls /proc/diskstats every X ms, if non-zero.
       * This is required to be &gt; 10ms to avoid excessive CPU usage.
       * </pre>
       *
       * <code>optional uint32 diskstat_period_ms = 10;</code>
       * @return Whether the diskstatPeriodMs field is set.
       */
      @java.lang.Override
      public boolean hasDiskstatPeriodMs() {
        return ((bitField0_ & 0x00000200) != 0);
      }
      /**
       * <pre>
       * Polls /proc/diskstats every X ms, if non-zero.
       * This is required to be &gt; 10ms to avoid excessive CPU usage.
       * </pre>
       *
       * <code>optional uint32 diskstat_period_ms = 10;</code>
       * @return The diskstatPeriodMs.
       */
      @java.lang.Override
      public int getDiskstatPeriodMs() {
        return diskstatPeriodMs_;
      }
      /**
       * <pre>
       * Polls /proc/diskstats every X ms, if non-zero.
       * This is required to be &gt; 10ms to avoid excessive CPU usage.
       * </pre>
       *
       * <code>optional uint32 diskstat_period_ms = 10;</code>
       * @param value The diskstatPeriodMs to set.
       * @return This builder for chaining.
       */
      public Builder setDiskstatPeriodMs(int value) {
        
        diskstatPeriodMs_ = value;
        bitField0_ |= 0x00000200;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Polls /proc/diskstats every X ms, if non-zero.
       * This is required to be &gt; 10ms to avoid excessive CPU usage.
       * </pre>
       *
       * <code>optional uint32 diskstat_period_ms = 10;</code>
       * @return This builder for chaining.
       */
      public Builder clearDiskstatPeriodMs() {
        bitField0_ = (bitField0_ & ~0x00000200);
        diskstatPeriodMs_ = 0;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:perfetto.protos.SysStatsConfig)
    }

    // @@protoc_insertion_point(class_scope:perfetto.protos.SysStatsConfig)
    private static final perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig();
    }

    public static perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<SysStatsConfig>
        PARSER = new com.google.protobuf.AbstractParser<SysStatsConfig>() {
      @java.lang.Override
      public SysStatsConfig parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<SysStatsConfig> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<SysStatsConfig> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public perfetto.protos.SysStatsConfigOuterClass.SysStatsConfig getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_perfetto_protos_SysStatsConfig_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_perfetto_protos_SysStatsConfig_fieldAccessorTable;

  public static com.google.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
    return descriptor;
  }
  private static  com.google.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
    java.lang.String[] descriptorData = {
      "\n7protos/perfetto/config/sys_stats/sys_s" +
      "tats_config.proto\022\017perfetto.protos\032/prot" +
      "os/perfetto/common/sys_stats_counters.pr" +
      "oto\"\204\004\n\016SysStatsConfig\022\031\n\021meminfo_period" +
      "_ms\030\001 \001(\r\022:\n\020meminfo_counters\030\002 \003(\0162 .pe" +
      "rfetto.protos.MeminfoCounters\022\030\n\020vmstat_" +
      "period_ms\030\003 \001(\r\0228\n\017vmstat_counters\030\004 \003(\016" +
      "2\037.perfetto.protos.VmstatCounters\022\026\n\016sta" +
      "t_period_ms\030\005 \001(\r\022C\n\rstat_counters\030\006 \003(\016" +
      "2,.perfetto.protos.SysStatsConfig.StatCo" +
      "unters\022\031\n\021devfreq_period_ms\030\007 \001(\r\022\031\n\021cpu" +
      "freq_period_ms\030\010 \001(\r\022\033\n\023buddyinfo_period" +
      "_ms\030\t \001(\r\022\032\n\022diskstat_period_ms\030\n \001(\r\"{\n" +
      "\014StatCounters\022\024\n\020STAT_UNSPECIFIED\020\000\022\022\n\016S" +
      "TAT_CPU_TIMES\020\001\022\023\n\017STAT_IRQ_COUNTS\020\002\022\027\n\023" +
      "STAT_SOFTIRQ_COUNTS\020\003\022\023\n\017STAT_FORK_COUNT" +
      "\020\004"
    };
    descriptor = com.google.protobuf.Descriptors.FileDescriptor
      .internalBuildGeneratedFileFrom(descriptorData,
        new com.google.protobuf.Descriptors.FileDescriptor[] {
          perfetto.protos.SysStatsCounters.getDescriptor(),
        });
    internal_static_perfetto_protos_SysStatsConfig_descriptor =
      getDescriptor().getMessageTypes().get(0);
    internal_static_perfetto_protos_SysStatsConfig_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_perfetto_protos_SysStatsConfig_descriptor,
        new java.lang.String[] { "MeminfoPeriodMs", "MeminfoCounters", "VmstatPeriodMs", "VmstatCounters", "StatPeriodMs", "StatCounters", "DevfreqPeriodMs", "CpufreqPeriodMs", "BuddyinfoPeriodMs", "DiskstatPeriodMs", });
    perfetto.protos.SysStatsCounters.getDescriptor();
  }

  // @@protoc_insertion_point(outer_class_scope)
}
