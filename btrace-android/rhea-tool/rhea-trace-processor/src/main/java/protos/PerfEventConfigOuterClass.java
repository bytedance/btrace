// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/config/profiling/perf_event_config.proto

package perfetto.protos;

public final class PerfEventConfigOuterClass {
  private PerfEventConfigOuterClass() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }

  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistry registry) {
    registerAllExtensions(
        (com.google.protobuf.ExtensionRegistryLite) registry);
  }
  public interface PerfEventConfigOrBuilder extends
      // @@protoc_insertion_point(interface_extends:perfetto.protos.PerfEventConfig)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * What event to sample on, and how often.
     * Defined in common/perf_events.proto.
     * </pre>
     *
     * <code>optional .perfetto.protos.PerfEvents.Timebase timebase = 15;</code>
     * @return Whether the timebase field is set.
     */
    boolean hasTimebase();
    /**
     * <pre>
     * What event to sample on, and how often.
     * Defined in common/perf_events.proto.
     * </pre>
     *
     * <code>optional .perfetto.protos.PerfEvents.Timebase timebase = 15;</code>
     * @return The timebase.
     */
    perfetto.protos.PerfEventsOuterClass.PerfEvents.Timebase getTimebase();
    /**
     * <pre>
     * What event to sample on, and how often.
     * Defined in common/perf_events.proto.
     * </pre>
     *
     * <code>optional .perfetto.protos.PerfEvents.Timebase timebase = 15;</code>
     */
    perfetto.protos.PerfEventsOuterClass.PerfEvents.TimebaseOrBuilder getTimebaseOrBuilder();

    /**
     * <pre>
     * If set, the profiler will sample userspace processes' callstacks at the
     * interval specified by the |timebase|.
     * If unset, the profiler will record only the event counts.
     * </pre>
     *
     * <code>optional .perfetto.protos.PerfEventConfig.CallstackSampling callstack_sampling = 16;</code>
     * @return Whether the callstackSampling field is set.
     */
    boolean hasCallstackSampling();
    /**
     * <pre>
     * If set, the profiler will sample userspace processes' callstacks at the
     * interval specified by the |timebase|.
     * If unset, the profiler will record only the event counts.
     * </pre>
     *
     * <code>optional .perfetto.protos.PerfEventConfig.CallstackSampling callstack_sampling = 16;</code>
     * @return The callstackSampling.
     */
    perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.CallstackSampling getCallstackSampling();
    /**
     * <pre>
     * If set, the profiler will sample userspace processes' callstacks at the
     * interval specified by the |timebase|.
     * If unset, the profiler will record only the event counts.
     * </pre>
     *
     * <code>optional .perfetto.protos.PerfEventConfig.CallstackSampling callstack_sampling = 16;</code>
     */
    perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.CallstackSamplingOrBuilder getCallstackSamplingOrBuilder();

    /**
     * <pre>
     * How often the per-cpu ring buffers are read by the producer.
     * If unset, an implementation-defined default is used.
     * </pre>
     *
     * <code>optional uint32 ring_buffer_read_period_ms = 8;</code>
     * @return Whether the ringBufferReadPeriodMs field is set.
     */
    boolean hasRingBufferReadPeriodMs();
    /**
     * <pre>
     * How often the per-cpu ring buffers are read by the producer.
     * If unset, an implementation-defined default is used.
     * </pre>
     *
     * <code>optional uint32 ring_buffer_read_period_ms = 8;</code>
     * @return The ringBufferReadPeriodMs.
     */
    int getRingBufferReadPeriodMs();

    /**
     * <pre>
     * Size (in 4k pages) of each per-cpu ring buffer that is filled by the
     * kernel. If set, must be a power of two.
     * If unset, an implementation-defined default is used.
     * </pre>
     *
     * <code>optional uint32 ring_buffer_pages = 3;</code>
     * @return Whether the ringBufferPages field is set.
     */
    boolean hasRingBufferPages();
    /**
     * <pre>
     * Size (in 4k pages) of each per-cpu ring buffer that is filled by the
     * kernel. If set, must be a power of two.
     * If unset, an implementation-defined default is used.
     * </pre>
     *
     * <code>optional uint32 ring_buffer_pages = 3;</code>
     * @return The ringBufferPages.
     */
    int getRingBufferPages();

    /**
     * <pre>
     * Drop samples if the heap memory held by the samples in the unwinder queue
     * is above the given limit. This counts the memory across all concurrent data
     * sources (not just this one's), and there is no fairness guarantee - the
     * whole quota might be used up by a concurrent source.
     * </pre>
     *
     * <code>optional uint64 max_enqueued_footprint_kb = 17;</code>
     * @return Whether the maxEnqueuedFootprintKb field is set.
     */
    boolean hasMaxEnqueuedFootprintKb();
    /**
     * <pre>
     * Drop samples if the heap memory held by the samples in the unwinder queue
     * is above the given limit. This counts the memory across all concurrent data
     * sources (not just this one's), and there is no fairness guarantee - the
     * whole quota might be used up by a concurrent source.
     * </pre>
     *
     * <code>optional uint64 max_enqueued_footprint_kb = 17;</code>
     * @return The maxEnqueuedFootprintKb.
     */
    long getMaxEnqueuedFootprintKb();

    /**
     * <pre>
     * Stop the data source if traced_perf's combined {RssAnon + Swap} memory
     * footprint exceeds this value.
     * </pre>
     *
     * <code>optional uint32 max_daemon_memory_kb = 13;</code>
     * @return Whether the maxDaemonMemoryKb field is set.
     */
    boolean hasMaxDaemonMemoryKb();
    /**
     * <pre>
     * Stop the data source if traced_perf's combined {RssAnon + Swap} memory
     * footprint exceeds this value.
     * </pre>
     *
     * <code>optional uint32 max_daemon_memory_kb = 13;</code>
     * @return The maxDaemonMemoryKb.
     */
    int getMaxDaemonMemoryKb();

    /**
     * <pre>
     * Timeout for the remote /proc/&lt;pid&gt;/{maps,mem} file descriptors for a
     * sampled process. This is primarily for Android, where this lookup is
     * asynchronous. As long as the producer is waiting, the associated samples
     * will be kept enqueued (putting pressure on the capacity of the shared
     * unwinding queue). Once a lookup for a process expires, all associated
     * samples are discarded. However, if the lookup still succeeds after the
     * timeout, future samples will be handled normally.
     * If unset, an implementation-defined default is used.
     * </pre>
     *
     * <code>optional uint32 remote_descriptor_timeout_ms = 9;</code>
     * @return Whether the remoteDescriptorTimeoutMs field is set.
     */
    boolean hasRemoteDescriptorTimeoutMs();
    /**
     * <pre>
     * Timeout for the remote /proc/&lt;pid&gt;/{maps,mem} file descriptors for a
     * sampled process. This is primarily for Android, where this lookup is
     * asynchronous. As long as the producer is waiting, the associated samples
     * will be kept enqueued (putting pressure on the capacity of the shared
     * unwinding queue). Once a lookup for a process expires, all associated
     * samples are discarded. However, if the lookup still succeeds after the
     * timeout, future samples will be handled normally.
     * If unset, an implementation-defined default is used.
     * </pre>
     *
     * <code>optional uint32 remote_descriptor_timeout_ms = 9;</code>
     * @return The remoteDescriptorTimeoutMs.
     */
    int getRemoteDescriptorTimeoutMs();

    /**
     * <pre>
     * Optional period for clearing state cached by the unwinder. This is a heavy
     * operation that is only necessary for traces that target a wide set of
     * processes, and require the memory footprint to be reset periodically.
     * If unset, the cached state will not be cleared.
     * </pre>
     *
     * <code>optional uint32 unwind_state_clear_period_ms = 10;</code>
     * @return Whether the unwindStateClearPeriodMs field is set.
     */
    boolean hasUnwindStateClearPeriodMs();
    /**
     * <pre>
     * Optional period for clearing state cached by the unwinder. This is a heavy
     * operation that is only necessary for traces that target a wide set of
     * processes, and require the memory footprint to be reset periodically.
     * If unset, the cached state will not be cleared.
     * </pre>
     *
     * <code>optional uint32 unwind_state_clear_period_ms = 10;</code>
     * @return The unwindStateClearPeriodMs.
     */
    int getUnwindStateClearPeriodMs();

    /**
     * <pre>
     * If set, only profile target if it was installed by a package with one of
     * these names. Special values:
     * * "&#64;system": installed on the system partition
     * * "&#64;product": installed on the product partition
     * * "&#64;null": sideloaded
     * Supported on Android 12+.
     * </pre>
     *
     * <code>repeated string target_installed_by = 18;</code>
     * @return A list containing the targetInstalledBy.
     */
    java.util.List<java.lang.String>
        getTargetInstalledByList();
    /**
     * <pre>
     * If set, only profile target if it was installed by a package with one of
     * these names. Special values:
     * * "&#64;system": installed on the system partition
     * * "&#64;product": installed on the product partition
     * * "&#64;null": sideloaded
     * Supported on Android 12+.
     * </pre>
     *
     * <code>repeated string target_installed_by = 18;</code>
     * @return The count of targetInstalledBy.
     */
    int getTargetInstalledByCount();
    /**
     * <pre>
     * If set, only profile target if it was installed by a package with one of
     * these names. Special values:
     * * "&#64;system": installed on the system partition
     * * "&#64;product": installed on the product partition
     * * "&#64;null": sideloaded
     * Supported on Android 12+.
     * </pre>
     *
     * <code>repeated string target_installed_by = 18;</code>
     * @param index The index of the element to return.
     * @return The targetInstalledBy at the given index.
     */
    java.lang.String getTargetInstalledBy(int index);
    /**
     * <pre>
     * If set, only profile target if it was installed by a package with one of
     * these names. Special values:
     * * "&#64;system": installed on the system partition
     * * "&#64;product": installed on the product partition
     * * "&#64;null": sideloaded
     * Supported on Android 12+.
     * </pre>
     *
     * <code>repeated string target_installed_by = 18;</code>
     * @param index The index of the value to return.
     * @return The bytes of the targetInstalledBy at the given index.
     */
    com.google.protobuf.ByteString
        getTargetInstalledByBytes(int index);

    /**
     * <pre>
     * Note: legacy configs had to set |all_cpus| to true to pass parsing.
     * We rely on this to detect such configs.
     * </pre>
     *
     * <code>optional bool all_cpus = 1;</code>
     * @return Whether the allCpus field is set.
     */
    boolean hasAllCpus();
    /**
     * <pre>
     * Note: legacy configs had to set |all_cpus| to true to pass parsing.
     * We rely on this to detect such configs.
     * </pre>
     *
     * <code>optional bool all_cpus = 1;</code>
     * @return The allCpus.
     */
    boolean getAllCpus();

    /**
     * <code>optional uint32 sampling_frequency = 2;</code>
     * @return Whether the samplingFrequency field is set.
     */
    boolean hasSamplingFrequency();
    /**
     * <code>optional uint32 sampling_frequency = 2;</code>
     * @return The samplingFrequency.
     */
    int getSamplingFrequency();

    /**
     * <code>optional bool kernel_frames = 12;</code>
     * @return Whether the kernelFrames field is set.
     */
    boolean hasKernelFrames();
    /**
     * <code>optional bool kernel_frames = 12;</code>
     * @return The kernelFrames.
     */
    boolean getKernelFrames();

    /**
     * <code>repeated int32 target_pid = 4;</code>
     * @return A list containing the targetPid.
     */
    java.util.List<java.lang.Integer> getTargetPidList();
    /**
     * <code>repeated int32 target_pid = 4;</code>
     * @return The count of targetPid.
     */
    int getTargetPidCount();
    /**
     * <code>repeated int32 target_pid = 4;</code>
     * @param index The index of the element to return.
     * @return The targetPid at the given index.
     */
    int getTargetPid(int index);

    /**
     * <code>repeated string target_cmdline = 5;</code>
     * @return A list containing the targetCmdline.
     */
    java.util.List<java.lang.String>
        getTargetCmdlineList();
    /**
     * <code>repeated string target_cmdline = 5;</code>
     * @return The count of targetCmdline.
     */
    int getTargetCmdlineCount();
    /**
     * <code>repeated string target_cmdline = 5;</code>
     * @param index The index of the element to return.
     * @return The targetCmdline at the given index.
     */
    java.lang.String getTargetCmdline(int index);
    /**
     * <code>repeated string target_cmdline = 5;</code>
     * @param index The index of the value to return.
     * @return The bytes of the targetCmdline at the given index.
     */
    com.google.protobuf.ByteString
        getTargetCmdlineBytes(int index);

    /**
     * <code>repeated int32 exclude_pid = 6;</code>
     * @return A list containing the excludePid.
     */
    java.util.List<java.lang.Integer> getExcludePidList();
    /**
     * <code>repeated int32 exclude_pid = 6;</code>
     * @return The count of excludePid.
     */
    int getExcludePidCount();
    /**
     * <code>repeated int32 exclude_pid = 6;</code>
     * @param index The index of the element to return.
     * @return The excludePid at the given index.
     */
    int getExcludePid(int index);

    /**
     * <code>repeated string exclude_cmdline = 7;</code>
     * @return A list containing the excludeCmdline.
     */
    java.util.List<java.lang.String>
        getExcludeCmdlineList();
    /**
     * <code>repeated string exclude_cmdline = 7;</code>
     * @return The count of excludeCmdline.
     */
    int getExcludeCmdlineCount();
    /**
     * <code>repeated string exclude_cmdline = 7;</code>
     * @param index The index of the element to return.
     * @return The excludeCmdline at the given index.
     */
    java.lang.String getExcludeCmdline(int index);
    /**
     * <code>repeated string exclude_cmdline = 7;</code>
     * @param index The index of the value to return.
     * @return The bytes of the excludeCmdline at the given index.
     */
    com.google.protobuf.ByteString
        getExcludeCmdlineBytes(int index);

    /**
     * <code>optional uint32 additional_cmdline_count = 11;</code>
     * @return Whether the additionalCmdlineCount field is set.
     */
    boolean hasAdditionalCmdlineCount();
    /**
     * <code>optional uint32 additional_cmdline_count = 11;</code>
     * @return The additionalCmdlineCount.
     */
    int getAdditionalCmdlineCount();
  }
  /**
   * <pre>
   * Configuration for the traced_perf profiler.
   * Example config for basic cpu profiling:
   *   perf_event_config {
   *     timebase {
   *       frequency: 80
   *     }
   *     callstack_sampling {
   *       scope {
   *         target_cmdline: "surfaceflinger"
   *         target_cmdline: "system_server"
   *       }
   *       kernel_frames: true
   *     }
   *   }
   * Next id: 19
   * </pre>
   *
   * Protobuf type {@code perfetto.protos.PerfEventConfig}
   */
  public static final class PerfEventConfig extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:perfetto.protos.PerfEventConfig)
      PerfEventConfigOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use PerfEventConfig.newBuilder() to construct.
    private PerfEventConfig(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private PerfEventConfig() {
      targetInstalledBy_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      targetPid_ = emptyIntList();
      targetCmdline_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      excludePid_ = emptyIntList();
      excludeCmdline_ = com.google.protobuf.LazyStringArrayList.EMPTY;
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new PerfEventConfig();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return perfetto.protos.PerfEventConfigOuterClass.internal_static_perfetto_protos_PerfEventConfig_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return perfetto.protos.PerfEventConfigOuterClass.internal_static_perfetto_protos_PerfEventConfig_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.class, perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.Builder.class);
    }

    /**
     * <pre>
     * Userspace unwinding mode. A possible future addition is kernel-unwound
     * callchains for frame pointer based systems.
     * </pre>
     *
     * Protobuf enum {@code perfetto.protos.PerfEventConfig.UnwindMode}
     */
    public enum UnwindMode
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <code>UNWIND_UNKNOWN = 0;</code>
       */
      UNWIND_UNKNOWN(0),
      /**
       * <pre>
       * Do not unwind userspace:
       * </pre>
       *
       * <code>UNWIND_SKIP = 1;</code>
       */
      UNWIND_SKIP(1),
      /**
       * <pre>
       * Use libunwindstack (default):
       * </pre>
       *
       * <code>UNWIND_DWARF = 2;</code>
       */
      UNWIND_DWARF(2),
      ;

      /**
       * <code>UNWIND_UNKNOWN = 0;</code>
       */
      public static final int UNWIND_UNKNOWN_VALUE = 0;
      /**
       * <pre>
       * Do not unwind userspace:
       * </pre>
       *
       * <code>UNWIND_SKIP = 1;</code>
       */
      public static final int UNWIND_SKIP_VALUE = 1;
      /**
       * <pre>
       * Use libunwindstack (default):
       * </pre>
       *
       * <code>UNWIND_DWARF = 2;</code>
       */
      public static final int UNWIND_DWARF_VALUE = 2;


      public final int getNumber() {
        return value;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static UnwindMode valueOf(int value) {
        return forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       */
      public static UnwindMode forNumber(int value) {
        switch (value) {
          case 0: return UNWIND_UNKNOWN;
          case 1: return UNWIND_SKIP;
          case 2: return UNWIND_DWARF;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<UnwindMode>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          UnwindMode> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<UnwindMode>() {
              public UnwindMode findValueByNumber(int number) {
                return UnwindMode.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.getDescriptor().getEnumTypes().get(0);
      }

      private static final UnwindMode[] VALUES = values();

      public static UnwindMode valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private UnwindMode(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:perfetto.protos.PerfEventConfig.UnwindMode)
    }

    public interface CallstackSamplingOrBuilder extends
        // @@protoc_insertion_point(interface_extends:perfetto.protos.PerfEventConfig.CallstackSampling)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <pre>
       * Defines a set of processes for which samples are retained/skipped. If
       * unset, all samples are kept, but beware that it will be very heavy on the
       * stack unwinder, which might start dropping samples due to overload.
       * </pre>
       *
       * <code>optional .perfetto.protos.PerfEventConfig.Scope scope = 1;</code>
       * @return Whether the scope field is set.
       */
      boolean hasScope();
      /**
       * <pre>
       * Defines a set of processes for which samples are retained/skipped. If
       * unset, all samples are kept, but beware that it will be very heavy on the
       * stack unwinder, which might start dropping samples due to overload.
       * </pre>
       *
       * <code>optional .perfetto.protos.PerfEventConfig.Scope scope = 1;</code>
       * @return The scope.
       */
      perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.Scope getScope();
      /**
       * <pre>
       * Defines a set of processes for which samples are retained/skipped. If
       * unset, all samples are kept, but beware that it will be very heavy on the
       * stack unwinder, which might start dropping samples due to overload.
       * </pre>
       *
       * <code>optional .perfetto.protos.PerfEventConfig.Scope scope = 1;</code>
       */
      perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.ScopeOrBuilder getScopeOrBuilder();

      /**
       * <pre>
       * If true, callstacks will include the kernel-space frames. Such frames can
       * be identified by a magical "kernel" string as their mapping name.
       * Requires traced_perf to be running as root, or kptr_restrict to have been
       * manually unrestricted. On Android, the platform should do the right thing
       * on debug builds.
       * This does *not* disclose KASLR, as only the function names are emitted.
       * </pre>
       *
       * <code>optional bool kernel_frames = 2;</code>
       * @return Whether the kernelFrames field is set.
       */
      boolean hasKernelFrames();
      /**
       * <pre>
       * If true, callstacks will include the kernel-space frames. Such frames can
       * be identified by a magical "kernel" string as their mapping name.
       * Requires traced_perf to be running as root, or kptr_restrict to have been
       * manually unrestricted. On Android, the platform should do the right thing
       * on debug builds.
       * This does *not* disclose KASLR, as only the function names are emitted.
       * </pre>
       *
       * <code>optional bool kernel_frames = 2;</code>
       * @return The kernelFrames.
       */
      boolean getKernelFrames();

      /**
       * <pre>
       * Whether to record and unwind userspace callstacks. If unset, defaults to
       * including userspace (UNWIND_DWARF) both for backwards compatibility and
       * as the most common default (this defaulting is only applicable if the
       * outer CallstackSampling message is explicitly set).
       * </pre>
       *
       * <code>optional .perfetto.protos.PerfEventConfig.UnwindMode user_frames = 3;</code>
       * @return Whether the userFrames field is set.
       */
      boolean hasUserFrames();
      /**
       * <pre>
       * Whether to record and unwind userspace callstacks. If unset, defaults to
       * including userspace (UNWIND_DWARF) both for backwards compatibility and
       * as the most common default (this defaulting is only applicable if the
       * outer CallstackSampling message is explicitly set).
       * </pre>
       *
       * <code>optional .perfetto.protos.PerfEventConfig.UnwindMode user_frames = 3;</code>
       * @return The userFrames.
       */
      perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.UnwindMode getUserFrames();
    }
    /**
     * Protobuf type {@code perfetto.protos.PerfEventConfig.CallstackSampling}
     */
    public static final class CallstackSampling extends
        com.google.protobuf.GeneratedMessageV3 implements
        // @@protoc_insertion_point(message_implements:perfetto.protos.PerfEventConfig.CallstackSampling)
        CallstackSamplingOrBuilder {
    private static final long serialVersionUID = 0L;
      // Use CallstackSampling.newBuilder() to construct.
      private CallstackSampling(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
      }
      private CallstackSampling() {
        userFrames_ = 0;
      }

      @java.lang.Override
      @SuppressWarnings({"unused"})
      protected java.lang.Object newInstance(
          UnusedPrivateParameter unused) {
        return new CallstackSampling();
      }

      @java.lang.Override
      public final com.google.protobuf.UnknownFieldSet
      getUnknownFields() {
        return this.unknownFields;
      }
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return perfetto.protos.PerfEventConfigOuterClass.internal_static_perfetto_protos_PerfEventConfig_CallstackSampling_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return perfetto.protos.PerfEventConfigOuterClass.internal_static_perfetto_protos_PerfEventConfig_CallstackSampling_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.CallstackSampling.class, perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.CallstackSampling.Builder.class);
      }

      private int bitField0_;
      public static final int SCOPE_FIELD_NUMBER = 1;
      private perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.Scope scope_;
      /**
       * <pre>
       * Defines a set of processes for which samples are retained/skipped. If
       * unset, all samples are kept, but beware that it will be very heavy on the
       * stack unwinder, which might start dropping samples due to overload.
       * </pre>
       *
       * <code>optional .perfetto.protos.PerfEventConfig.Scope scope = 1;</code>
       * @return Whether the scope field is set.
       */
      @java.lang.Override
      public boolean hasScope() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Defines a set of processes for which samples are retained/skipped. If
       * unset, all samples are kept, but beware that it will be very heavy on the
       * stack unwinder, which might start dropping samples due to overload.
       * </pre>
       *
       * <code>optional .perfetto.protos.PerfEventConfig.Scope scope = 1;</code>
       * @return The scope.
       */
      @java.lang.Override
      public perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.Scope getScope() {
        return scope_ == null ? perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.Scope.getDefaultInstance() : scope_;
      }
      /**
       * <pre>
       * Defines a set of processes for which samples are retained/skipped. If
       * unset, all samples are kept, but beware that it will be very heavy on the
       * stack unwinder, which might start dropping samples due to overload.
       * </pre>
       *
       * <code>optional .perfetto.protos.PerfEventConfig.Scope scope = 1;</code>
       */
      @java.lang.Override
      public perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.ScopeOrBuilder getScopeOrBuilder() {
        return scope_ == null ? perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.Scope.getDefaultInstance() : scope_;
      }

      public static final int KERNEL_FRAMES_FIELD_NUMBER = 2;
      private boolean kernelFrames_ = false;
      /**
       * <pre>
       * If true, callstacks will include the kernel-space frames. Such frames can
       * be identified by a magical "kernel" string as their mapping name.
       * Requires traced_perf to be running as root, or kptr_restrict to have been
       * manually unrestricted. On Android, the platform should do the right thing
       * on debug builds.
       * This does *not* disclose KASLR, as only the function names are emitted.
       * </pre>
       *
       * <code>optional bool kernel_frames = 2;</code>
       * @return Whether the kernelFrames field is set.
       */
      @java.lang.Override
      public boolean hasKernelFrames() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * If true, callstacks will include the kernel-space frames. Such frames can
       * be identified by a magical "kernel" string as their mapping name.
       * Requires traced_perf to be running as root, or kptr_restrict to have been
       * manually unrestricted. On Android, the platform should do the right thing
       * on debug builds.
       * This does *not* disclose KASLR, as only the function names are emitted.
       * </pre>
       *
       * <code>optional bool kernel_frames = 2;</code>
       * @return The kernelFrames.
       */
      @java.lang.Override
      public boolean getKernelFrames() {
        return kernelFrames_;
      }

      public static final int USER_FRAMES_FIELD_NUMBER = 3;
      private int userFrames_ = 0;
      /**
       * <pre>
       * Whether to record and unwind userspace callstacks. If unset, defaults to
       * including userspace (UNWIND_DWARF) both for backwards compatibility and
       * as the most common default (this defaulting is only applicable if the
       * outer CallstackSampling message is explicitly set).
       * </pre>
       *
       * <code>optional .perfetto.protos.PerfEventConfig.UnwindMode user_frames = 3;</code>
       * @return Whether the userFrames field is set.
       */
      @java.lang.Override public boolean hasUserFrames() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * Whether to record and unwind userspace callstacks. If unset, defaults to
       * including userspace (UNWIND_DWARF) both for backwards compatibility and
       * as the most common default (this defaulting is only applicable if the
       * outer CallstackSampling message is explicitly set).
       * </pre>
       *
       * <code>optional .perfetto.protos.PerfEventConfig.UnwindMode user_frames = 3;</code>
       * @return The userFrames.
       */
      @java.lang.Override public perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.UnwindMode getUserFrames() {
        perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.UnwindMode result = perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.UnwindMode.forNumber(userFrames_);
        return result == null ? perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.UnwindMode.UNWIND_UNKNOWN : result;
      }

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        if (((bitField0_ & 0x00000001) != 0)) {
          output.writeMessage(1, getScope());
        }
        if (((bitField0_ & 0x00000002) != 0)) {
          output.writeBool(2, kernelFrames_);
        }
        if (((bitField0_ & 0x00000004) != 0)) {
          output.writeEnum(3, userFrames_);
        }
        getUnknownFields().writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (((bitField0_ & 0x00000001) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(1, getScope());
        }
        if (((bitField0_ & 0x00000002) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeBoolSize(2, kernelFrames_);
        }
        if (((bitField0_ & 0x00000004) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeEnumSize(3, userFrames_);
        }
        size += getUnknownFields().getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.CallstackSampling)) {
          return super.equals(obj);
        }
        perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.CallstackSampling other = (perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.CallstackSampling) obj;

        if (hasScope() != other.hasScope()) return false;
        if (hasScope()) {
          if (!getScope()
              .equals(other.getScope())) return false;
        }
        if (hasKernelFrames() != other.hasKernelFrames()) return false;
        if (hasKernelFrames()) {
          if (getKernelFrames()
              != other.getKernelFrames()) return false;
        }
        if (hasUserFrames() != other.hasUserFrames()) return false;
        if (hasUserFrames()) {
          if (userFrames_ != other.userFrames_) return false;
        }
        if (!getUnknownFields().equals(other.getUnknownFields())) return false;
        return true;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        if (hasScope()) {
          hash = (37 * hash) + SCOPE_FIELD_NUMBER;
          hash = (53 * hash) + getScope().hashCode();
        }
        if (hasKernelFrames()) {
          hash = (37 * hash) + KERNEL_FRAMES_FIELD_NUMBER;
          hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
              getKernelFrames());
        }
        if (hasUserFrames()) {
          hash = (37 * hash) + USER_FRAMES_FIELD_NUMBER;
          hash = (53 * hash) + userFrames_;
        }
        hash = (29 * hash) + getUnknownFields().hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.CallstackSampling parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.CallstackSampling parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.CallstackSampling parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.CallstackSampling parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.CallstackSampling parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.CallstackSampling parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.CallstackSampling parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.CallstackSampling parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }
      public static perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.CallstackSampling parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input);
      }
      public static perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.CallstackSampling parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.CallstackSampling parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.CallstackSampling parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.CallstackSampling prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * Protobuf type {@code perfetto.protos.PerfEventConfig.CallstackSampling}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:perfetto.protos.PerfEventConfig.CallstackSampling)
          perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.CallstackSamplingOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return perfetto.protos.PerfEventConfigOuterClass.internal_static_perfetto_protos_PerfEventConfig_CallstackSampling_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return perfetto.protos.PerfEventConfigOuterClass.internal_static_perfetto_protos_PerfEventConfig_CallstackSampling_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.CallstackSampling.class, perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.CallstackSampling.Builder.class);
        }

        // Construct using perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.CallstackSampling.newBuilder()
        private Builder() {
          maybeForceBuilderInitialization();
        }

        private Builder(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
          super(parent);
          maybeForceBuilderInitialization();
        }
        private void maybeForceBuilderInitialization() {
          if (com.google.protobuf.GeneratedMessageV3
                  .alwaysUseFieldBuilders) {
            getScopeFieldBuilder();
          }
        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          bitField0_ = 0;
          scope_ = null;
          if (scopeBuilder_ != null) {
            scopeBuilder_.dispose();
            scopeBuilder_ = null;
          }
          kernelFrames_ = false;
          userFrames_ = 0;
          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return perfetto.protos.PerfEventConfigOuterClass.internal_static_perfetto_protos_PerfEventConfig_CallstackSampling_descriptor;
        }

        @java.lang.Override
        public perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.CallstackSampling getDefaultInstanceForType() {
          return perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.CallstackSampling.getDefaultInstance();
        }

        @java.lang.Override
        public perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.CallstackSampling build() {
          perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.CallstackSampling result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.CallstackSampling buildPartial() {
          perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.CallstackSampling result = new perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.CallstackSampling(this);
          if (bitField0_ != 0) { buildPartial0(result); }
          onBuilt();
          return result;
        }

        private void buildPartial0(perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.CallstackSampling result) {
          int from_bitField0_ = bitField0_;
          int to_bitField0_ = 0;
          if (((from_bitField0_ & 0x00000001) != 0)) {
            result.scope_ = scopeBuilder_ == null
                ? scope_
                : scopeBuilder_.build();
            to_bitField0_ |= 0x00000001;
          }
          if (((from_bitField0_ & 0x00000002) != 0)) {
            result.kernelFrames_ = kernelFrames_;
            to_bitField0_ |= 0x00000002;
          }
          if (((from_bitField0_ & 0x00000004) != 0)) {
            result.userFrames_ = userFrames_;
            to_bitField0_ |= 0x00000004;
          }
          result.bitField0_ |= to_bitField0_;
        }

        @java.lang.Override
        public Builder clone() {
          return super.clone();
        }
        @java.lang.Override
        public Builder setField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.setField(field, value);
        }
        @java.lang.Override
        public Builder clearField(
            com.google.protobuf.Descriptors.FieldDescriptor field) {
          return super.clearField(field);
        }
        @java.lang.Override
        public Builder clearOneof(
            com.google.protobuf.Descriptors.OneofDescriptor oneof) {
          return super.clearOneof(oneof);
        }
        @java.lang.Override
        public Builder setRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            int index, java.lang.Object value) {
          return super.setRepeatedField(field, index, value);
        }
        @java.lang.Override
        public Builder addRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.addRepeatedField(field, value);
        }
        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.CallstackSampling) {
            return mergeFrom((perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.CallstackSampling)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.CallstackSampling other) {
          if (other == perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.CallstackSampling.getDefaultInstance()) return this;
          if (other.hasScope()) {
            mergeScope(other.getScope());
          }
          if (other.hasKernelFrames()) {
            setKernelFrames(other.getKernelFrames());
          }
          if (other.hasUserFrames()) {
            setUserFrames(other.getUserFrames());
          }
          this.mergeUnknownFields(other.getUnknownFields());
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          if (extensionRegistry == null) {
            throw new java.lang.NullPointerException();
          }
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                case 10: {
                  input.readMessage(
                      getScopeFieldBuilder().getBuilder(),
                      extensionRegistry);
                  bitField0_ |= 0x00000001;
                  break;
                } // case 10
                case 16: {
                  kernelFrames_ = input.readBool();
                  bitField0_ |= 0x00000002;
                  break;
                } // case 16
                case 24: {
                  int tmpRaw = input.readEnum();
                  perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.UnwindMode tmpValue =
                      perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.UnwindMode.forNumber(tmpRaw);
                  if (tmpValue == null) {
                    mergeUnknownVarintField(3, tmpRaw);
                  } else {
                    userFrames_ = tmpRaw;
                    bitField0_ |= 0x00000004;
                  }
                  break;
                } // case 24
                default: {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
              } // switch (tag)
            } // while (!done)
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.unwrapIOException();
          } finally {
            onChanged();
          } // finally
          return this;
        }
        private int bitField0_;

        private perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.Scope scope_;
        private com.google.protobuf.SingleFieldBuilderV3<
            perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.Scope, perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.Scope.Builder, perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.ScopeOrBuilder> scopeBuilder_;
        /**
         * <pre>
         * Defines a set of processes for which samples are retained/skipped. If
         * unset, all samples are kept, but beware that it will be very heavy on the
         * stack unwinder, which might start dropping samples due to overload.
         * </pre>
         *
         * <code>optional .perfetto.protos.PerfEventConfig.Scope scope = 1;</code>
         * @return Whether the scope field is set.
         */
        public boolean hasScope() {
          return ((bitField0_ & 0x00000001) != 0);
        }
        /**
         * <pre>
         * Defines a set of processes for which samples are retained/skipped. If
         * unset, all samples are kept, but beware that it will be very heavy on the
         * stack unwinder, which might start dropping samples due to overload.
         * </pre>
         *
         * <code>optional .perfetto.protos.PerfEventConfig.Scope scope = 1;</code>
         * @return The scope.
         */
        public perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.Scope getScope() {
          if (scopeBuilder_ == null) {
            return scope_ == null ? perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.Scope.getDefaultInstance() : scope_;
          } else {
            return scopeBuilder_.getMessage();
          }
        }
        /**
         * <pre>
         * Defines a set of processes for which samples are retained/skipped. If
         * unset, all samples are kept, but beware that it will be very heavy on the
         * stack unwinder, which might start dropping samples due to overload.
         * </pre>
         *
         * <code>optional .perfetto.protos.PerfEventConfig.Scope scope = 1;</code>
         */
        public Builder setScope(perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.Scope value) {
          if (scopeBuilder_ == null) {
            if (value == null) {
              throw new NullPointerException();
            }
            scope_ = value;
          } else {
            scopeBuilder_.setMessage(value);
          }
          bitField0_ |= 0x00000001;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Defines a set of processes for which samples are retained/skipped. If
         * unset, all samples are kept, but beware that it will be very heavy on the
         * stack unwinder, which might start dropping samples due to overload.
         * </pre>
         *
         * <code>optional .perfetto.protos.PerfEventConfig.Scope scope = 1;</code>
         */
        public Builder setScope(
            perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.Scope.Builder builderForValue) {
          if (scopeBuilder_ == null) {
            scope_ = builderForValue.build();
          } else {
            scopeBuilder_.setMessage(builderForValue.build());
          }
          bitField0_ |= 0x00000001;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Defines a set of processes for which samples are retained/skipped. If
         * unset, all samples are kept, but beware that it will be very heavy on the
         * stack unwinder, which might start dropping samples due to overload.
         * </pre>
         *
         * <code>optional .perfetto.protos.PerfEventConfig.Scope scope = 1;</code>
         */
        public Builder mergeScope(perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.Scope value) {
          if (scopeBuilder_ == null) {
            if (((bitField0_ & 0x00000001) != 0) &&
              scope_ != null &&
              scope_ != perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.Scope.getDefaultInstance()) {
              getScopeBuilder().mergeFrom(value);
            } else {
              scope_ = value;
            }
          } else {
            scopeBuilder_.mergeFrom(value);
          }
          bitField0_ |= 0x00000001;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Defines a set of processes for which samples are retained/skipped. If
         * unset, all samples are kept, but beware that it will be very heavy on the
         * stack unwinder, which might start dropping samples due to overload.
         * </pre>
         *
         * <code>optional .perfetto.protos.PerfEventConfig.Scope scope = 1;</code>
         */
        public Builder clearScope() {
          bitField0_ = (bitField0_ & ~0x00000001);
          scope_ = null;
          if (scopeBuilder_ != null) {
            scopeBuilder_.dispose();
            scopeBuilder_ = null;
          }
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Defines a set of processes for which samples are retained/skipped. If
         * unset, all samples are kept, but beware that it will be very heavy on the
         * stack unwinder, which might start dropping samples due to overload.
         * </pre>
         *
         * <code>optional .perfetto.protos.PerfEventConfig.Scope scope = 1;</code>
         */
        public perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.Scope.Builder getScopeBuilder() {
          bitField0_ |= 0x00000001;
          onChanged();
          return getScopeFieldBuilder().getBuilder();
        }
        /**
         * <pre>
         * Defines a set of processes for which samples are retained/skipped. If
         * unset, all samples are kept, but beware that it will be very heavy on the
         * stack unwinder, which might start dropping samples due to overload.
         * </pre>
         *
         * <code>optional .perfetto.protos.PerfEventConfig.Scope scope = 1;</code>
         */
        public perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.ScopeOrBuilder getScopeOrBuilder() {
          if (scopeBuilder_ != null) {
            return scopeBuilder_.getMessageOrBuilder();
          } else {
            return scope_ == null ?
                perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.Scope.getDefaultInstance() : scope_;
          }
        }
        /**
         * <pre>
         * Defines a set of processes for which samples are retained/skipped. If
         * unset, all samples are kept, but beware that it will be very heavy on the
         * stack unwinder, which might start dropping samples due to overload.
         * </pre>
         *
         * <code>optional .perfetto.protos.PerfEventConfig.Scope scope = 1;</code>
         */
        private com.google.protobuf.SingleFieldBuilderV3<
            perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.Scope, perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.Scope.Builder, perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.ScopeOrBuilder> 
            getScopeFieldBuilder() {
          if (scopeBuilder_ == null) {
            scopeBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
                perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.Scope, perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.Scope.Builder, perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.ScopeOrBuilder>(
                    getScope(),
                    getParentForChildren(),
                    isClean());
            scope_ = null;
          }
          return scopeBuilder_;
        }

        private boolean kernelFrames_ ;
        /**
         * <pre>
         * If true, callstacks will include the kernel-space frames. Such frames can
         * be identified by a magical "kernel" string as their mapping name.
         * Requires traced_perf to be running as root, or kptr_restrict to have been
         * manually unrestricted. On Android, the platform should do the right thing
         * on debug builds.
         * This does *not* disclose KASLR, as only the function names are emitted.
         * </pre>
         *
         * <code>optional bool kernel_frames = 2;</code>
         * @return Whether the kernelFrames field is set.
         */
        @java.lang.Override
        public boolean hasKernelFrames() {
          return ((bitField0_ & 0x00000002) != 0);
        }
        /**
         * <pre>
         * If true, callstacks will include the kernel-space frames. Such frames can
         * be identified by a magical "kernel" string as their mapping name.
         * Requires traced_perf to be running as root, or kptr_restrict to have been
         * manually unrestricted. On Android, the platform should do the right thing
         * on debug builds.
         * This does *not* disclose KASLR, as only the function names are emitted.
         * </pre>
         *
         * <code>optional bool kernel_frames = 2;</code>
         * @return The kernelFrames.
         */
        @java.lang.Override
        public boolean getKernelFrames() {
          return kernelFrames_;
        }
        /**
         * <pre>
         * If true, callstacks will include the kernel-space frames. Such frames can
         * be identified by a magical "kernel" string as their mapping name.
         * Requires traced_perf to be running as root, or kptr_restrict to have been
         * manually unrestricted. On Android, the platform should do the right thing
         * on debug builds.
         * This does *not* disclose KASLR, as only the function names are emitted.
         * </pre>
         *
         * <code>optional bool kernel_frames = 2;</code>
         * @param value The kernelFrames to set.
         * @return This builder for chaining.
         */
        public Builder setKernelFrames(boolean value) {
          
          kernelFrames_ = value;
          bitField0_ |= 0x00000002;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * If true, callstacks will include the kernel-space frames. Such frames can
         * be identified by a magical "kernel" string as their mapping name.
         * Requires traced_perf to be running as root, or kptr_restrict to have been
         * manually unrestricted. On Android, the platform should do the right thing
         * on debug builds.
         * This does *not* disclose KASLR, as only the function names are emitted.
         * </pre>
         *
         * <code>optional bool kernel_frames = 2;</code>
         * @return This builder for chaining.
         */
        public Builder clearKernelFrames() {
          bitField0_ = (bitField0_ & ~0x00000002);
          kernelFrames_ = false;
          onChanged();
          return this;
        }

        private int userFrames_ = 0;
        /**
         * <pre>
         * Whether to record and unwind userspace callstacks. If unset, defaults to
         * including userspace (UNWIND_DWARF) both for backwards compatibility and
         * as the most common default (this defaulting is only applicable if the
         * outer CallstackSampling message is explicitly set).
         * </pre>
         *
         * <code>optional .perfetto.protos.PerfEventConfig.UnwindMode user_frames = 3;</code>
         * @return Whether the userFrames field is set.
         */
        @java.lang.Override public boolean hasUserFrames() {
          return ((bitField0_ & 0x00000004) != 0);
        }
        /**
         * <pre>
         * Whether to record and unwind userspace callstacks. If unset, defaults to
         * including userspace (UNWIND_DWARF) both for backwards compatibility and
         * as the most common default (this defaulting is only applicable if the
         * outer CallstackSampling message is explicitly set).
         * </pre>
         *
         * <code>optional .perfetto.protos.PerfEventConfig.UnwindMode user_frames = 3;</code>
         * @return The userFrames.
         */
        @java.lang.Override
        public perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.UnwindMode getUserFrames() {
          perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.UnwindMode result = perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.UnwindMode.forNumber(userFrames_);
          return result == null ? perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.UnwindMode.UNWIND_UNKNOWN : result;
        }
        /**
         * <pre>
         * Whether to record and unwind userspace callstacks. If unset, defaults to
         * including userspace (UNWIND_DWARF) both for backwards compatibility and
         * as the most common default (this defaulting is only applicable if the
         * outer CallstackSampling message is explicitly set).
         * </pre>
         *
         * <code>optional .perfetto.protos.PerfEventConfig.UnwindMode user_frames = 3;</code>
         * @param value The userFrames to set.
         * @return This builder for chaining.
         */
        public Builder setUserFrames(perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.UnwindMode value) {
          if (value == null) {
            throw new NullPointerException();
          }
          bitField0_ |= 0x00000004;
          userFrames_ = value.getNumber();
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Whether to record and unwind userspace callstacks. If unset, defaults to
         * including userspace (UNWIND_DWARF) both for backwards compatibility and
         * as the most common default (this defaulting is only applicable if the
         * outer CallstackSampling message is explicitly set).
         * </pre>
         *
         * <code>optional .perfetto.protos.PerfEventConfig.UnwindMode user_frames = 3;</code>
         * @return This builder for chaining.
         */
        public Builder clearUserFrames() {
          bitField0_ = (bitField0_ & ~0x00000004);
          userFrames_ = 0;
          onChanged();
          return this;
        }
        @java.lang.Override
        public final Builder setUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.setUnknownFields(unknownFields);
        }

        @java.lang.Override
        public final Builder mergeUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.mergeUnknownFields(unknownFields);
        }


        // @@protoc_insertion_point(builder_scope:perfetto.protos.PerfEventConfig.CallstackSampling)
      }

      // @@protoc_insertion_point(class_scope:perfetto.protos.PerfEventConfig.CallstackSampling)
      private static final perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.CallstackSampling DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.CallstackSampling();
      }

      public static perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.CallstackSampling getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      @java.lang.Deprecated public static final com.google.protobuf.Parser<CallstackSampling>
          PARSER = new com.google.protobuf.AbstractParser<CallstackSampling>() {
        @java.lang.Override
        public CallstackSampling parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          Builder builder = newBuilder();
          try {
            builder.mergeFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.setUnfinishedMessage(builder.buildPartial());
          } catch (com.google.protobuf.UninitializedMessageException e) {
            throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
          } catch (java.io.IOException e) {
            throw new com.google.protobuf.InvalidProtocolBufferException(e)
                .setUnfinishedMessage(builder.buildPartial());
          }
          return builder.buildPartial();
        }
      };

      public static com.google.protobuf.Parser<CallstackSampling> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<CallstackSampling> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.CallstackSampling getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    public interface ScopeOrBuilder extends
        // @@protoc_insertion_point(interface_extends:perfetto.protos.PerfEventConfig.Scope)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <pre>
       * Process ID (TGID) allowlist. If this list is not empty, only matching
       * samples will be retained. If multiple allow/deny-lists are
       * specified by the config, then all of them are evaluated for each sampled
       * process.
       * </pre>
       *
       * <code>repeated int32 target_pid = 1;</code>
       * @return A list containing the targetPid.
       */
      java.util.List<java.lang.Integer> getTargetPidList();
      /**
       * <pre>
       * Process ID (TGID) allowlist. If this list is not empty, only matching
       * samples will be retained. If multiple allow/deny-lists are
       * specified by the config, then all of them are evaluated for each sampled
       * process.
       * </pre>
       *
       * <code>repeated int32 target_pid = 1;</code>
       * @return The count of targetPid.
       */
      int getTargetPidCount();
      /**
       * <pre>
       * Process ID (TGID) allowlist. If this list is not empty, only matching
       * samples will be retained. If multiple allow/deny-lists are
       * specified by the config, then all of them are evaluated for each sampled
       * process.
       * </pre>
       *
       * <code>repeated int32 target_pid = 1;</code>
       * @param index The index of the element to return.
       * @return The targetPid at the given index.
       */
      int getTargetPid(int index);

      /**
       * <pre>
       * Command line allowlist, matched against the /proc/&lt;pid&gt;/cmdline (not the
       * comm string). The semantics of this field were changed since its original
       * introduction.
       * On Android T+ (13+), this field can specify a single wildcard (*), and
       * the profiler will attempt to match it in two possible ways:
       * * if the pattern starts with a '/', then it is matched against the first
       *   segment of the cmdline (i.e. argv0). For example "/bin/e*" would match
       *   "/bin/echo".
       * * otherwise the pattern is matched against the part of argv0
       *   corresponding to the binary name (this is unrelated to /proc/pid/exe).
       *   For example "echo" would match "/bin/echo".
       * On Android S (12) and below, both this pattern and /proc/pid/cmdline get
       * normalized prior to an exact string comparison. Normalization is as
       * follows: (1) trim everything beyond the first null or "&#64;" byte; (2) if
       * the string contains forward slashes, trim everything up to and including
       * the last one.
       * Implementation note: in either case, at most 511 characters of cmdline
       * are considered.
       * </pre>
       *
       * <code>repeated string target_cmdline = 2;</code>
       * @return A list containing the targetCmdline.
       */
      java.util.List<java.lang.String>
          getTargetCmdlineList();
      /**
       * <pre>
       * Command line allowlist, matched against the /proc/&lt;pid&gt;/cmdline (not the
       * comm string). The semantics of this field were changed since its original
       * introduction.
       * On Android T+ (13+), this field can specify a single wildcard (*), and
       * the profiler will attempt to match it in two possible ways:
       * * if the pattern starts with a '/', then it is matched against the first
       *   segment of the cmdline (i.e. argv0). For example "/bin/e*" would match
       *   "/bin/echo".
       * * otherwise the pattern is matched against the part of argv0
       *   corresponding to the binary name (this is unrelated to /proc/pid/exe).
       *   For example "echo" would match "/bin/echo".
       * On Android S (12) and below, both this pattern and /proc/pid/cmdline get
       * normalized prior to an exact string comparison. Normalization is as
       * follows: (1) trim everything beyond the first null or "&#64;" byte; (2) if
       * the string contains forward slashes, trim everything up to and including
       * the last one.
       * Implementation note: in either case, at most 511 characters of cmdline
       * are considered.
       * </pre>
       *
       * <code>repeated string target_cmdline = 2;</code>
       * @return The count of targetCmdline.
       */
      int getTargetCmdlineCount();
      /**
       * <pre>
       * Command line allowlist, matched against the /proc/&lt;pid&gt;/cmdline (not the
       * comm string). The semantics of this field were changed since its original
       * introduction.
       * On Android T+ (13+), this field can specify a single wildcard (*), and
       * the profiler will attempt to match it in two possible ways:
       * * if the pattern starts with a '/', then it is matched against the first
       *   segment of the cmdline (i.e. argv0). For example "/bin/e*" would match
       *   "/bin/echo".
       * * otherwise the pattern is matched against the part of argv0
       *   corresponding to the binary name (this is unrelated to /proc/pid/exe).
       *   For example "echo" would match "/bin/echo".
       * On Android S (12) and below, both this pattern and /proc/pid/cmdline get
       * normalized prior to an exact string comparison. Normalization is as
       * follows: (1) trim everything beyond the first null or "&#64;" byte; (2) if
       * the string contains forward slashes, trim everything up to and including
       * the last one.
       * Implementation note: in either case, at most 511 characters of cmdline
       * are considered.
       * </pre>
       *
       * <code>repeated string target_cmdline = 2;</code>
       * @param index The index of the element to return.
       * @return The targetCmdline at the given index.
       */
      java.lang.String getTargetCmdline(int index);
      /**
       * <pre>
       * Command line allowlist, matched against the /proc/&lt;pid&gt;/cmdline (not the
       * comm string). The semantics of this field were changed since its original
       * introduction.
       * On Android T+ (13+), this field can specify a single wildcard (*), and
       * the profiler will attempt to match it in two possible ways:
       * * if the pattern starts with a '/', then it is matched against the first
       *   segment of the cmdline (i.e. argv0). For example "/bin/e*" would match
       *   "/bin/echo".
       * * otherwise the pattern is matched against the part of argv0
       *   corresponding to the binary name (this is unrelated to /proc/pid/exe).
       *   For example "echo" would match "/bin/echo".
       * On Android S (12) and below, both this pattern and /proc/pid/cmdline get
       * normalized prior to an exact string comparison. Normalization is as
       * follows: (1) trim everything beyond the first null or "&#64;" byte; (2) if
       * the string contains forward slashes, trim everything up to and including
       * the last one.
       * Implementation note: in either case, at most 511 characters of cmdline
       * are considered.
       * </pre>
       *
       * <code>repeated string target_cmdline = 2;</code>
       * @param index The index of the value to return.
       * @return The bytes of the targetCmdline at the given index.
       */
      com.google.protobuf.ByteString
          getTargetCmdlineBytes(int index);

      /**
       * <pre>
       * List of excluded pids.
       * </pre>
       *
       * <code>repeated int32 exclude_pid = 3;</code>
       * @return A list containing the excludePid.
       */
      java.util.List<java.lang.Integer> getExcludePidList();
      /**
       * <pre>
       * List of excluded pids.
       * </pre>
       *
       * <code>repeated int32 exclude_pid = 3;</code>
       * @return The count of excludePid.
       */
      int getExcludePidCount();
      /**
       * <pre>
       * List of excluded pids.
       * </pre>
       *
       * <code>repeated int32 exclude_pid = 3;</code>
       * @param index The index of the element to return.
       * @return The excludePid at the given index.
       */
      int getExcludePid(int index);

      /**
       * <pre>
       * List of excluded cmdlines. See description of |target_cmdline| for how
       * this is handled.
       * </pre>
       *
       * <code>repeated string exclude_cmdline = 4;</code>
       * @return A list containing the excludeCmdline.
       */
      java.util.List<java.lang.String>
          getExcludeCmdlineList();
      /**
       * <pre>
       * List of excluded cmdlines. See description of |target_cmdline| for how
       * this is handled.
       * </pre>
       *
       * <code>repeated string exclude_cmdline = 4;</code>
       * @return The count of excludeCmdline.
       */
      int getExcludeCmdlineCount();
      /**
       * <pre>
       * List of excluded cmdlines. See description of |target_cmdline| for how
       * this is handled.
       * </pre>
       *
       * <code>repeated string exclude_cmdline = 4;</code>
       * @param index The index of the element to return.
       * @return The excludeCmdline at the given index.
       */
      java.lang.String getExcludeCmdline(int index);
      /**
       * <pre>
       * List of excluded cmdlines. See description of |target_cmdline| for how
       * this is handled.
       * </pre>
       *
       * <code>repeated string exclude_cmdline = 4;</code>
       * @param index The index of the value to return.
       * @return The bytes of the excludeCmdline at the given index.
       */
      com.google.protobuf.ByteString
          getExcludeCmdlineBytes(int index);

      /**
       * <pre>
       * Number of additional command lines to sample. Only those which are
       * neither explicitly included nor excluded will be considered. Processes
       * are accepted on a first come, first served basis.
       * </pre>
       *
       * <code>optional uint32 additional_cmdline_count = 5;</code>
       * @return Whether the additionalCmdlineCount field is set.
       */
      boolean hasAdditionalCmdlineCount();
      /**
       * <pre>
       * Number of additional command lines to sample. Only those which are
       * neither explicitly included nor excluded will be considered. Processes
       * are accepted on a first come, first served basis.
       * </pre>
       *
       * <code>optional uint32 additional_cmdline_count = 5;</code>
       * @return The additionalCmdlineCount.
       */
      int getAdditionalCmdlineCount();

      /**
       * <pre>
       * If set to N, all encountered processes will be put into one of the N
       * possible bins, and only one randomly-chosen bin will be selected for
       * unwinding. The binning is simply "pid % N", under the assumption that
       * low-order bits of pids are roughly uniformly distributed. Other explicit
       * inclusions/exclusions in this |Scope| message are still respected.
       * The profiler will report the chosen shard in PerfSampleDefaults, and the
       * values will be queryable in trace processor under the "stats" table as
       * "perf_process_shard_count" and "perf_chosen_process_shard".
       * NB: all data sources in a config that set |process_shard_count| must set
       * it to the same value. The profiler will choose one bin for all those data
       * sources.
       * </pre>
       *
       * <code>optional uint32 process_shard_count = 6;</code>
       * @return Whether the processShardCount field is set.
       */
      boolean hasProcessShardCount();
      /**
       * <pre>
       * If set to N, all encountered processes will be put into one of the N
       * possible bins, and only one randomly-chosen bin will be selected for
       * unwinding. The binning is simply "pid % N", under the assumption that
       * low-order bits of pids are roughly uniformly distributed. Other explicit
       * inclusions/exclusions in this |Scope| message are still respected.
       * The profiler will report the chosen shard in PerfSampleDefaults, and the
       * values will be queryable in trace processor under the "stats" table as
       * "perf_process_shard_count" and "perf_chosen_process_shard".
       * NB: all data sources in a config that set |process_shard_count| must set
       * it to the same value. The profiler will choose one bin for all those data
       * sources.
       * </pre>
       *
       * <code>optional uint32 process_shard_count = 6;</code>
       * @return The processShardCount.
       */
      int getProcessShardCount();
    }
    /**
     * Protobuf type {@code perfetto.protos.PerfEventConfig.Scope}
     */
    public static final class Scope extends
        com.google.protobuf.GeneratedMessageV3 implements
        // @@protoc_insertion_point(message_implements:perfetto.protos.PerfEventConfig.Scope)
        ScopeOrBuilder {
    private static final long serialVersionUID = 0L;
      // Use Scope.newBuilder() to construct.
      private Scope(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
      }
      private Scope() {
        targetPid_ = emptyIntList();
        targetCmdline_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        excludePid_ = emptyIntList();
        excludeCmdline_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      }

      @java.lang.Override
      @SuppressWarnings({"unused"})
      protected java.lang.Object newInstance(
          UnusedPrivateParameter unused) {
        return new Scope();
      }

      @java.lang.Override
      public final com.google.protobuf.UnknownFieldSet
      getUnknownFields() {
        return this.unknownFields;
      }
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return perfetto.protos.PerfEventConfigOuterClass.internal_static_perfetto_protos_PerfEventConfig_Scope_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return perfetto.protos.PerfEventConfigOuterClass.internal_static_perfetto_protos_PerfEventConfig_Scope_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.Scope.class, perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.Scope.Builder.class);
      }

      private int bitField0_;
      public static final int TARGET_PID_FIELD_NUMBER = 1;
      @SuppressWarnings("serial")
      private com.google.protobuf.Internal.IntList targetPid_;
      /**
       * <pre>
       * Process ID (TGID) allowlist. If this list is not empty, only matching
       * samples will be retained. If multiple allow/deny-lists are
       * specified by the config, then all of them are evaluated for each sampled
       * process.
       * </pre>
       *
       * <code>repeated int32 target_pid = 1;</code>
       * @return A list containing the targetPid.
       */
      @java.lang.Override
      public java.util.List<java.lang.Integer>
          getTargetPidList() {
        return targetPid_;
      }
      /**
       * <pre>
       * Process ID (TGID) allowlist. If this list is not empty, only matching
       * samples will be retained. If multiple allow/deny-lists are
       * specified by the config, then all of them are evaluated for each sampled
       * process.
       * </pre>
       *
       * <code>repeated int32 target_pid = 1;</code>
       * @return The count of targetPid.
       */
      public int getTargetPidCount() {
        return targetPid_.size();
      }
      /**
       * <pre>
       * Process ID (TGID) allowlist. If this list is not empty, only matching
       * samples will be retained. If multiple allow/deny-lists are
       * specified by the config, then all of them are evaluated for each sampled
       * process.
       * </pre>
       *
       * <code>repeated int32 target_pid = 1;</code>
       * @param index The index of the element to return.
       * @return The targetPid at the given index.
       */
      public int getTargetPid(int index) {
        return targetPid_.getInt(index);
      }

      public static final int TARGET_CMDLINE_FIELD_NUMBER = 2;
      @SuppressWarnings("serial")
      private com.google.protobuf.LazyStringList targetCmdline_;
      /**
       * <pre>
       * Command line allowlist, matched against the /proc/&lt;pid&gt;/cmdline (not the
       * comm string). The semantics of this field were changed since its original
       * introduction.
       * On Android T+ (13+), this field can specify a single wildcard (*), and
       * the profiler will attempt to match it in two possible ways:
       * * if the pattern starts with a '/', then it is matched against the first
       *   segment of the cmdline (i.e. argv0). For example "/bin/e*" would match
       *   "/bin/echo".
       * * otherwise the pattern is matched against the part of argv0
       *   corresponding to the binary name (this is unrelated to /proc/pid/exe).
       *   For example "echo" would match "/bin/echo".
       * On Android S (12) and below, both this pattern and /proc/pid/cmdline get
       * normalized prior to an exact string comparison. Normalization is as
       * follows: (1) trim everything beyond the first null or "&#64;" byte; (2) if
       * the string contains forward slashes, trim everything up to and including
       * the last one.
       * Implementation note: in either case, at most 511 characters of cmdline
       * are considered.
       * </pre>
       *
       * <code>repeated string target_cmdline = 2;</code>
       * @return A list containing the targetCmdline.
       */
      public com.google.protobuf.ProtocolStringList
          getTargetCmdlineList() {
        return targetCmdline_;
      }
      /**
       * <pre>
       * Command line allowlist, matched against the /proc/&lt;pid&gt;/cmdline (not the
       * comm string). The semantics of this field were changed since its original
       * introduction.
       * On Android T+ (13+), this field can specify a single wildcard (*), and
       * the profiler will attempt to match it in two possible ways:
       * * if the pattern starts with a '/', then it is matched against the first
       *   segment of the cmdline (i.e. argv0). For example "/bin/e*" would match
       *   "/bin/echo".
       * * otherwise the pattern is matched against the part of argv0
       *   corresponding to the binary name (this is unrelated to /proc/pid/exe).
       *   For example "echo" would match "/bin/echo".
       * On Android S (12) and below, both this pattern and /proc/pid/cmdline get
       * normalized prior to an exact string comparison. Normalization is as
       * follows: (1) trim everything beyond the first null or "&#64;" byte; (2) if
       * the string contains forward slashes, trim everything up to and including
       * the last one.
       * Implementation note: in either case, at most 511 characters of cmdline
       * are considered.
       * </pre>
       *
       * <code>repeated string target_cmdline = 2;</code>
       * @return The count of targetCmdline.
       */
      public int getTargetCmdlineCount() {
        return targetCmdline_.size();
      }
      /**
       * <pre>
       * Command line allowlist, matched against the /proc/&lt;pid&gt;/cmdline (not the
       * comm string). The semantics of this field were changed since its original
       * introduction.
       * On Android T+ (13+), this field can specify a single wildcard (*), and
       * the profiler will attempt to match it in two possible ways:
       * * if the pattern starts with a '/', then it is matched against the first
       *   segment of the cmdline (i.e. argv0). For example "/bin/e*" would match
       *   "/bin/echo".
       * * otherwise the pattern is matched against the part of argv0
       *   corresponding to the binary name (this is unrelated to /proc/pid/exe).
       *   For example "echo" would match "/bin/echo".
       * On Android S (12) and below, both this pattern and /proc/pid/cmdline get
       * normalized prior to an exact string comparison. Normalization is as
       * follows: (1) trim everything beyond the first null or "&#64;" byte; (2) if
       * the string contains forward slashes, trim everything up to and including
       * the last one.
       * Implementation note: in either case, at most 511 characters of cmdline
       * are considered.
       * </pre>
       *
       * <code>repeated string target_cmdline = 2;</code>
       * @param index The index of the element to return.
       * @return The targetCmdline at the given index.
       */
      public java.lang.String getTargetCmdline(int index) {
        return targetCmdline_.get(index);
      }
      /**
       * <pre>
       * Command line allowlist, matched against the /proc/&lt;pid&gt;/cmdline (not the
       * comm string). The semantics of this field were changed since its original
       * introduction.
       * On Android T+ (13+), this field can specify a single wildcard (*), and
       * the profiler will attempt to match it in two possible ways:
       * * if the pattern starts with a '/', then it is matched against the first
       *   segment of the cmdline (i.e. argv0). For example "/bin/e*" would match
       *   "/bin/echo".
       * * otherwise the pattern is matched against the part of argv0
       *   corresponding to the binary name (this is unrelated to /proc/pid/exe).
       *   For example "echo" would match "/bin/echo".
       * On Android S (12) and below, both this pattern and /proc/pid/cmdline get
       * normalized prior to an exact string comparison. Normalization is as
       * follows: (1) trim everything beyond the first null or "&#64;" byte; (2) if
       * the string contains forward slashes, trim everything up to and including
       * the last one.
       * Implementation note: in either case, at most 511 characters of cmdline
       * are considered.
       * </pre>
       *
       * <code>repeated string target_cmdline = 2;</code>
       * @param index The index of the value to return.
       * @return The bytes of the targetCmdline at the given index.
       */
      public com.google.protobuf.ByteString
          getTargetCmdlineBytes(int index) {
        return targetCmdline_.getByteString(index);
      }

      public static final int EXCLUDE_PID_FIELD_NUMBER = 3;
      @SuppressWarnings("serial")
      private com.google.protobuf.Internal.IntList excludePid_;
      /**
       * <pre>
       * List of excluded pids.
       * </pre>
       *
       * <code>repeated int32 exclude_pid = 3;</code>
       * @return A list containing the excludePid.
       */
      @java.lang.Override
      public java.util.List<java.lang.Integer>
          getExcludePidList() {
        return excludePid_;
      }
      /**
       * <pre>
       * List of excluded pids.
       * </pre>
       *
       * <code>repeated int32 exclude_pid = 3;</code>
       * @return The count of excludePid.
       */
      public int getExcludePidCount() {
        return excludePid_.size();
      }
      /**
       * <pre>
       * List of excluded pids.
       * </pre>
       *
       * <code>repeated int32 exclude_pid = 3;</code>
       * @param index The index of the element to return.
       * @return The excludePid at the given index.
       */
      public int getExcludePid(int index) {
        return excludePid_.getInt(index);
      }

      public static final int EXCLUDE_CMDLINE_FIELD_NUMBER = 4;
      @SuppressWarnings("serial")
      private com.google.protobuf.LazyStringList excludeCmdline_;
      /**
       * <pre>
       * List of excluded cmdlines. See description of |target_cmdline| for how
       * this is handled.
       * </pre>
       *
       * <code>repeated string exclude_cmdline = 4;</code>
       * @return A list containing the excludeCmdline.
       */
      public com.google.protobuf.ProtocolStringList
          getExcludeCmdlineList() {
        return excludeCmdline_;
      }
      /**
       * <pre>
       * List of excluded cmdlines. See description of |target_cmdline| for how
       * this is handled.
       * </pre>
       *
       * <code>repeated string exclude_cmdline = 4;</code>
       * @return The count of excludeCmdline.
       */
      public int getExcludeCmdlineCount() {
        return excludeCmdline_.size();
      }
      /**
       * <pre>
       * List of excluded cmdlines. See description of |target_cmdline| for how
       * this is handled.
       * </pre>
       *
       * <code>repeated string exclude_cmdline = 4;</code>
       * @param index The index of the element to return.
       * @return The excludeCmdline at the given index.
       */
      public java.lang.String getExcludeCmdline(int index) {
        return excludeCmdline_.get(index);
      }
      /**
       * <pre>
       * List of excluded cmdlines. See description of |target_cmdline| for how
       * this is handled.
       * </pre>
       *
       * <code>repeated string exclude_cmdline = 4;</code>
       * @param index The index of the value to return.
       * @return The bytes of the excludeCmdline at the given index.
       */
      public com.google.protobuf.ByteString
          getExcludeCmdlineBytes(int index) {
        return excludeCmdline_.getByteString(index);
      }

      public static final int ADDITIONAL_CMDLINE_COUNT_FIELD_NUMBER = 5;
      private int additionalCmdlineCount_ = 0;
      /**
       * <pre>
       * Number of additional command lines to sample. Only those which are
       * neither explicitly included nor excluded will be considered. Processes
       * are accepted on a first come, first served basis.
       * </pre>
       *
       * <code>optional uint32 additional_cmdline_count = 5;</code>
       * @return Whether the additionalCmdlineCount field is set.
       */
      @java.lang.Override
      public boolean hasAdditionalCmdlineCount() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Number of additional command lines to sample. Only those which are
       * neither explicitly included nor excluded will be considered. Processes
       * are accepted on a first come, first served basis.
       * </pre>
       *
       * <code>optional uint32 additional_cmdline_count = 5;</code>
       * @return The additionalCmdlineCount.
       */
      @java.lang.Override
      public int getAdditionalCmdlineCount() {
        return additionalCmdlineCount_;
      }

      public static final int PROCESS_SHARD_COUNT_FIELD_NUMBER = 6;
      private int processShardCount_ = 0;
      /**
       * <pre>
       * If set to N, all encountered processes will be put into one of the N
       * possible bins, and only one randomly-chosen bin will be selected for
       * unwinding. The binning is simply "pid % N", under the assumption that
       * low-order bits of pids are roughly uniformly distributed. Other explicit
       * inclusions/exclusions in this |Scope| message are still respected.
       * The profiler will report the chosen shard in PerfSampleDefaults, and the
       * values will be queryable in trace processor under the "stats" table as
       * "perf_process_shard_count" and "perf_chosen_process_shard".
       * NB: all data sources in a config that set |process_shard_count| must set
       * it to the same value. The profiler will choose one bin for all those data
       * sources.
       * </pre>
       *
       * <code>optional uint32 process_shard_count = 6;</code>
       * @return Whether the processShardCount field is set.
       */
      @java.lang.Override
      public boolean hasProcessShardCount() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * If set to N, all encountered processes will be put into one of the N
       * possible bins, and only one randomly-chosen bin will be selected for
       * unwinding. The binning is simply "pid % N", under the assumption that
       * low-order bits of pids are roughly uniformly distributed. Other explicit
       * inclusions/exclusions in this |Scope| message are still respected.
       * The profiler will report the chosen shard in PerfSampleDefaults, and the
       * values will be queryable in trace processor under the "stats" table as
       * "perf_process_shard_count" and "perf_chosen_process_shard".
       * NB: all data sources in a config that set |process_shard_count| must set
       * it to the same value. The profiler will choose one bin for all those data
       * sources.
       * </pre>
       *
       * <code>optional uint32 process_shard_count = 6;</code>
       * @return The processShardCount.
       */
      @java.lang.Override
      public int getProcessShardCount() {
        return processShardCount_;
      }

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        for (int i = 0; i < targetPid_.size(); i++) {
          output.writeInt32(1, targetPid_.getInt(i));
        }
        for (int i = 0; i < targetCmdline_.size(); i++) {
          com.google.protobuf.GeneratedMessageV3.writeString(output, 2, targetCmdline_.getRaw(i));
        }
        for (int i = 0; i < excludePid_.size(); i++) {
          output.writeInt32(3, excludePid_.getInt(i));
        }
        for (int i = 0; i < excludeCmdline_.size(); i++) {
          com.google.protobuf.GeneratedMessageV3.writeString(output, 4, excludeCmdline_.getRaw(i));
        }
        if (((bitField0_ & 0x00000001) != 0)) {
          output.writeUInt32(5, additionalCmdlineCount_);
        }
        if (((bitField0_ & 0x00000002) != 0)) {
          output.writeUInt32(6, processShardCount_);
        }
        getUnknownFields().writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        {
          int dataSize = 0;
          for (int i = 0; i < targetPid_.size(); i++) {
            dataSize += com.google.protobuf.CodedOutputStream
              .computeInt32SizeNoTag(targetPid_.getInt(i));
          }
          size += dataSize;
          size += 1 * getTargetPidList().size();
        }
        {
          int dataSize = 0;
          for (int i = 0; i < targetCmdline_.size(); i++) {
            dataSize += computeStringSizeNoTag(targetCmdline_.getRaw(i));
          }
          size += dataSize;
          size += 1 * getTargetCmdlineList().size();
        }
        {
          int dataSize = 0;
          for (int i = 0; i < excludePid_.size(); i++) {
            dataSize += com.google.protobuf.CodedOutputStream
              .computeInt32SizeNoTag(excludePid_.getInt(i));
          }
          size += dataSize;
          size += 1 * getExcludePidList().size();
        }
        {
          int dataSize = 0;
          for (int i = 0; i < excludeCmdline_.size(); i++) {
            dataSize += computeStringSizeNoTag(excludeCmdline_.getRaw(i));
          }
          size += dataSize;
          size += 1 * getExcludeCmdlineList().size();
        }
        if (((bitField0_ & 0x00000001) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt32Size(5, additionalCmdlineCount_);
        }
        if (((bitField0_ & 0x00000002) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt32Size(6, processShardCount_);
        }
        size += getUnknownFields().getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.Scope)) {
          return super.equals(obj);
        }
        perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.Scope other = (perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.Scope) obj;

        if (!getTargetPidList()
            .equals(other.getTargetPidList())) return false;
        if (!getTargetCmdlineList()
            .equals(other.getTargetCmdlineList())) return false;
        if (!getExcludePidList()
            .equals(other.getExcludePidList())) return false;
        if (!getExcludeCmdlineList()
            .equals(other.getExcludeCmdlineList())) return false;
        if (hasAdditionalCmdlineCount() != other.hasAdditionalCmdlineCount()) return false;
        if (hasAdditionalCmdlineCount()) {
          if (getAdditionalCmdlineCount()
              != other.getAdditionalCmdlineCount()) return false;
        }
        if (hasProcessShardCount() != other.hasProcessShardCount()) return false;
        if (hasProcessShardCount()) {
          if (getProcessShardCount()
              != other.getProcessShardCount()) return false;
        }
        if (!getUnknownFields().equals(other.getUnknownFields())) return false;
        return true;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        if (getTargetPidCount() > 0) {
          hash = (37 * hash) + TARGET_PID_FIELD_NUMBER;
          hash = (53 * hash) + getTargetPidList().hashCode();
        }
        if (getTargetCmdlineCount() > 0) {
          hash = (37 * hash) + TARGET_CMDLINE_FIELD_NUMBER;
          hash = (53 * hash) + getTargetCmdlineList().hashCode();
        }
        if (getExcludePidCount() > 0) {
          hash = (37 * hash) + EXCLUDE_PID_FIELD_NUMBER;
          hash = (53 * hash) + getExcludePidList().hashCode();
        }
        if (getExcludeCmdlineCount() > 0) {
          hash = (37 * hash) + EXCLUDE_CMDLINE_FIELD_NUMBER;
          hash = (53 * hash) + getExcludeCmdlineList().hashCode();
        }
        if (hasAdditionalCmdlineCount()) {
          hash = (37 * hash) + ADDITIONAL_CMDLINE_COUNT_FIELD_NUMBER;
          hash = (53 * hash) + getAdditionalCmdlineCount();
        }
        if (hasProcessShardCount()) {
          hash = (37 * hash) + PROCESS_SHARD_COUNT_FIELD_NUMBER;
          hash = (53 * hash) + getProcessShardCount();
        }
        hash = (29 * hash) + getUnknownFields().hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.Scope parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.Scope parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.Scope parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.Scope parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.Scope parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.Scope parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.Scope parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.Scope parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }
      public static perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.Scope parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input);
      }
      public static perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.Scope parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.Scope parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.Scope parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.Scope prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * Protobuf type {@code perfetto.protos.PerfEventConfig.Scope}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:perfetto.protos.PerfEventConfig.Scope)
          perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.ScopeOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return perfetto.protos.PerfEventConfigOuterClass.internal_static_perfetto_protos_PerfEventConfig_Scope_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return perfetto.protos.PerfEventConfigOuterClass.internal_static_perfetto_protos_PerfEventConfig_Scope_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.Scope.class, perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.Scope.Builder.class);
        }

        // Construct using perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.Scope.newBuilder()
        private Builder() {

        }

        private Builder(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
          super(parent);

        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          bitField0_ = 0;
          targetPid_ = emptyIntList();
          targetCmdline_ = com.google.protobuf.LazyStringArrayList.EMPTY;
          bitField0_ = (bitField0_ & ~0x00000002);
          excludePid_ = emptyIntList();
          excludeCmdline_ = com.google.protobuf.LazyStringArrayList.EMPTY;
          bitField0_ = (bitField0_ & ~0x00000008);
          additionalCmdlineCount_ = 0;
          processShardCount_ = 0;
          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return perfetto.protos.PerfEventConfigOuterClass.internal_static_perfetto_protos_PerfEventConfig_Scope_descriptor;
        }

        @java.lang.Override
        public perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.Scope getDefaultInstanceForType() {
          return perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.Scope.getDefaultInstance();
        }

        @java.lang.Override
        public perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.Scope build() {
          perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.Scope result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.Scope buildPartial() {
          perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.Scope result = new perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.Scope(this);
          buildPartialRepeatedFields(result);
          if (bitField0_ != 0) { buildPartial0(result); }
          onBuilt();
          return result;
        }

        private void buildPartialRepeatedFields(perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.Scope result) {
          if (((bitField0_ & 0x00000001) != 0)) {
            targetPid_.makeImmutable();
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.targetPid_ = targetPid_;
          if (((bitField0_ & 0x00000002) != 0)) {
            targetCmdline_ = targetCmdline_.getUnmodifiableView();
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.targetCmdline_ = targetCmdline_;
          if (((bitField0_ & 0x00000004) != 0)) {
            excludePid_.makeImmutable();
            bitField0_ = (bitField0_ & ~0x00000004);
          }
          result.excludePid_ = excludePid_;
          if (((bitField0_ & 0x00000008) != 0)) {
            excludeCmdline_ = excludeCmdline_.getUnmodifiableView();
            bitField0_ = (bitField0_ & ~0x00000008);
          }
          result.excludeCmdline_ = excludeCmdline_;
        }

        private void buildPartial0(perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.Scope result) {
          int from_bitField0_ = bitField0_;
          int to_bitField0_ = 0;
          if (((from_bitField0_ & 0x00000010) != 0)) {
            result.additionalCmdlineCount_ = additionalCmdlineCount_;
            to_bitField0_ |= 0x00000001;
          }
          if (((from_bitField0_ & 0x00000020) != 0)) {
            result.processShardCount_ = processShardCount_;
            to_bitField0_ |= 0x00000002;
          }
          result.bitField0_ |= to_bitField0_;
        }

        @java.lang.Override
        public Builder clone() {
          return super.clone();
        }
        @java.lang.Override
        public Builder setField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.setField(field, value);
        }
        @java.lang.Override
        public Builder clearField(
            com.google.protobuf.Descriptors.FieldDescriptor field) {
          return super.clearField(field);
        }
        @java.lang.Override
        public Builder clearOneof(
            com.google.protobuf.Descriptors.OneofDescriptor oneof) {
          return super.clearOneof(oneof);
        }
        @java.lang.Override
        public Builder setRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            int index, java.lang.Object value) {
          return super.setRepeatedField(field, index, value);
        }
        @java.lang.Override
        public Builder addRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.addRepeatedField(field, value);
        }
        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.Scope) {
            return mergeFrom((perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.Scope)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.Scope other) {
          if (other == perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.Scope.getDefaultInstance()) return this;
          if (!other.targetPid_.isEmpty()) {
            if (targetPid_.isEmpty()) {
              targetPid_ = other.targetPid_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureTargetPidIsMutable();
              targetPid_.addAll(other.targetPid_);
            }
            onChanged();
          }
          if (!other.targetCmdline_.isEmpty()) {
            if (targetCmdline_.isEmpty()) {
              targetCmdline_ = other.targetCmdline_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureTargetCmdlineIsMutable();
              targetCmdline_.addAll(other.targetCmdline_);
            }
            onChanged();
          }
          if (!other.excludePid_.isEmpty()) {
            if (excludePid_.isEmpty()) {
              excludePid_ = other.excludePid_;
              bitField0_ = (bitField0_ & ~0x00000004);
            } else {
              ensureExcludePidIsMutable();
              excludePid_.addAll(other.excludePid_);
            }
            onChanged();
          }
          if (!other.excludeCmdline_.isEmpty()) {
            if (excludeCmdline_.isEmpty()) {
              excludeCmdline_ = other.excludeCmdline_;
              bitField0_ = (bitField0_ & ~0x00000008);
            } else {
              ensureExcludeCmdlineIsMutable();
              excludeCmdline_.addAll(other.excludeCmdline_);
            }
            onChanged();
          }
          if (other.hasAdditionalCmdlineCount()) {
            setAdditionalCmdlineCount(other.getAdditionalCmdlineCount());
          }
          if (other.hasProcessShardCount()) {
            setProcessShardCount(other.getProcessShardCount());
          }
          this.mergeUnknownFields(other.getUnknownFields());
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          if (extensionRegistry == null) {
            throw new java.lang.NullPointerException();
          }
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                case 8: {
                  int v = input.readInt32();
                  ensureTargetPidIsMutable();
                  targetPid_.addInt(v);
                  break;
                } // case 8
                case 10: {
                  int length = input.readRawVarint32();
                  int limit = input.pushLimit(length);
                  ensureTargetPidIsMutable();
                  while (input.getBytesUntilLimit() > 0) {
                    targetPid_.addInt(input.readInt32());
                  }
                  input.popLimit(limit);
                  break;
                } // case 10
                case 18: {
                  com.google.protobuf.ByteString bs = input.readBytes();
                  ensureTargetCmdlineIsMutable();
                  targetCmdline_.add(bs);
                  break;
                } // case 18
                case 24: {
                  int v = input.readInt32();
                  ensureExcludePidIsMutable();
                  excludePid_.addInt(v);
                  break;
                } // case 24
                case 26: {
                  int length = input.readRawVarint32();
                  int limit = input.pushLimit(length);
                  ensureExcludePidIsMutable();
                  while (input.getBytesUntilLimit() > 0) {
                    excludePid_.addInt(input.readInt32());
                  }
                  input.popLimit(limit);
                  break;
                } // case 26
                case 34: {
                  com.google.protobuf.ByteString bs = input.readBytes();
                  ensureExcludeCmdlineIsMutable();
                  excludeCmdline_.add(bs);
                  break;
                } // case 34
                case 40: {
                  additionalCmdlineCount_ = input.readUInt32();
                  bitField0_ |= 0x00000010;
                  break;
                } // case 40
                case 48: {
                  processShardCount_ = input.readUInt32();
                  bitField0_ |= 0x00000020;
                  break;
                } // case 48
                default: {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
              } // switch (tag)
            } // while (!done)
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.unwrapIOException();
          } finally {
            onChanged();
          } // finally
          return this;
        }
        private int bitField0_;

        private com.google.protobuf.Internal.IntList targetPid_ = emptyIntList();
        private void ensureTargetPidIsMutable() {
          if (!((bitField0_ & 0x00000001) != 0)) {
            targetPid_ = mutableCopy(targetPid_);
            bitField0_ |= 0x00000001;
          }
        }
        /**
         * <pre>
         * Process ID (TGID) allowlist. If this list is not empty, only matching
         * samples will be retained. If multiple allow/deny-lists are
         * specified by the config, then all of them are evaluated for each sampled
         * process.
         * </pre>
         *
         * <code>repeated int32 target_pid = 1;</code>
         * @return A list containing the targetPid.
         */
        public java.util.List<java.lang.Integer>
            getTargetPidList() {
          return ((bitField0_ & 0x00000001) != 0) ?
                   java.util.Collections.unmodifiableList(targetPid_) : targetPid_;
        }
        /**
         * <pre>
         * Process ID (TGID) allowlist. If this list is not empty, only matching
         * samples will be retained. If multiple allow/deny-lists are
         * specified by the config, then all of them are evaluated for each sampled
         * process.
         * </pre>
         *
         * <code>repeated int32 target_pid = 1;</code>
         * @return The count of targetPid.
         */
        public int getTargetPidCount() {
          return targetPid_.size();
        }
        /**
         * <pre>
         * Process ID (TGID) allowlist. If this list is not empty, only matching
         * samples will be retained. If multiple allow/deny-lists are
         * specified by the config, then all of them are evaluated for each sampled
         * process.
         * </pre>
         *
         * <code>repeated int32 target_pid = 1;</code>
         * @param index The index of the element to return.
         * @return The targetPid at the given index.
         */
        public int getTargetPid(int index) {
          return targetPid_.getInt(index);
        }
        /**
         * <pre>
         * Process ID (TGID) allowlist. If this list is not empty, only matching
         * samples will be retained. If multiple allow/deny-lists are
         * specified by the config, then all of them are evaluated for each sampled
         * process.
         * </pre>
         *
         * <code>repeated int32 target_pid = 1;</code>
         * @param index The index to set the value at.
         * @param value The targetPid to set.
         * @return This builder for chaining.
         */
        public Builder setTargetPid(
            int index, int value) {
          
          ensureTargetPidIsMutable();
          targetPid_.setInt(index, value);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Process ID (TGID) allowlist. If this list is not empty, only matching
         * samples will be retained. If multiple allow/deny-lists are
         * specified by the config, then all of them are evaluated for each sampled
         * process.
         * </pre>
         *
         * <code>repeated int32 target_pid = 1;</code>
         * @param value The targetPid to add.
         * @return This builder for chaining.
         */
        public Builder addTargetPid(int value) {
          
          ensureTargetPidIsMutable();
          targetPid_.addInt(value);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Process ID (TGID) allowlist. If this list is not empty, only matching
         * samples will be retained. If multiple allow/deny-lists are
         * specified by the config, then all of them are evaluated for each sampled
         * process.
         * </pre>
         *
         * <code>repeated int32 target_pid = 1;</code>
         * @param values The targetPid to add.
         * @return This builder for chaining.
         */
        public Builder addAllTargetPid(
            java.lang.Iterable<? extends java.lang.Integer> values) {
          ensureTargetPidIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, targetPid_);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Process ID (TGID) allowlist. If this list is not empty, only matching
         * samples will be retained. If multiple allow/deny-lists are
         * specified by the config, then all of them are evaluated for each sampled
         * process.
         * </pre>
         *
         * <code>repeated int32 target_pid = 1;</code>
         * @return This builder for chaining.
         */
        public Builder clearTargetPid() {
          targetPid_ = emptyIntList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
          return this;
        }

        private com.google.protobuf.LazyStringList targetCmdline_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        private void ensureTargetCmdlineIsMutable() {
          if (!((bitField0_ & 0x00000002) != 0)) {
            targetCmdline_ = new com.google.protobuf.LazyStringArrayList(targetCmdline_);
            bitField0_ |= 0x00000002;
           }
        }
        /**
         * <pre>
         * Command line allowlist, matched against the /proc/&lt;pid&gt;/cmdline (not the
         * comm string). The semantics of this field were changed since its original
         * introduction.
         * On Android T+ (13+), this field can specify a single wildcard (*), and
         * the profiler will attempt to match it in two possible ways:
         * * if the pattern starts with a '/', then it is matched against the first
         *   segment of the cmdline (i.e. argv0). For example "/bin/e*" would match
         *   "/bin/echo".
         * * otherwise the pattern is matched against the part of argv0
         *   corresponding to the binary name (this is unrelated to /proc/pid/exe).
         *   For example "echo" would match "/bin/echo".
         * On Android S (12) and below, both this pattern and /proc/pid/cmdline get
         * normalized prior to an exact string comparison. Normalization is as
         * follows: (1) trim everything beyond the first null or "&#64;" byte; (2) if
         * the string contains forward slashes, trim everything up to and including
         * the last one.
         * Implementation note: in either case, at most 511 characters of cmdline
         * are considered.
         * </pre>
         *
         * <code>repeated string target_cmdline = 2;</code>
         * @return A list containing the targetCmdline.
         */
        public com.google.protobuf.ProtocolStringList
            getTargetCmdlineList() {
          return targetCmdline_.getUnmodifiableView();
        }
        /**
         * <pre>
         * Command line allowlist, matched against the /proc/&lt;pid&gt;/cmdline (not the
         * comm string). The semantics of this field were changed since its original
         * introduction.
         * On Android T+ (13+), this field can specify a single wildcard (*), and
         * the profiler will attempt to match it in two possible ways:
         * * if the pattern starts with a '/', then it is matched against the first
         *   segment of the cmdline (i.e. argv0). For example "/bin/e*" would match
         *   "/bin/echo".
         * * otherwise the pattern is matched against the part of argv0
         *   corresponding to the binary name (this is unrelated to /proc/pid/exe).
         *   For example "echo" would match "/bin/echo".
         * On Android S (12) and below, both this pattern and /proc/pid/cmdline get
         * normalized prior to an exact string comparison. Normalization is as
         * follows: (1) trim everything beyond the first null or "&#64;" byte; (2) if
         * the string contains forward slashes, trim everything up to and including
         * the last one.
         * Implementation note: in either case, at most 511 characters of cmdline
         * are considered.
         * </pre>
         *
         * <code>repeated string target_cmdline = 2;</code>
         * @return The count of targetCmdline.
         */
        public int getTargetCmdlineCount() {
          return targetCmdline_.size();
        }
        /**
         * <pre>
         * Command line allowlist, matched against the /proc/&lt;pid&gt;/cmdline (not the
         * comm string). The semantics of this field were changed since its original
         * introduction.
         * On Android T+ (13+), this field can specify a single wildcard (*), and
         * the profiler will attempt to match it in two possible ways:
         * * if the pattern starts with a '/', then it is matched against the first
         *   segment of the cmdline (i.e. argv0). For example "/bin/e*" would match
         *   "/bin/echo".
         * * otherwise the pattern is matched against the part of argv0
         *   corresponding to the binary name (this is unrelated to /proc/pid/exe).
         *   For example "echo" would match "/bin/echo".
         * On Android S (12) and below, both this pattern and /proc/pid/cmdline get
         * normalized prior to an exact string comparison. Normalization is as
         * follows: (1) trim everything beyond the first null or "&#64;" byte; (2) if
         * the string contains forward slashes, trim everything up to and including
         * the last one.
         * Implementation note: in either case, at most 511 characters of cmdline
         * are considered.
         * </pre>
         *
         * <code>repeated string target_cmdline = 2;</code>
         * @param index The index of the element to return.
         * @return The targetCmdline at the given index.
         */
        public java.lang.String getTargetCmdline(int index) {
          return targetCmdline_.get(index);
        }
        /**
         * <pre>
         * Command line allowlist, matched against the /proc/&lt;pid&gt;/cmdline (not the
         * comm string). The semantics of this field were changed since its original
         * introduction.
         * On Android T+ (13+), this field can specify a single wildcard (*), and
         * the profiler will attempt to match it in two possible ways:
         * * if the pattern starts with a '/', then it is matched against the first
         *   segment of the cmdline (i.e. argv0). For example "/bin/e*" would match
         *   "/bin/echo".
         * * otherwise the pattern is matched against the part of argv0
         *   corresponding to the binary name (this is unrelated to /proc/pid/exe).
         *   For example "echo" would match "/bin/echo".
         * On Android S (12) and below, both this pattern and /proc/pid/cmdline get
         * normalized prior to an exact string comparison. Normalization is as
         * follows: (1) trim everything beyond the first null or "&#64;" byte; (2) if
         * the string contains forward slashes, trim everything up to and including
         * the last one.
         * Implementation note: in either case, at most 511 characters of cmdline
         * are considered.
         * </pre>
         *
         * <code>repeated string target_cmdline = 2;</code>
         * @param index The index of the value to return.
         * @return The bytes of the targetCmdline at the given index.
         */
        public com.google.protobuf.ByteString
            getTargetCmdlineBytes(int index) {
          return targetCmdline_.getByteString(index);
        }
        /**
         * <pre>
         * Command line allowlist, matched against the /proc/&lt;pid&gt;/cmdline (not the
         * comm string). The semantics of this field were changed since its original
         * introduction.
         * On Android T+ (13+), this field can specify a single wildcard (*), and
         * the profiler will attempt to match it in two possible ways:
         * * if the pattern starts with a '/', then it is matched against the first
         *   segment of the cmdline (i.e. argv0). For example "/bin/e*" would match
         *   "/bin/echo".
         * * otherwise the pattern is matched against the part of argv0
         *   corresponding to the binary name (this is unrelated to /proc/pid/exe).
         *   For example "echo" would match "/bin/echo".
         * On Android S (12) and below, both this pattern and /proc/pid/cmdline get
         * normalized prior to an exact string comparison. Normalization is as
         * follows: (1) trim everything beyond the first null or "&#64;" byte; (2) if
         * the string contains forward slashes, trim everything up to and including
         * the last one.
         * Implementation note: in either case, at most 511 characters of cmdline
         * are considered.
         * </pre>
         *
         * <code>repeated string target_cmdline = 2;</code>
         * @param index The index to set the value at.
         * @param value The targetCmdline to set.
         * @return This builder for chaining.
         */
        public Builder setTargetCmdline(
            int index, java.lang.String value) {
          if (value == null) { throw new NullPointerException(); }
          ensureTargetCmdlineIsMutable();
          targetCmdline_.set(index, value);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Command line allowlist, matched against the /proc/&lt;pid&gt;/cmdline (not the
         * comm string). The semantics of this field were changed since its original
         * introduction.
         * On Android T+ (13+), this field can specify a single wildcard (*), and
         * the profiler will attempt to match it in two possible ways:
         * * if the pattern starts with a '/', then it is matched against the first
         *   segment of the cmdline (i.e. argv0). For example "/bin/e*" would match
         *   "/bin/echo".
         * * otherwise the pattern is matched against the part of argv0
         *   corresponding to the binary name (this is unrelated to /proc/pid/exe).
         *   For example "echo" would match "/bin/echo".
         * On Android S (12) and below, both this pattern and /proc/pid/cmdline get
         * normalized prior to an exact string comparison. Normalization is as
         * follows: (1) trim everything beyond the first null or "&#64;" byte; (2) if
         * the string contains forward slashes, trim everything up to and including
         * the last one.
         * Implementation note: in either case, at most 511 characters of cmdline
         * are considered.
         * </pre>
         *
         * <code>repeated string target_cmdline = 2;</code>
         * @param value The targetCmdline to add.
         * @return This builder for chaining.
         */
        public Builder addTargetCmdline(
            java.lang.String value) {
          if (value == null) { throw new NullPointerException(); }
          ensureTargetCmdlineIsMutable();
          targetCmdline_.add(value);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Command line allowlist, matched against the /proc/&lt;pid&gt;/cmdline (not the
         * comm string). The semantics of this field were changed since its original
         * introduction.
         * On Android T+ (13+), this field can specify a single wildcard (*), and
         * the profiler will attempt to match it in two possible ways:
         * * if the pattern starts with a '/', then it is matched against the first
         *   segment of the cmdline (i.e. argv0). For example "/bin/e*" would match
         *   "/bin/echo".
         * * otherwise the pattern is matched against the part of argv0
         *   corresponding to the binary name (this is unrelated to /proc/pid/exe).
         *   For example "echo" would match "/bin/echo".
         * On Android S (12) and below, both this pattern and /proc/pid/cmdline get
         * normalized prior to an exact string comparison. Normalization is as
         * follows: (1) trim everything beyond the first null or "&#64;" byte; (2) if
         * the string contains forward slashes, trim everything up to and including
         * the last one.
         * Implementation note: in either case, at most 511 characters of cmdline
         * are considered.
         * </pre>
         *
         * <code>repeated string target_cmdline = 2;</code>
         * @param values The targetCmdline to add.
         * @return This builder for chaining.
         */
        public Builder addAllTargetCmdline(
            java.lang.Iterable<java.lang.String> values) {
          ensureTargetCmdlineIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, targetCmdline_);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Command line allowlist, matched against the /proc/&lt;pid&gt;/cmdline (not the
         * comm string). The semantics of this field were changed since its original
         * introduction.
         * On Android T+ (13+), this field can specify a single wildcard (*), and
         * the profiler will attempt to match it in two possible ways:
         * * if the pattern starts with a '/', then it is matched against the first
         *   segment of the cmdline (i.e. argv0). For example "/bin/e*" would match
         *   "/bin/echo".
         * * otherwise the pattern is matched against the part of argv0
         *   corresponding to the binary name (this is unrelated to /proc/pid/exe).
         *   For example "echo" would match "/bin/echo".
         * On Android S (12) and below, both this pattern and /proc/pid/cmdline get
         * normalized prior to an exact string comparison. Normalization is as
         * follows: (1) trim everything beyond the first null or "&#64;" byte; (2) if
         * the string contains forward slashes, trim everything up to and including
         * the last one.
         * Implementation note: in either case, at most 511 characters of cmdline
         * are considered.
         * </pre>
         *
         * <code>repeated string target_cmdline = 2;</code>
         * @return This builder for chaining.
         */
        public Builder clearTargetCmdline() {
          targetCmdline_ = com.google.protobuf.LazyStringArrayList.EMPTY;
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Command line allowlist, matched against the /proc/&lt;pid&gt;/cmdline (not the
         * comm string). The semantics of this field were changed since its original
         * introduction.
         * On Android T+ (13+), this field can specify a single wildcard (*), and
         * the profiler will attempt to match it in two possible ways:
         * * if the pattern starts with a '/', then it is matched against the first
         *   segment of the cmdline (i.e. argv0). For example "/bin/e*" would match
         *   "/bin/echo".
         * * otherwise the pattern is matched against the part of argv0
         *   corresponding to the binary name (this is unrelated to /proc/pid/exe).
         *   For example "echo" would match "/bin/echo".
         * On Android S (12) and below, both this pattern and /proc/pid/cmdline get
         * normalized prior to an exact string comparison. Normalization is as
         * follows: (1) trim everything beyond the first null or "&#64;" byte; (2) if
         * the string contains forward slashes, trim everything up to and including
         * the last one.
         * Implementation note: in either case, at most 511 characters of cmdline
         * are considered.
         * </pre>
         *
         * <code>repeated string target_cmdline = 2;</code>
         * @param value The bytes of the targetCmdline to add.
         * @return This builder for chaining.
         */
        public Builder addTargetCmdlineBytes(
            com.google.protobuf.ByteString value) {
          if (value == null) { throw new NullPointerException(); }
          ensureTargetCmdlineIsMutable();
          targetCmdline_.add(value);
          onChanged();
          return this;
        }

        private com.google.protobuf.Internal.IntList excludePid_ = emptyIntList();
        private void ensureExcludePidIsMutable() {
          if (!((bitField0_ & 0x00000004) != 0)) {
            excludePid_ = mutableCopy(excludePid_);
            bitField0_ |= 0x00000004;
          }
        }
        /**
         * <pre>
         * List of excluded pids.
         * </pre>
         *
         * <code>repeated int32 exclude_pid = 3;</code>
         * @return A list containing the excludePid.
         */
        public java.util.List<java.lang.Integer>
            getExcludePidList() {
          return ((bitField0_ & 0x00000004) != 0) ?
                   java.util.Collections.unmodifiableList(excludePid_) : excludePid_;
        }
        /**
         * <pre>
         * List of excluded pids.
         * </pre>
         *
         * <code>repeated int32 exclude_pid = 3;</code>
         * @return The count of excludePid.
         */
        public int getExcludePidCount() {
          return excludePid_.size();
        }
        /**
         * <pre>
         * List of excluded pids.
         * </pre>
         *
         * <code>repeated int32 exclude_pid = 3;</code>
         * @param index The index of the element to return.
         * @return The excludePid at the given index.
         */
        public int getExcludePid(int index) {
          return excludePid_.getInt(index);
        }
        /**
         * <pre>
         * List of excluded pids.
         * </pre>
         *
         * <code>repeated int32 exclude_pid = 3;</code>
         * @param index The index to set the value at.
         * @param value The excludePid to set.
         * @return This builder for chaining.
         */
        public Builder setExcludePid(
            int index, int value) {
          
          ensureExcludePidIsMutable();
          excludePid_.setInt(index, value);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * List of excluded pids.
         * </pre>
         *
         * <code>repeated int32 exclude_pid = 3;</code>
         * @param value The excludePid to add.
         * @return This builder for chaining.
         */
        public Builder addExcludePid(int value) {
          
          ensureExcludePidIsMutable();
          excludePid_.addInt(value);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * List of excluded pids.
         * </pre>
         *
         * <code>repeated int32 exclude_pid = 3;</code>
         * @param values The excludePid to add.
         * @return This builder for chaining.
         */
        public Builder addAllExcludePid(
            java.lang.Iterable<? extends java.lang.Integer> values) {
          ensureExcludePidIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, excludePid_);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * List of excluded pids.
         * </pre>
         *
         * <code>repeated int32 exclude_pid = 3;</code>
         * @return This builder for chaining.
         */
        public Builder clearExcludePid() {
          excludePid_ = emptyIntList();
          bitField0_ = (bitField0_ & ~0x00000004);
          onChanged();
          return this;
        }

        private com.google.protobuf.LazyStringList excludeCmdline_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        private void ensureExcludeCmdlineIsMutable() {
          if (!((bitField0_ & 0x00000008) != 0)) {
            excludeCmdline_ = new com.google.protobuf.LazyStringArrayList(excludeCmdline_);
            bitField0_ |= 0x00000008;
           }
        }
        /**
         * <pre>
         * List of excluded cmdlines. See description of |target_cmdline| for how
         * this is handled.
         * </pre>
         *
         * <code>repeated string exclude_cmdline = 4;</code>
         * @return A list containing the excludeCmdline.
         */
        public com.google.protobuf.ProtocolStringList
            getExcludeCmdlineList() {
          return excludeCmdline_.getUnmodifiableView();
        }
        /**
         * <pre>
         * List of excluded cmdlines. See description of |target_cmdline| for how
         * this is handled.
         * </pre>
         *
         * <code>repeated string exclude_cmdline = 4;</code>
         * @return The count of excludeCmdline.
         */
        public int getExcludeCmdlineCount() {
          return excludeCmdline_.size();
        }
        /**
         * <pre>
         * List of excluded cmdlines. See description of |target_cmdline| for how
         * this is handled.
         * </pre>
         *
         * <code>repeated string exclude_cmdline = 4;</code>
         * @param index The index of the element to return.
         * @return The excludeCmdline at the given index.
         */
        public java.lang.String getExcludeCmdline(int index) {
          return excludeCmdline_.get(index);
        }
        /**
         * <pre>
         * List of excluded cmdlines. See description of |target_cmdline| for how
         * this is handled.
         * </pre>
         *
         * <code>repeated string exclude_cmdline = 4;</code>
         * @param index The index of the value to return.
         * @return The bytes of the excludeCmdline at the given index.
         */
        public com.google.protobuf.ByteString
            getExcludeCmdlineBytes(int index) {
          return excludeCmdline_.getByteString(index);
        }
        /**
         * <pre>
         * List of excluded cmdlines. See description of |target_cmdline| for how
         * this is handled.
         * </pre>
         *
         * <code>repeated string exclude_cmdline = 4;</code>
         * @param index The index to set the value at.
         * @param value The excludeCmdline to set.
         * @return This builder for chaining.
         */
        public Builder setExcludeCmdline(
            int index, java.lang.String value) {
          if (value == null) { throw new NullPointerException(); }
          ensureExcludeCmdlineIsMutable();
          excludeCmdline_.set(index, value);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * List of excluded cmdlines. See description of |target_cmdline| for how
         * this is handled.
         * </pre>
         *
         * <code>repeated string exclude_cmdline = 4;</code>
         * @param value The excludeCmdline to add.
         * @return This builder for chaining.
         */
        public Builder addExcludeCmdline(
            java.lang.String value) {
          if (value == null) { throw new NullPointerException(); }
          ensureExcludeCmdlineIsMutable();
          excludeCmdline_.add(value);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * List of excluded cmdlines. See description of |target_cmdline| for how
         * this is handled.
         * </pre>
         *
         * <code>repeated string exclude_cmdline = 4;</code>
         * @param values The excludeCmdline to add.
         * @return This builder for chaining.
         */
        public Builder addAllExcludeCmdline(
            java.lang.Iterable<java.lang.String> values) {
          ensureExcludeCmdlineIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, excludeCmdline_);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * List of excluded cmdlines. See description of |target_cmdline| for how
         * this is handled.
         * </pre>
         *
         * <code>repeated string exclude_cmdline = 4;</code>
         * @return This builder for chaining.
         */
        public Builder clearExcludeCmdline() {
          excludeCmdline_ = com.google.protobuf.LazyStringArrayList.EMPTY;
          bitField0_ = (bitField0_ & ~0x00000008);
          onChanged();
          return this;
        }
        /**
         * <pre>
         * List of excluded cmdlines. See description of |target_cmdline| for how
         * this is handled.
         * </pre>
         *
         * <code>repeated string exclude_cmdline = 4;</code>
         * @param value The bytes of the excludeCmdline to add.
         * @return This builder for chaining.
         */
        public Builder addExcludeCmdlineBytes(
            com.google.protobuf.ByteString value) {
          if (value == null) { throw new NullPointerException(); }
          ensureExcludeCmdlineIsMutable();
          excludeCmdline_.add(value);
          onChanged();
          return this;
        }

        private int additionalCmdlineCount_ ;
        /**
         * <pre>
         * Number of additional command lines to sample. Only those which are
         * neither explicitly included nor excluded will be considered. Processes
         * are accepted on a first come, first served basis.
         * </pre>
         *
         * <code>optional uint32 additional_cmdline_count = 5;</code>
         * @return Whether the additionalCmdlineCount field is set.
         */
        @java.lang.Override
        public boolean hasAdditionalCmdlineCount() {
          return ((bitField0_ & 0x00000010) != 0);
        }
        /**
         * <pre>
         * Number of additional command lines to sample. Only those which are
         * neither explicitly included nor excluded will be considered. Processes
         * are accepted on a first come, first served basis.
         * </pre>
         *
         * <code>optional uint32 additional_cmdline_count = 5;</code>
         * @return The additionalCmdlineCount.
         */
        @java.lang.Override
        public int getAdditionalCmdlineCount() {
          return additionalCmdlineCount_;
        }
        /**
         * <pre>
         * Number of additional command lines to sample. Only those which are
         * neither explicitly included nor excluded will be considered. Processes
         * are accepted on a first come, first served basis.
         * </pre>
         *
         * <code>optional uint32 additional_cmdline_count = 5;</code>
         * @param value The additionalCmdlineCount to set.
         * @return This builder for chaining.
         */
        public Builder setAdditionalCmdlineCount(int value) {
          
          additionalCmdlineCount_ = value;
          bitField0_ |= 0x00000010;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Number of additional command lines to sample. Only those which are
         * neither explicitly included nor excluded will be considered. Processes
         * are accepted on a first come, first served basis.
         * </pre>
         *
         * <code>optional uint32 additional_cmdline_count = 5;</code>
         * @return This builder for chaining.
         */
        public Builder clearAdditionalCmdlineCount() {
          bitField0_ = (bitField0_ & ~0x00000010);
          additionalCmdlineCount_ = 0;
          onChanged();
          return this;
        }

        private int processShardCount_ ;
        /**
         * <pre>
         * If set to N, all encountered processes will be put into one of the N
         * possible bins, and only one randomly-chosen bin will be selected for
         * unwinding. The binning is simply "pid % N", under the assumption that
         * low-order bits of pids are roughly uniformly distributed. Other explicit
         * inclusions/exclusions in this |Scope| message are still respected.
         * The profiler will report the chosen shard in PerfSampleDefaults, and the
         * values will be queryable in trace processor under the "stats" table as
         * "perf_process_shard_count" and "perf_chosen_process_shard".
         * NB: all data sources in a config that set |process_shard_count| must set
         * it to the same value. The profiler will choose one bin for all those data
         * sources.
         * </pre>
         *
         * <code>optional uint32 process_shard_count = 6;</code>
         * @return Whether the processShardCount field is set.
         */
        @java.lang.Override
        public boolean hasProcessShardCount() {
          return ((bitField0_ & 0x00000020) != 0);
        }
        /**
         * <pre>
         * If set to N, all encountered processes will be put into one of the N
         * possible bins, and only one randomly-chosen bin will be selected for
         * unwinding. The binning is simply "pid % N", under the assumption that
         * low-order bits of pids are roughly uniformly distributed. Other explicit
         * inclusions/exclusions in this |Scope| message are still respected.
         * The profiler will report the chosen shard in PerfSampleDefaults, and the
         * values will be queryable in trace processor under the "stats" table as
         * "perf_process_shard_count" and "perf_chosen_process_shard".
         * NB: all data sources in a config that set |process_shard_count| must set
         * it to the same value. The profiler will choose one bin for all those data
         * sources.
         * </pre>
         *
         * <code>optional uint32 process_shard_count = 6;</code>
         * @return The processShardCount.
         */
        @java.lang.Override
        public int getProcessShardCount() {
          return processShardCount_;
        }
        /**
         * <pre>
         * If set to N, all encountered processes will be put into one of the N
         * possible bins, and only one randomly-chosen bin will be selected for
         * unwinding. The binning is simply "pid % N", under the assumption that
         * low-order bits of pids are roughly uniformly distributed. Other explicit
         * inclusions/exclusions in this |Scope| message are still respected.
         * The profiler will report the chosen shard in PerfSampleDefaults, and the
         * values will be queryable in trace processor under the "stats" table as
         * "perf_process_shard_count" and "perf_chosen_process_shard".
         * NB: all data sources in a config that set |process_shard_count| must set
         * it to the same value. The profiler will choose one bin for all those data
         * sources.
         * </pre>
         *
         * <code>optional uint32 process_shard_count = 6;</code>
         * @param value The processShardCount to set.
         * @return This builder for chaining.
         */
        public Builder setProcessShardCount(int value) {
          
          processShardCount_ = value;
          bitField0_ |= 0x00000020;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * If set to N, all encountered processes will be put into one of the N
         * possible bins, and only one randomly-chosen bin will be selected for
         * unwinding. The binning is simply "pid % N", under the assumption that
         * low-order bits of pids are roughly uniformly distributed. Other explicit
         * inclusions/exclusions in this |Scope| message are still respected.
         * The profiler will report the chosen shard in PerfSampleDefaults, and the
         * values will be queryable in trace processor under the "stats" table as
         * "perf_process_shard_count" and "perf_chosen_process_shard".
         * NB: all data sources in a config that set |process_shard_count| must set
         * it to the same value. The profiler will choose one bin for all those data
         * sources.
         * </pre>
         *
         * <code>optional uint32 process_shard_count = 6;</code>
         * @return This builder for chaining.
         */
        public Builder clearProcessShardCount() {
          bitField0_ = (bitField0_ & ~0x00000020);
          processShardCount_ = 0;
          onChanged();
          return this;
        }
        @java.lang.Override
        public final Builder setUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.setUnknownFields(unknownFields);
        }

        @java.lang.Override
        public final Builder mergeUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.mergeUnknownFields(unknownFields);
        }


        // @@protoc_insertion_point(builder_scope:perfetto.protos.PerfEventConfig.Scope)
      }

      // @@protoc_insertion_point(class_scope:perfetto.protos.PerfEventConfig.Scope)
      private static final perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.Scope DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.Scope();
      }

      public static perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.Scope getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      @java.lang.Deprecated public static final com.google.protobuf.Parser<Scope>
          PARSER = new com.google.protobuf.AbstractParser<Scope>() {
        @java.lang.Override
        public Scope parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          Builder builder = newBuilder();
          try {
            builder.mergeFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.setUnfinishedMessage(builder.buildPartial());
          } catch (com.google.protobuf.UninitializedMessageException e) {
            throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
          } catch (java.io.IOException e) {
            throw new com.google.protobuf.InvalidProtocolBufferException(e)
                .setUnfinishedMessage(builder.buildPartial());
          }
          return builder.buildPartial();
        }
      };

      public static com.google.protobuf.Parser<Scope> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<Scope> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.Scope getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    private int bitField0_;
    public static final int TIMEBASE_FIELD_NUMBER = 15;
    private perfetto.protos.PerfEventsOuterClass.PerfEvents.Timebase timebase_;
    /**
     * <pre>
     * What event to sample on, and how often.
     * Defined in common/perf_events.proto.
     * </pre>
     *
     * <code>optional .perfetto.protos.PerfEvents.Timebase timebase = 15;</code>
     * @return Whether the timebase field is set.
     */
    @java.lang.Override
    public boolean hasTimebase() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * What event to sample on, and how often.
     * Defined in common/perf_events.proto.
     * </pre>
     *
     * <code>optional .perfetto.protos.PerfEvents.Timebase timebase = 15;</code>
     * @return The timebase.
     */
    @java.lang.Override
    public perfetto.protos.PerfEventsOuterClass.PerfEvents.Timebase getTimebase() {
      return timebase_ == null ? perfetto.protos.PerfEventsOuterClass.PerfEvents.Timebase.getDefaultInstance() : timebase_;
    }
    /**
     * <pre>
     * What event to sample on, and how often.
     * Defined in common/perf_events.proto.
     * </pre>
     *
     * <code>optional .perfetto.protos.PerfEvents.Timebase timebase = 15;</code>
     */
    @java.lang.Override
    public perfetto.protos.PerfEventsOuterClass.PerfEvents.TimebaseOrBuilder getTimebaseOrBuilder() {
      return timebase_ == null ? perfetto.protos.PerfEventsOuterClass.PerfEvents.Timebase.getDefaultInstance() : timebase_;
    }

    public static final int CALLSTACK_SAMPLING_FIELD_NUMBER = 16;
    private perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.CallstackSampling callstackSampling_;
    /**
     * <pre>
     * If set, the profiler will sample userspace processes' callstacks at the
     * interval specified by the |timebase|.
     * If unset, the profiler will record only the event counts.
     * </pre>
     *
     * <code>optional .perfetto.protos.PerfEventConfig.CallstackSampling callstack_sampling = 16;</code>
     * @return Whether the callstackSampling field is set.
     */
    @java.lang.Override
    public boolean hasCallstackSampling() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * If set, the profiler will sample userspace processes' callstacks at the
     * interval specified by the |timebase|.
     * If unset, the profiler will record only the event counts.
     * </pre>
     *
     * <code>optional .perfetto.protos.PerfEventConfig.CallstackSampling callstack_sampling = 16;</code>
     * @return The callstackSampling.
     */
    @java.lang.Override
    public perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.CallstackSampling getCallstackSampling() {
      return callstackSampling_ == null ? perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.CallstackSampling.getDefaultInstance() : callstackSampling_;
    }
    /**
     * <pre>
     * If set, the profiler will sample userspace processes' callstacks at the
     * interval specified by the |timebase|.
     * If unset, the profiler will record only the event counts.
     * </pre>
     *
     * <code>optional .perfetto.protos.PerfEventConfig.CallstackSampling callstack_sampling = 16;</code>
     */
    @java.lang.Override
    public perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.CallstackSamplingOrBuilder getCallstackSamplingOrBuilder() {
      return callstackSampling_ == null ? perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.CallstackSampling.getDefaultInstance() : callstackSampling_;
    }

    public static final int RING_BUFFER_READ_PERIOD_MS_FIELD_NUMBER = 8;
    private int ringBufferReadPeriodMs_ = 0;
    /**
     * <pre>
     * How often the per-cpu ring buffers are read by the producer.
     * If unset, an implementation-defined default is used.
     * </pre>
     *
     * <code>optional uint32 ring_buffer_read_period_ms = 8;</code>
     * @return Whether the ringBufferReadPeriodMs field is set.
     */
    @java.lang.Override
    public boolean hasRingBufferReadPeriodMs() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * How often the per-cpu ring buffers are read by the producer.
     * If unset, an implementation-defined default is used.
     * </pre>
     *
     * <code>optional uint32 ring_buffer_read_period_ms = 8;</code>
     * @return The ringBufferReadPeriodMs.
     */
    @java.lang.Override
    public int getRingBufferReadPeriodMs() {
      return ringBufferReadPeriodMs_;
    }

    public static final int RING_BUFFER_PAGES_FIELD_NUMBER = 3;
    private int ringBufferPages_ = 0;
    /**
     * <pre>
     * Size (in 4k pages) of each per-cpu ring buffer that is filled by the
     * kernel. If set, must be a power of two.
     * If unset, an implementation-defined default is used.
     * </pre>
     *
     * <code>optional uint32 ring_buffer_pages = 3;</code>
     * @return Whether the ringBufferPages field is set.
     */
    @java.lang.Override
    public boolean hasRingBufferPages() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * Size (in 4k pages) of each per-cpu ring buffer that is filled by the
     * kernel. If set, must be a power of two.
     * If unset, an implementation-defined default is used.
     * </pre>
     *
     * <code>optional uint32 ring_buffer_pages = 3;</code>
     * @return The ringBufferPages.
     */
    @java.lang.Override
    public int getRingBufferPages() {
      return ringBufferPages_;
    }

    public static final int MAX_ENQUEUED_FOOTPRINT_KB_FIELD_NUMBER = 17;
    private long maxEnqueuedFootprintKb_ = 0L;
    /**
     * <pre>
     * Drop samples if the heap memory held by the samples in the unwinder queue
     * is above the given limit. This counts the memory across all concurrent data
     * sources (not just this one's), and there is no fairness guarantee - the
     * whole quota might be used up by a concurrent source.
     * </pre>
     *
     * <code>optional uint64 max_enqueued_footprint_kb = 17;</code>
     * @return Whether the maxEnqueuedFootprintKb field is set.
     */
    @java.lang.Override
    public boolean hasMaxEnqueuedFootprintKb() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * Drop samples if the heap memory held by the samples in the unwinder queue
     * is above the given limit. This counts the memory across all concurrent data
     * sources (not just this one's), and there is no fairness guarantee - the
     * whole quota might be used up by a concurrent source.
     * </pre>
     *
     * <code>optional uint64 max_enqueued_footprint_kb = 17;</code>
     * @return The maxEnqueuedFootprintKb.
     */
    @java.lang.Override
    public long getMaxEnqueuedFootprintKb() {
      return maxEnqueuedFootprintKb_;
    }

    public static final int MAX_DAEMON_MEMORY_KB_FIELD_NUMBER = 13;
    private int maxDaemonMemoryKb_ = 0;
    /**
     * <pre>
     * Stop the data source if traced_perf's combined {RssAnon + Swap} memory
     * footprint exceeds this value.
     * </pre>
     *
     * <code>optional uint32 max_daemon_memory_kb = 13;</code>
     * @return Whether the maxDaemonMemoryKb field is set.
     */
    @java.lang.Override
    public boolean hasMaxDaemonMemoryKb() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * Stop the data source if traced_perf's combined {RssAnon + Swap} memory
     * footprint exceeds this value.
     * </pre>
     *
     * <code>optional uint32 max_daemon_memory_kb = 13;</code>
     * @return The maxDaemonMemoryKb.
     */
    @java.lang.Override
    public int getMaxDaemonMemoryKb() {
      return maxDaemonMemoryKb_;
    }

    public static final int REMOTE_DESCRIPTOR_TIMEOUT_MS_FIELD_NUMBER = 9;
    private int remoteDescriptorTimeoutMs_ = 0;
    /**
     * <pre>
     * Timeout for the remote /proc/&lt;pid&gt;/{maps,mem} file descriptors for a
     * sampled process. This is primarily for Android, where this lookup is
     * asynchronous. As long as the producer is waiting, the associated samples
     * will be kept enqueued (putting pressure on the capacity of the shared
     * unwinding queue). Once a lookup for a process expires, all associated
     * samples are discarded. However, if the lookup still succeeds after the
     * timeout, future samples will be handled normally.
     * If unset, an implementation-defined default is used.
     * </pre>
     *
     * <code>optional uint32 remote_descriptor_timeout_ms = 9;</code>
     * @return Whether the remoteDescriptorTimeoutMs field is set.
     */
    @java.lang.Override
    public boolean hasRemoteDescriptorTimeoutMs() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <pre>
     * Timeout for the remote /proc/&lt;pid&gt;/{maps,mem} file descriptors for a
     * sampled process. This is primarily for Android, where this lookup is
     * asynchronous. As long as the producer is waiting, the associated samples
     * will be kept enqueued (putting pressure on the capacity of the shared
     * unwinding queue). Once a lookup for a process expires, all associated
     * samples are discarded. However, if the lookup still succeeds after the
     * timeout, future samples will be handled normally.
     * If unset, an implementation-defined default is used.
     * </pre>
     *
     * <code>optional uint32 remote_descriptor_timeout_ms = 9;</code>
     * @return The remoteDescriptorTimeoutMs.
     */
    @java.lang.Override
    public int getRemoteDescriptorTimeoutMs() {
      return remoteDescriptorTimeoutMs_;
    }

    public static final int UNWIND_STATE_CLEAR_PERIOD_MS_FIELD_NUMBER = 10;
    private int unwindStateClearPeriodMs_ = 0;
    /**
     * <pre>
     * Optional period for clearing state cached by the unwinder. This is a heavy
     * operation that is only necessary for traces that target a wide set of
     * processes, and require the memory footprint to be reset periodically.
     * If unset, the cached state will not be cleared.
     * </pre>
     *
     * <code>optional uint32 unwind_state_clear_period_ms = 10;</code>
     * @return Whether the unwindStateClearPeriodMs field is set.
     */
    @java.lang.Override
    public boolean hasUnwindStateClearPeriodMs() {
      return ((bitField0_ & 0x00000080) != 0);
    }
    /**
     * <pre>
     * Optional period for clearing state cached by the unwinder. This is a heavy
     * operation that is only necessary for traces that target a wide set of
     * processes, and require the memory footprint to be reset periodically.
     * If unset, the cached state will not be cleared.
     * </pre>
     *
     * <code>optional uint32 unwind_state_clear_period_ms = 10;</code>
     * @return The unwindStateClearPeriodMs.
     */
    @java.lang.Override
    public int getUnwindStateClearPeriodMs() {
      return unwindStateClearPeriodMs_;
    }

    public static final int TARGET_INSTALLED_BY_FIELD_NUMBER = 18;
    @SuppressWarnings("serial")
    private com.google.protobuf.LazyStringList targetInstalledBy_;
    /**
     * <pre>
     * If set, only profile target if it was installed by a package with one of
     * these names. Special values:
     * * "&#64;system": installed on the system partition
     * * "&#64;product": installed on the product partition
     * * "&#64;null": sideloaded
     * Supported on Android 12+.
     * </pre>
     *
     * <code>repeated string target_installed_by = 18;</code>
     * @return A list containing the targetInstalledBy.
     */
    public com.google.protobuf.ProtocolStringList
        getTargetInstalledByList() {
      return targetInstalledBy_;
    }
    /**
     * <pre>
     * If set, only profile target if it was installed by a package with one of
     * these names. Special values:
     * * "&#64;system": installed on the system partition
     * * "&#64;product": installed on the product partition
     * * "&#64;null": sideloaded
     * Supported on Android 12+.
     * </pre>
     *
     * <code>repeated string target_installed_by = 18;</code>
     * @return The count of targetInstalledBy.
     */
    public int getTargetInstalledByCount() {
      return targetInstalledBy_.size();
    }
    /**
     * <pre>
     * If set, only profile target if it was installed by a package with one of
     * these names. Special values:
     * * "&#64;system": installed on the system partition
     * * "&#64;product": installed on the product partition
     * * "&#64;null": sideloaded
     * Supported on Android 12+.
     * </pre>
     *
     * <code>repeated string target_installed_by = 18;</code>
     * @param index The index of the element to return.
     * @return The targetInstalledBy at the given index.
     */
    public java.lang.String getTargetInstalledBy(int index) {
      return targetInstalledBy_.get(index);
    }
    /**
     * <pre>
     * If set, only profile target if it was installed by a package with one of
     * these names. Special values:
     * * "&#64;system": installed on the system partition
     * * "&#64;product": installed on the product partition
     * * "&#64;null": sideloaded
     * Supported on Android 12+.
     * </pre>
     *
     * <code>repeated string target_installed_by = 18;</code>
     * @param index The index of the value to return.
     * @return The bytes of the targetInstalledBy at the given index.
     */
    public com.google.protobuf.ByteString
        getTargetInstalledByBytes(int index) {
      return targetInstalledBy_.getByteString(index);
    }

    public static final int ALL_CPUS_FIELD_NUMBER = 1;
    private boolean allCpus_ = false;
    /**
     * <pre>
     * Note: legacy configs had to set |all_cpus| to true to pass parsing.
     * We rely on this to detect such configs.
     * </pre>
     *
     * <code>optional bool all_cpus = 1;</code>
     * @return Whether the allCpus field is set.
     */
    @java.lang.Override
    public boolean hasAllCpus() {
      return ((bitField0_ & 0x00000100) != 0);
    }
    /**
     * <pre>
     * Note: legacy configs had to set |all_cpus| to true to pass parsing.
     * We rely on this to detect such configs.
     * </pre>
     *
     * <code>optional bool all_cpus = 1;</code>
     * @return The allCpus.
     */
    @java.lang.Override
    public boolean getAllCpus() {
      return allCpus_;
    }

    public static final int SAMPLING_FREQUENCY_FIELD_NUMBER = 2;
    private int samplingFrequency_ = 0;
    /**
     * <code>optional uint32 sampling_frequency = 2;</code>
     * @return Whether the samplingFrequency field is set.
     */
    @java.lang.Override
    public boolean hasSamplingFrequency() {
      return ((bitField0_ & 0x00000200) != 0);
    }
    /**
     * <code>optional uint32 sampling_frequency = 2;</code>
     * @return The samplingFrequency.
     */
    @java.lang.Override
    public int getSamplingFrequency() {
      return samplingFrequency_;
    }

    public static final int KERNEL_FRAMES_FIELD_NUMBER = 12;
    private boolean kernelFrames_ = false;
    /**
     * <code>optional bool kernel_frames = 12;</code>
     * @return Whether the kernelFrames field is set.
     */
    @java.lang.Override
    public boolean hasKernelFrames() {
      return ((bitField0_ & 0x00000400) != 0);
    }
    /**
     * <code>optional bool kernel_frames = 12;</code>
     * @return The kernelFrames.
     */
    @java.lang.Override
    public boolean getKernelFrames() {
      return kernelFrames_;
    }

    public static final int TARGET_PID_FIELD_NUMBER = 4;
    @SuppressWarnings("serial")
    private com.google.protobuf.Internal.IntList targetPid_;
    /**
     * <code>repeated int32 target_pid = 4;</code>
     * @return A list containing the targetPid.
     */
    @java.lang.Override
    public java.util.List<java.lang.Integer>
        getTargetPidList() {
      return targetPid_;
    }
    /**
     * <code>repeated int32 target_pid = 4;</code>
     * @return The count of targetPid.
     */
    public int getTargetPidCount() {
      return targetPid_.size();
    }
    /**
     * <code>repeated int32 target_pid = 4;</code>
     * @param index The index of the element to return.
     * @return The targetPid at the given index.
     */
    public int getTargetPid(int index) {
      return targetPid_.getInt(index);
    }

    public static final int TARGET_CMDLINE_FIELD_NUMBER = 5;
    @SuppressWarnings("serial")
    private com.google.protobuf.LazyStringList targetCmdline_;
    /**
     * <code>repeated string target_cmdline = 5;</code>
     * @return A list containing the targetCmdline.
     */
    public com.google.protobuf.ProtocolStringList
        getTargetCmdlineList() {
      return targetCmdline_;
    }
    /**
     * <code>repeated string target_cmdline = 5;</code>
     * @return The count of targetCmdline.
     */
    public int getTargetCmdlineCount() {
      return targetCmdline_.size();
    }
    /**
     * <code>repeated string target_cmdline = 5;</code>
     * @param index The index of the element to return.
     * @return The targetCmdline at the given index.
     */
    public java.lang.String getTargetCmdline(int index) {
      return targetCmdline_.get(index);
    }
    /**
     * <code>repeated string target_cmdline = 5;</code>
     * @param index The index of the value to return.
     * @return The bytes of the targetCmdline at the given index.
     */
    public com.google.protobuf.ByteString
        getTargetCmdlineBytes(int index) {
      return targetCmdline_.getByteString(index);
    }

    public static final int EXCLUDE_PID_FIELD_NUMBER = 6;
    @SuppressWarnings("serial")
    private com.google.protobuf.Internal.IntList excludePid_;
    /**
     * <code>repeated int32 exclude_pid = 6;</code>
     * @return A list containing the excludePid.
     */
    @java.lang.Override
    public java.util.List<java.lang.Integer>
        getExcludePidList() {
      return excludePid_;
    }
    /**
     * <code>repeated int32 exclude_pid = 6;</code>
     * @return The count of excludePid.
     */
    public int getExcludePidCount() {
      return excludePid_.size();
    }
    /**
     * <code>repeated int32 exclude_pid = 6;</code>
     * @param index The index of the element to return.
     * @return The excludePid at the given index.
     */
    public int getExcludePid(int index) {
      return excludePid_.getInt(index);
    }

    public static final int EXCLUDE_CMDLINE_FIELD_NUMBER = 7;
    @SuppressWarnings("serial")
    private com.google.protobuf.LazyStringList excludeCmdline_;
    /**
     * <code>repeated string exclude_cmdline = 7;</code>
     * @return A list containing the excludeCmdline.
     */
    public com.google.protobuf.ProtocolStringList
        getExcludeCmdlineList() {
      return excludeCmdline_;
    }
    /**
     * <code>repeated string exclude_cmdline = 7;</code>
     * @return The count of excludeCmdline.
     */
    public int getExcludeCmdlineCount() {
      return excludeCmdline_.size();
    }
    /**
     * <code>repeated string exclude_cmdline = 7;</code>
     * @param index The index of the element to return.
     * @return The excludeCmdline at the given index.
     */
    public java.lang.String getExcludeCmdline(int index) {
      return excludeCmdline_.get(index);
    }
    /**
     * <code>repeated string exclude_cmdline = 7;</code>
     * @param index The index of the value to return.
     * @return The bytes of the excludeCmdline at the given index.
     */
    public com.google.protobuf.ByteString
        getExcludeCmdlineBytes(int index) {
      return excludeCmdline_.getByteString(index);
    }

    public static final int ADDITIONAL_CMDLINE_COUNT_FIELD_NUMBER = 11;
    private int additionalCmdlineCount_ = 0;
    /**
     * <code>optional uint32 additional_cmdline_count = 11;</code>
     * @return Whether the additionalCmdlineCount field is set.
     */
    @java.lang.Override
    public boolean hasAdditionalCmdlineCount() {
      return ((bitField0_ & 0x00000800) != 0);
    }
    /**
     * <code>optional uint32 additional_cmdline_count = 11;</code>
     * @return The additionalCmdlineCount.
     */
    @java.lang.Override
    public int getAdditionalCmdlineCount() {
      return additionalCmdlineCount_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000100) != 0)) {
        output.writeBool(1, allCpus_);
      }
      if (((bitField0_ & 0x00000200) != 0)) {
        output.writeUInt32(2, samplingFrequency_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        output.writeUInt32(3, ringBufferPages_);
      }
      for (int i = 0; i < targetPid_.size(); i++) {
        output.writeInt32(4, targetPid_.getInt(i));
      }
      for (int i = 0; i < targetCmdline_.size(); i++) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 5, targetCmdline_.getRaw(i));
      }
      for (int i = 0; i < excludePid_.size(); i++) {
        output.writeInt32(6, excludePid_.getInt(i));
      }
      for (int i = 0; i < excludeCmdline_.size(); i++) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 7, excludeCmdline_.getRaw(i));
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeUInt32(8, ringBufferReadPeriodMs_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        output.writeUInt32(9, remoteDescriptorTimeoutMs_);
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        output.writeUInt32(10, unwindStateClearPeriodMs_);
      }
      if (((bitField0_ & 0x00000800) != 0)) {
        output.writeUInt32(11, additionalCmdlineCount_);
      }
      if (((bitField0_ & 0x00000400) != 0)) {
        output.writeBool(12, kernelFrames_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        output.writeUInt32(13, maxDaemonMemoryKb_);
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeMessage(15, getTimebase());
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeMessage(16, getCallstackSampling());
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        output.writeUInt64(17, maxEnqueuedFootprintKb_);
      }
      for (int i = 0; i < targetInstalledBy_.size(); i++) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 18, targetInstalledBy_.getRaw(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000100) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(1, allCpus_);
      }
      if (((bitField0_ & 0x00000200) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(2, samplingFrequency_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(3, ringBufferPages_);
      }
      {
        int dataSize = 0;
        for (int i = 0; i < targetPid_.size(); i++) {
          dataSize += com.google.protobuf.CodedOutputStream
            .computeInt32SizeNoTag(targetPid_.getInt(i));
        }
        size += dataSize;
        size += 1 * getTargetPidList().size();
      }
      {
        int dataSize = 0;
        for (int i = 0; i < targetCmdline_.size(); i++) {
          dataSize += computeStringSizeNoTag(targetCmdline_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getTargetCmdlineList().size();
      }
      {
        int dataSize = 0;
        for (int i = 0; i < excludePid_.size(); i++) {
          dataSize += com.google.protobuf.CodedOutputStream
            .computeInt32SizeNoTag(excludePid_.getInt(i));
        }
        size += dataSize;
        size += 1 * getExcludePidList().size();
      }
      {
        int dataSize = 0;
        for (int i = 0; i < excludeCmdline_.size(); i++) {
          dataSize += computeStringSizeNoTag(excludeCmdline_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getExcludeCmdlineList().size();
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(8, ringBufferReadPeriodMs_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(9, remoteDescriptorTimeoutMs_);
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(10, unwindStateClearPeriodMs_);
      }
      if (((bitField0_ & 0x00000800) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(11, additionalCmdlineCount_);
      }
      if (((bitField0_ & 0x00000400) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(12, kernelFrames_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(13, maxDaemonMemoryKb_);
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(15, getTimebase());
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(16, getCallstackSampling());
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(17, maxEnqueuedFootprintKb_);
      }
      {
        int dataSize = 0;
        for (int i = 0; i < targetInstalledBy_.size(); i++) {
          dataSize += computeStringSizeNoTag(targetInstalledBy_.getRaw(i));
        }
        size += dataSize;
        size += 2 * getTargetInstalledByList().size();
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig)) {
        return super.equals(obj);
      }
      perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig other = (perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig) obj;

      if (hasTimebase() != other.hasTimebase()) return false;
      if (hasTimebase()) {
        if (!getTimebase()
            .equals(other.getTimebase())) return false;
      }
      if (hasCallstackSampling() != other.hasCallstackSampling()) return false;
      if (hasCallstackSampling()) {
        if (!getCallstackSampling()
            .equals(other.getCallstackSampling())) return false;
      }
      if (hasRingBufferReadPeriodMs() != other.hasRingBufferReadPeriodMs()) return false;
      if (hasRingBufferReadPeriodMs()) {
        if (getRingBufferReadPeriodMs()
            != other.getRingBufferReadPeriodMs()) return false;
      }
      if (hasRingBufferPages() != other.hasRingBufferPages()) return false;
      if (hasRingBufferPages()) {
        if (getRingBufferPages()
            != other.getRingBufferPages()) return false;
      }
      if (hasMaxEnqueuedFootprintKb() != other.hasMaxEnqueuedFootprintKb()) return false;
      if (hasMaxEnqueuedFootprintKb()) {
        if (getMaxEnqueuedFootprintKb()
            != other.getMaxEnqueuedFootprintKb()) return false;
      }
      if (hasMaxDaemonMemoryKb() != other.hasMaxDaemonMemoryKb()) return false;
      if (hasMaxDaemonMemoryKb()) {
        if (getMaxDaemonMemoryKb()
            != other.getMaxDaemonMemoryKb()) return false;
      }
      if (hasRemoteDescriptorTimeoutMs() != other.hasRemoteDescriptorTimeoutMs()) return false;
      if (hasRemoteDescriptorTimeoutMs()) {
        if (getRemoteDescriptorTimeoutMs()
            != other.getRemoteDescriptorTimeoutMs()) return false;
      }
      if (hasUnwindStateClearPeriodMs() != other.hasUnwindStateClearPeriodMs()) return false;
      if (hasUnwindStateClearPeriodMs()) {
        if (getUnwindStateClearPeriodMs()
            != other.getUnwindStateClearPeriodMs()) return false;
      }
      if (!getTargetInstalledByList()
          .equals(other.getTargetInstalledByList())) return false;
      if (hasAllCpus() != other.hasAllCpus()) return false;
      if (hasAllCpus()) {
        if (getAllCpus()
            != other.getAllCpus()) return false;
      }
      if (hasSamplingFrequency() != other.hasSamplingFrequency()) return false;
      if (hasSamplingFrequency()) {
        if (getSamplingFrequency()
            != other.getSamplingFrequency()) return false;
      }
      if (hasKernelFrames() != other.hasKernelFrames()) return false;
      if (hasKernelFrames()) {
        if (getKernelFrames()
            != other.getKernelFrames()) return false;
      }
      if (!getTargetPidList()
          .equals(other.getTargetPidList())) return false;
      if (!getTargetCmdlineList()
          .equals(other.getTargetCmdlineList())) return false;
      if (!getExcludePidList()
          .equals(other.getExcludePidList())) return false;
      if (!getExcludeCmdlineList()
          .equals(other.getExcludeCmdlineList())) return false;
      if (hasAdditionalCmdlineCount() != other.hasAdditionalCmdlineCount()) return false;
      if (hasAdditionalCmdlineCount()) {
        if (getAdditionalCmdlineCount()
            != other.getAdditionalCmdlineCount()) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasTimebase()) {
        hash = (37 * hash) + TIMEBASE_FIELD_NUMBER;
        hash = (53 * hash) + getTimebase().hashCode();
      }
      if (hasCallstackSampling()) {
        hash = (37 * hash) + CALLSTACK_SAMPLING_FIELD_NUMBER;
        hash = (53 * hash) + getCallstackSampling().hashCode();
      }
      if (hasRingBufferReadPeriodMs()) {
        hash = (37 * hash) + RING_BUFFER_READ_PERIOD_MS_FIELD_NUMBER;
        hash = (53 * hash) + getRingBufferReadPeriodMs();
      }
      if (hasRingBufferPages()) {
        hash = (37 * hash) + RING_BUFFER_PAGES_FIELD_NUMBER;
        hash = (53 * hash) + getRingBufferPages();
      }
      if (hasMaxEnqueuedFootprintKb()) {
        hash = (37 * hash) + MAX_ENQUEUED_FOOTPRINT_KB_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getMaxEnqueuedFootprintKb());
      }
      if (hasMaxDaemonMemoryKb()) {
        hash = (37 * hash) + MAX_DAEMON_MEMORY_KB_FIELD_NUMBER;
        hash = (53 * hash) + getMaxDaemonMemoryKb();
      }
      if (hasRemoteDescriptorTimeoutMs()) {
        hash = (37 * hash) + REMOTE_DESCRIPTOR_TIMEOUT_MS_FIELD_NUMBER;
        hash = (53 * hash) + getRemoteDescriptorTimeoutMs();
      }
      if (hasUnwindStateClearPeriodMs()) {
        hash = (37 * hash) + UNWIND_STATE_CLEAR_PERIOD_MS_FIELD_NUMBER;
        hash = (53 * hash) + getUnwindStateClearPeriodMs();
      }
      if (getTargetInstalledByCount() > 0) {
        hash = (37 * hash) + TARGET_INSTALLED_BY_FIELD_NUMBER;
        hash = (53 * hash) + getTargetInstalledByList().hashCode();
      }
      if (hasAllCpus()) {
        hash = (37 * hash) + ALL_CPUS_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getAllCpus());
      }
      if (hasSamplingFrequency()) {
        hash = (37 * hash) + SAMPLING_FREQUENCY_FIELD_NUMBER;
        hash = (53 * hash) + getSamplingFrequency();
      }
      if (hasKernelFrames()) {
        hash = (37 * hash) + KERNEL_FRAMES_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getKernelFrames());
      }
      if (getTargetPidCount() > 0) {
        hash = (37 * hash) + TARGET_PID_FIELD_NUMBER;
        hash = (53 * hash) + getTargetPidList().hashCode();
      }
      if (getTargetCmdlineCount() > 0) {
        hash = (37 * hash) + TARGET_CMDLINE_FIELD_NUMBER;
        hash = (53 * hash) + getTargetCmdlineList().hashCode();
      }
      if (getExcludePidCount() > 0) {
        hash = (37 * hash) + EXCLUDE_PID_FIELD_NUMBER;
        hash = (53 * hash) + getExcludePidList().hashCode();
      }
      if (getExcludeCmdlineCount() > 0) {
        hash = (37 * hash) + EXCLUDE_CMDLINE_FIELD_NUMBER;
        hash = (53 * hash) + getExcludeCmdlineList().hashCode();
      }
      if (hasAdditionalCmdlineCount()) {
        hash = (37 * hash) + ADDITIONAL_CMDLINE_COUNT_FIELD_NUMBER;
        hash = (53 * hash) + getAdditionalCmdlineCount();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Configuration for the traced_perf profiler.
     * Example config for basic cpu profiling:
     *   perf_event_config {
     *     timebase {
     *       frequency: 80
     *     }
     *     callstack_sampling {
     *       scope {
     *         target_cmdline: "surfaceflinger"
     *         target_cmdline: "system_server"
     *       }
     *       kernel_frames: true
     *     }
     *   }
     * Next id: 19
     * </pre>
     *
     * Protobuf type {@code perfetto.protos.PerfEventConfig}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:perfetto.protos.PerfEventConfig)
        perfetto.protos.PerfEventConfigOuterClass.PerfEventConfigOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return perfetto.protos.PerfEventConfigOuterClass.internal_static_perfetto_protos_PerfEventConfig_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return perfetto.protos.PerfEventConfigOuterClass.internal_static_perfetto_protos_PerfEventConfig_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.class, perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.Builder.class);
      }

      // Construct using perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getTimebaseFieldBuilder();
          getCallstackSamplingFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        timebase_ = null;
        if (timebaseBuilder_ != null) {
          timebaseBuilder_.dispose();
          timebaseBuilder_ = null;
        }
        callstackSampling_ = null;
        if (callstackSamplingBuilder_ != null) {
          callstackSamplingBuilder_.dispose();
          callstackSamplingBuilder_ = null;
        }
        ringBufferReadPeriodMs_ = 0;
        ringBufferPages_ = 0;
        maxEnqueuedFootprintKb_ = 0L;
        maxDaemonMemoryKb_ = 0;
        remoteDescriptorTimeoutMs_ = 0;
        unwindStateClearPeriodMs_ = 0;
        targetInstalledBy_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000100);
        allCpus_ = false;
        samplingFrequency_ = 0;
        kernelFrames_ = false;
        targetPid_ = emptyIntList();
        targetCmdline_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00002000);
        excludePid_ = emptyIntList();
        excludeCmdline_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00008000);
        additionalCmdlineCount_ = 0;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return perfetto.protos.PerfEventConfigOuterClass.internal_static_perfetto_protos_PerfEventConfig_descriptor;
      }

      @java.lang.Override
      public perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig getDefaultInstanceForType() {
        return perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.getDefaultInstance();
      }

      @java.lang.Override
      public perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig build() {
        perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig buildPartial() {
        perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig result = new perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig result) {
        if (((bitField0_ & 0x00000100) != 0)) {
          targetInstalledBy_ = targetInstalledBy_.getUnmodifiableView();
          bitField0_ = (bitField0_ & ~0x00000100);
        }
        result.targetInstalledBy_ = targetInstalledBy_;
        if (((bitField0_ & 0x00001000) != 0)) {
          targetPid_.makeImmutable();
          bitField0_ = (bitField0_ & ~0x00001000);
        }
        result.targetPid_ = targetPid_;
        if (((bitField0_ & 0x00002000) != 0)) {
          targetCmdline_ = targetCmdline_.getUnmodifiableView();
          bitField0_ = (bitField0_ & ~0x00002000);
        }
        result.targetCmdline_ = targetCmdline_;
        if (((bitField0_ & 0x00004000) != 0)) {
          excludePid_.makeImmutable();
          bitField0_ = (bitField0_ & ~0x00004000);
        }
        result.excludePid_ = excludePid_;
        if (((bitField0_ & 0x00008000) != 0)) {
          excludeCmdline_ = excludeCmdline_.getUnmodifiableView();
          bitField0_ = (bitField0_ & ~0x00008000);
        }
        result.excludeCmdline_ = excludeCmdline_;
      }

      private void buildPartial0(perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.timebase_ = timebaseBuilder_ == null
              ? timebase_
              : timebaseBuilder_.build();
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.callstackSampling_ = callstackSamplingBuilder_ == null
              ? callstackSampling_
              : callstackSamplingBuilder_.build();
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.ringBufferReadPeriodMs_ = ringBufferReadPeriodMs_;
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.ringBufferPages_ = ringBufferPages_;
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.maxEnqueuedFootprintKb_ = maxEnqueuedFootprintKb_;
          to_bitField0_ |= 0x00000010;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          result.maxDaemonMemoryKb_ = maxDaemonMemoryKb_;
          to_bitField0_ |= 0x00000020;
        }
        if (((from_bitField0_ & 0x00000040) != 0)) {
          result.remoteDescriptorTimeoutMs_ = remoteDescriptorTimeoutMs_;
          to_bitField0_ |= 0x00000040;
        }
        if (((from_bitField0_ & 0x00000080) != 0)) {
          result.unwindStateClearPeriodMs_ = unwindStateClearPeriodMs_;
          to_bitField0_ |= 0x00000080;
        }
        if (((from_bitField0_ & 0x00000200) != 0)) {
          result.allCpus_ = allCpus_;
          to_bitField0_ |= 0x00000100;
        }
        if (((from_bitField0_ & 0x00000400) != 0)) {
          result.samplingFrequency_ = samplingFrequency_;
          to_bitField0_ |= 0x00000200;
        }
        if (((from_bitField0_ & 0x00000800) != 0)) {
          result.kernelFrames_ = kernelFrames_;
          to_bitField0_ |= 0x00000400;
        }
        if (((from_bitField0_ & 0x00010000) != 0)) {
          result.additionalCmdlineCount_ = additionalCmdlineCount_;
          to_bitField0_ |= 0x00000800;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig) {
          return mergeFrom((perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig other) {
        if (other == perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.getDefaultInstance()) return this;
        if (other.hasTimebase()) {
          mergeTimebase(other.getTimebase());
        }
        if (other.hasCallstackSampling()) {
          mergeCallstackSampling(other.getCallstackSampling());
        }
        if (other.hasRingBufferReadPeriodMs()) {
          setRingBufferReadPeriodMs(other.getRingBufferReadPeriodMs());
        }
        if (other.hasRingBufferPages()) {
          setRingBufferPages(other.getRingBufferPages());
        }
        if (other.hasMaxEnqueuedFootprintKb()) {
          setMaxEnqueuedFootprintKb(other.getMaxEnqueuedFootprintKb());
        }
        if (other.hasMaxDaemonMemoryKb()) {
          setMaxDaemonMemoryKb(other.getMaxDaemonMemoryKb());
        }
        if (other.hasRemoteDescriptorTimeoutMs()) {
          setRemoteDescriptorTimeoutMs(other.getRemoteDescriptorTimeoutMs());
        }
        if (other.hasUnwindStateClearPeriodMs()) {
          setUnwindStateClearPeriodMs(other.getUnwindStateClearPeriodMs());
        }
        if (!other.targetInstalledBy_.isEmpty()) {
          if (targetInstalledBy_.isEmpty()) {
            targetInstalledBy_ = other.targetInstalledBy_;
            bitField0_ = (bitField0_ & ~0x00000100);
          } else {
            ensureTargetInstalledByIsMutable();
            targetInstalledBy_.addAll(other.targetInstalledBy_);
          }
          onChanged();
        }
        if (other.hasAllCpus()) {
          setAllCpus(other.getAllCpus());
        }
        if (other.hasSamplingFrequency()) {
          setSamplingFrequency(other.getSamplingFrequency());
        }
        if (other.hasKernelFrames()) {
          setKernelFrames(other.getKernelFrames());
        }
        if (!other.targetPid_.isEmpty()) {
          if (targetPid_.isEmpty()) {
            targetPid_ = other.targetPid_;
            bitField0_ = (bitField0_ & ~0x00001000);
          } else {
            ensureTargetPidIsMutable();
            targetPid_.addAll(other.targetPid_);
          }
          onChanged();
        }
        if (!other.targetCmdline_.isEmpty()) {
          if (targetCmdline_.isEmpty()) {
            targetCmdline_ = other.targetCmdline_;
            bitField0_ = (bitField0_ & ~0x00002000);
          } else {
            ensureTargetCmdlineIsMutable();
            targetCmdline_.addAll(other.targetCmdline_);
          }
          onChanged();
        }
        if (!other.excludePid_.isEmpty()) {
          if (excludePid_.isEmpty()) {
            excludePid_ = other.excludePid_;
            bitField0_ = (bitField0_ & ~0x00004000);
          } else {
            ensureExcludePidIsMutable();
            excludePid_.addAll(other.excludePid_);
          }
          onChanged();
        }
        if (!other.excludeCmdline_.isEmpty()) {
          if (excludeCmdline_.isEmpty()) {
            excludeCmdline_ = other.excludeCmdline_;
            bitField0_ = (bitField0_ & ~0x00008000);
          } else {
            ensureExcludeCmdlineIsMutable();
            excludeCmdline_.addAll(other.excludeCmdline_);
          }
          onChanged();
        }
        if (other.hasAdditionalCmdlineCount()) {
          setAdditionalCmdlineCount(other.getAdditionalCmdlineCount());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 8: {
                allCpus_ = input.readBool();
                bitField0_ |= 0x00000200;
                break;
              } // case 8
              case 16: {
                samplingFrequency_ = input.readUInt32();
                bitField0_ |= 0x00000400;
                break;
              } // case 16
              case 24: {
                ringBufferPages_ = input.readUInt32();
                bitField0_ |= 0x00000008;
                break;
              } // case 24
              case 32: {
                int v = input.readInt32();
                ensureTargetPidIsMutable();
                targetPid_.addInt(v);
                break;
              } // case 32
              case 34: {
                int length = input.readRawVarint32();
                int limit = input.pushLimit(length);
                ensureTargetPidIsMutable();
                while (input.getBytesUntilLimit() > 0) {
                  targetPid_.addInt(input.readInt32());
                }
                input.popLimit(limit);
                break;
              } // case 34
              case 42: {
                com.google.protobuf.ByteString bs = input.readBytes();
                ensureTargetCmdlineIsMutable();
                targetCmdline_.add(bs);
                break;
              } // case 42
              case 48: {
                int v = input.readInt32();
                ensureExcludePidIsMutable();
                excludePid_.addInt(v);
                break;
              } // case 48
              case 50: {
                int length = input.readRawVarint32();
                int limit = input.pushLimit(length);
                ensureExcludePidIsMutable();
                while (input.getBytesUntilLimit() > 0) {
                  excludePid_.addInt(input.readInt32());
                }
                input.popLimit(limit);
                break;
              } // case 50
              case 58: {
                com.google.protobuf.ByteString bs = input.readBytes();
                ensureExcludeCmdlineIsMutable();
                excludeCmdline_.add(bs);
                break;
              } // case 58
              case 64: {
                ringBufferReadPeriodMs_ = input.readUInt32();
                bitField0_ |= 0x00000004;
                break;
              } // case 64
              case 72: {
                remoteDescriptorTimeoutMs_ = input.readUInt32();
                bitField0_ |= 0x00000040;
                break;
              } // case 72
              case 80: {
                unwindStateClearPeriodMs_ = input.readUInt32();
                bitField0_ |= 0x00000080;
                break;
              } // case 80
              case 88: {
                additionalCmdlineCount_ = input.readUInt32();
                bitField0_ |= 0x00010000;
                break;
              } // case 88
              case 96: {
                kernelFrames_ = input.readBool();
                bitField0_ |= 0x00000800;
                break;
              } // case 96
              case 104: {
                maxDaemonMemoryKb_ = input.readUInt32();
                bitField0_ |= 0x00000020;
                break;
              } // case 104
              case 122: {
                input.readMessage(
                    getTimebaseFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000001;
                break;
              } // case 122
              case 130: {
                input.readMessage(
                    getCallstackSamplingFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000002;
                break;
              } // case 130
              case 136: {
                maxEnqueuedFootprintKb_ = input.readUInt64();
                bitField0_ |= 0x00000010;
                break;
              } // case 136
              case 146: {
                com.google.protobuf.ByteString bs = input.readBytes();
                ensureTargetInstalledByIsMutable();
                targetInstalledBy_.add(bs);
                break;
              } // case 146
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private perfetto.protos.PerfEventsOuterClass.PerfEvents.Timebase timebase_;
      private com.google.protobuf.SingleFieldBuilderV3<
          perfetto.protos.PerfEventsOuterClass.PerfEvents.Timebase, perfetto.protos.PerfEventsOuterClass.PerfEvents.Timebase.Builder, perfetto.protos.PerfEventsOuterClass.PerfEvents.TimebaseOrBuilder> timebaseBuilder_;
      /**
       * <pre>
       * What event to sample on, and how often.
       * Defined in common/perf_events.proto.
       * </pre>
       *
       * <code>optional .perfetto.protos.PerfEvents.Timebase timebase = 15;</code>
       * @return Whether the timebase field is set.
       */
      public boolean hasTimebase() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * What event to sample on, and how often.
       * Defined in common/perf_events.proto.
       * </pre>
       *
       * <code>optional .perfetto.protos.PerfEvents.Timebase timebase = 15;</code>
       * @return The timebase.
       */
      public perfetto.protos.PerfEventsOuterClass.PerfEvents.Timebase getTimebase() {
        if (timebaseBuilder_ == null) {
          return timebase_ == null ? perfetto.protos.PerfEventsOuterClass.PerfEvents.Timebase.getDefaultInstance() : timebase_;
        } else {
          return timebaseBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * What event to sample on, and how often.
       * Defined in common/perf_events.proto.
       * </pre>
       *
       * <code>optional .perfetto.protos.PerfEvents.Timebase timebase = 15;</code>
       */
      public Builder setTimebase(perfetto.protos.PerfEventsOuterClass.PerfEvents.Timebase value) {
        if (timebaseBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          timebase_ = value;
        } else {
          timebaseBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * What event to sample on, and how often.
       * Defined in common/perf_events.proto.
       * </pre>
       *
       * <code>optional .perfetto.protos.PerfEvents.Timebase timebase = 15;</code>
       */
      public Builder setTimebase(
          perfetto.protos.PerfEventsOuterClass.PerfEvents.Timebase.Builder builderForValue) {
        if (timebaseBuilder_ == null) {
          timebase_ = builderForValue.build();
        } else {
          timebaseBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * What event to sample on, and how often.
       * Defined in common/perf_events.proto.
       * </pre>
       *
       * <code>optional .perfetto.protos.PerfEvents.Timebase timebase = 15;</code>
       */
      public Builder mergeTimebase(perfetto.protos.PerfEventsOuterClass.PerfEvents.Timebase value) {
        if (timebaseBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0) &&
            timebase_ != null &&
            timebase_ != perfetto.protos.PerfEventsOuterClass.PerfEvents.Timebase.getDefaultInstance()) {
            getTimebaseBuilder().mergeFrom(value);
          } else {
            timebase_ = value;
          }
        } else {
          timebaseBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * What event to sample on, and how often.
       * Defined in common/perf_events.proto.
       * </pre>
       *
       * <code>optional .perfetto.protos.PerfEvents.Timebase timebase = 15;</code>
       */
      public Builder clearTimebase() {
        bitField0_ = (bitField0_ & ~0x00000001);
        timebase_ = null;
        if (timebaseBuilder_ != null) {
          timebaseBuilder_.dispose();
          timebaseBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * What event to sample on, and how often.
       * Defined in common/perf_events.proto.
       * </pre>
       *
       * <code>optional .perfetto.protos.PerfEvents.Timebase timebase = 15;</code>
       */
      public perfetto.protos.PerfEventsOuterClass.PerfEvents.Timebase.Builder getTimebaseBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getTimebaseFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * What event to sample on, and how often.
       * Defined in common/perf_events.proto.
       * </pre>
       *
       * <code>optional .perfetto.protos.PerfEvents.Timebase timebase = 15;</code>
       */
      public perfetto.protos.PerfEventsOuterClass.PerfEvents.TimebaseOrBuilder getTimebaseOrBuilder() {
        if (timebaseBuilder_ != null) {
          return timebaseBuilder_.getMessageOrBuilder();
        } else {
          return timebase_ == null ?
              perfetto.protos.PerfEventsOuterClass.PerfEvents.Timebase.getDefaultInstance() : timebase_;
        }
      }
      /**
       * <pre>
       * What event to sample on, and how often.
       * Defined in common/perf_events.proto.
       * </pre>
       *
       * <code>optional .perfetto.protos.PerfEvents.Timebase timebase = 15;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          perfetto.protos.PerfEventsOuterClass.PerfEvents.Timebase, perfetto.protos.PerfEventsOuterClass.PerfEvents.Timebase.Builder, perfetto.protos.PerfEventsOuterClass.PerfEvents.TimebaseOrBuilder> 
          getTimebaseFieldBuilder() {
        if (timebaseBuilder_ == null) {
          timebaseBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              perfetto.protos.PerfEventsOuterClass.PerfEvents.Timebase, perfetto.protos.PerfEventsOuterClass.PerfEvents.Timebase.Builder, perfetto.protos.PerfEventsOuterClass.PerfEvents.TimebaseOrBuilder>(
                  getTimebase(),
                  getParentForChildren(),
                  isClean());
          timebase_ = null;
        }
        return timebaseBuilder_;
      }

      private perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.CallstackSampling callstackSampling_;
      private com.google.protobuf.SingleFieldBuilderV3<
          perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.CallstackSampling, perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.CallstackSampling.Builder, perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.CallstackSamplingOrBuilder> callstackSamplingBuilder_;
      /**
       * <pre>
       * If set, the profiler will sample userspace processes' callstacks at the
       * interval specified by the |timebase|.
       * If unset, the profiler will record only the event counts.
       * </pre>
       *
       * <code>optional .perfetto.protos.PerfEventConfig.CallstackSampling callstack_sampling = 16;</code>
       * @return Whether the callstackSampling field is set.
       */
      public boolean hasCallstackSampling() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * If set, the profiler will sample userspace processes' callstacks at the
       * interval specified by the |timebase|.
       * If unset, the profiler will record only the event counts.
       * </pre>
       *
       * <code>optional .perfetto.protos.PerfEventConfig.CallstackSampling callstack_sampling = 16;</code>
       * @return The callstackSampling.
       */
      public perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.CallstackSampling getCallstackSampling() {
        if (callstackSamplingBuilder_ == null) {
          return callstackSampling_ == null ? perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.CallstackSampling.getDefaultInstance() : callstackSampling_;
        } else {
          return callstackSamplingBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * If set, the profiler will sample userspace processes' callstacks at the
       * interval specified by the |timebase|.
       * If unset, the profiler will record only the event counts.
       * </pre>
       *
       * <code>optional .perfetto.protos.PerfEventConfig.CallstackSampling callstack_sampling = 16;</code>
       */
      public Builder setCallstackSampling(perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.CallstackSampling value) {
        if (callstackSamplingBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          callstackSampling_ = value;
        } else {
          callstackSamplingBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If set, the profiler will sample userspace processes' callstacks at the
       * interval specified by the |timebase|.
       * If unset, the profiler will record only the event counts.
       * </pre>
       *
       * <code>optional .perfetto.protos.PerfEventConfig.CallstackSampling callstack_sampling = 16;</code>
       */
      public Builder setCallstackSampling(
          perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.CallstackSampling.Builder builderForValue) {
        if (callstackSamplingBuilder_ == null) {
          callstackSampling_ = builderForValue.build();
        } else {
          callstackSamplingBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If set, the profiler will sample userspace processes' callstacks at the
       * interval specified by the |timebase|.
       * If unset, the profiler will record only the event counts.
       * </pre>
       *
       * <code>optional .perfetto.protos.PerfEventConfig.CallstackSampling callstack_sampling = 16;</code>
       */
      public Builder mergeCallstackSampling(perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.CallstackSampling value) {
        if (callstackSamplingBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0) &&
            callstackSampling_ != null &&
            callstackSampling_ != perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.CallstackSampling.getDefaultInstance()) {
            getCallstackSamplingBuilder().mergeFrom(value);
          } else {
            callstackSampling_ = value;
          }
        } else {
          callstackSamplingBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If set, the profiler will sample userspace processes' callstacks at the
       * interval specified by the |timebase|.
       * If unset, the profiler will record only the event counts.
       * </pre>
       *
       * <code>optional .perfetto.protos.PerfEventConfig.CallstackSampling callstack_sampling = 16;</code>
       */
      public Builder clearCallstackSampling() {
        bitField0_ = (bitField0_ & ~0x00000002);
        callstackSampling_ = null;
        if (callstackSamplingBuilder_ != null) {
          callstackSamplingBuilder_.dispose();
          callstackSamplingBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If set, the profiler will sample userspace processes' callstacks at the
       * interval specified by the |timebase|.
       * If unset, the profiler will record only the event counts.
       * </pre>
       *
       * <code>optional .perfetto.protos.PerfEventConfig.CallstackSampling callstack_sampling = 16;</code>
       */
      public perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.CallstackSampling.Builder getCallstackSamplingBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getCallstackSamplingFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * If set, the profiler will sample userspace processes' callstacks at the
       * interval specified by the |timebase|.
       * If unset, the profiler will record only the event counts.
       * </pre>
       *
       * <code>optional .perfetto.protos.PerfEventConfig.CallstackSampling callstack_sampling = 16;</code>
       */
      public perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.CallstackSamplingOrBuilder getCallstackSamplingOrBuilder() {
        if (callstackSamplingBuilder_ != null) {
          return callstackSamplingBuilder_.getMessageOrBuilder();
        } else {
          return callstackSampling_ == null ?
              perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.CallstackSampling.getDefaultInstance() : callstackSampling_;
        }
      }
      /**
       * <pre>
       * If set, the profiler will sample userspace processes' callstacks at the
       * interval specified by the |timebase|.
       * If unset, the profiler will record only the event counts.
       * </pre>
       *
       * <code>optional .perfetto.protos.PerfEventConfig.CallstackSampling callstack_sampling = 16;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.CallstackSampling, perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.CallstackSampling.Builder, perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.CallstackSamplingOrBuilder> 
          getCallstackSamplingFieldBuilder() {
        if (callstackSamplingBuilder_ == null) {
          callstackSamplingBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.CallstackSampling, perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.CallstackSampling.Builder, perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig.CallstackSamplingOrBuilder>(
                  getCallstackSampling(),
                  getParentForChildren(),
                  isClean());
          callstackSampling_ = null;
        }
        return callstackSamplingBuilder_;
      }

      private int ringBufferReadPeriodMs_ ;
      /**
       * <pre>
       * How often the per-cpu ring buffers are read by the producer.
       * If unset, an implementation-defined default is used.
       * </pre>
       *
       * <code>optional uint32 ring_buffer_read_period_ms = 8;</code>
       * @return Whether the ringBufferReadPeriodMs field is set.
       */
      @java.lang.Override
      public boolean hasRingBufferReadPeriodMs() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * How often the per-cpu ring buffers are read by the producer.
       * If unset, an implementation-defined default is used.
       * </pre>
       *
       * <code>optional uint32 ring_buffer_read_period_ms = 8;</code>
       * @return The ringBufferReadPeriodMs.
       */
      @java.lang.Override
      public int getRingBufferReadPeriodMs() {
        return ringBufferReadPeriodMs_;
      }
      /**
       * <pre>
       * How often the per-cpu ring buffers are read by the producer.
       * If unset, an implementation-defined default is used.
       * </pre>
       *
       * <code>optional uint32 ring_buffer_read_period_ms = 8;</code>
       * @param value The ringBufferReadPeriodMs to set.
       * @return This builder for chaining.
       */
      public Builder setRingBufferReadPeriodMs(int value) {
        
        ringBufferReadPeriodMs_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * How often the per-cpu ring buffers are read by the producer.
       * If unset, an implementation-defined default is used.
       * </pre>
       *
       * <code>optional uint32 ring_buffer_read_period_ms = 8;</code>
       * @return This builder for chaining.
       */
      public Builder clearRingBufferReadPeriodMs() {
        bitField0_ = (bitField0_ & ~0x00000004);
        ringBufferReadPeriodMs_ = 0;
        onChanged();
        return this;
      }

      private int ringBufferPages_ ;
      /**
       * <pre>
       * Size (in 4k pages) of each per-cpu ring buffer that is filled by the
       * kernel. If set, must be a power of two.
       * If unset, an implementation-defined default is used.
       * </pre>
       *
       * <code>optional uint32 ring_buffer_pages = 3;</code>
       * @return Whether the ringBufferPages field is set.
       */
      @java.lang.Override
      public boolean hasRingBufferPages() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * Size (in 4k pages) of each per-cpu ring buffer that is filled by the
       * kernel. If set, must be a power of two.
       * If unset, an implementation-defined default is used.
       * </pre>
       *
       * <code>optional uint32 ring_buffer_pages = 3;</code>
       * @return The ringBufferPages.
       */
      @java.lang.Override
      public int getRingBufferPages() {
        return ringBufferPages_;
      }
      /**
       * <pre>
       * Size (in 4k pages) of each per-cpu ring buffer that is filled by the
       * kernel. If set, must be a power of two.
       * If unset, an implementation-defined default is used.
       * </pre>
       *
       * <code>optional uint32 ring_buffer_pages = 3;</code>
       * @param value The ringBufferPages to set.
       * @return This builder for chaining.
       */
      public Builder setRingBufferPages(int value) {
        
        ringBufferPages_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Size (in 4k pages) of each per-cpu ring buffer that is filled by the
       * kernel. If set, must be a power of two.
       * If unset, an implementation-defined default is used.
       * </pre>
       *
       * <code>optional uint32 ring_buffer_pages = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearRingBufferPages() {
        bitField0_ = (bitField0_ & ~0x00000008);
        ringBufferPages_ = 0;
        onChanged();
        return this;
      }

      private long maxEnqueuedFootprintKb_ ;
      /**
       * <pre>
       * Drop samples if the heap memory held by the samples in the unwinder queue
       * is above the given limit. This counts the memory across all concurrent data
       * sources (not just this one's), and there is no fairness guarantee - the
       * whole quota might be used up by a concurrent source.
       * </pre>
       *
       * <code>optional uint64 max_enqueued_footprint_kb = 17;</code>
       * @return Whether the maxEnqueuedFootprintKb field is set.
       */
      @java.lang.Override
      public boolean hasMaxEnqueuedFootprintKb() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * Drop samples if the heap memory held by the samples in the unwinder queue
       * is above the given limit. This counts the memory across all concurrent data
       * sources (not just this one's), and there is no fairness guarantee - the
       * whole quota might be used up by a concurrent source.
       * </pre>
       *
       * <code>optional uint64 max_enqueued_footprint_kb = 17;</code>
       * @return The maxEnqueuedFootprintKb.
       */
      @java.lang.Override
      public long getMaxEnqueuedFootprintKb() {
        return maxEnqueuedFootprintKb_;
      }
      /**
       * <pre>
       * Drop samples if the heap memory held by the samples in the unwinder queue
       * is above the given limit. This counts the memory across all concurrent data
       * sources (not just this one's), and there is no fairness guarantee - the
       * whole quota might be used up by a concurrent source.
       * </pre>
       *
       * <code>optional uint64 max_enqueued_footprint_kb = 17;</code>
       * @param value The maxEnqueuedFootprintKb to set.
       * @return This builder for chaining.
       */
      public Builder setMaxEnqueuedFootprintKb(long value) {
        
        maxEnqueuedFootprintKb_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Drop samples if the heap memory held by the samples in the unwinder queue
       * is above the given limit. This counts the memory across all concurrent data
       * sources (not just this one's), and there is no fairness guarantee - the
       * whole quota might be used up by a concurrent source.
       * </pre>
       *
       * <code>optional uint64 max_enqueued_footprint_kb = 17;</code>
       * @return This builder for chaining.
       */
      public Builder clearMaxEnqueuedFootprintKb() {
        bitField0_ = (bitField0_ & ~0x00000010);
        maxEnqueuedFootprintKb_ = 0L;
        onChanged();
        return this;
      }

      private int maxDaemonMemoryKb_ ;
      /**
       * <pre>
       * Stop the data source if traced_perf's combined {RssAnon + Swap} memory
       * footprint exceeds this value.
       * </pre>
       *
       * <code>optional uint32 max_daemon_memory_kb = 13;</code>
       * @return Whether the maxDaemonMemoryKb field is set.
       */
      @java.lang.Override
      public boolean hasMaxDaemonMemoryKb() {
        return ((bitField0_ & 0x00000020) != 0);
      }
      /**
       * <pre>
       * Stop the data source if traced_perf's combined {RssAnon + Swap} memory
       * footprint exceeds this value.
       * </pre>
       *
       * <code>optional uint32 max_daemon_memory_kb = 13;</code>
       * @return The maxDaemonMemoryKb.
       */
      @java.lang.Override
      public int getMaxDaemonMemoryKb() {
        return maxDaemonMemoryKb_;
      }
      /**
       * <pre>
       * Stop the data source if traced_perf's combined {RssAnon + Swap} memory
       * footprint exceeds this value.
       * </pre>
       *
       * <code>optional uint32 max_daemon_memory_kb = 13;</code>
       * @param value The maxDaemonMemoryKb to set.
       * @return This builder for chaining.
       */
      public Builder setMaxDaemonMemoryKb(int value) {
        
        maxDaemonMemoryKb_ = value;
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Stop the data source if traced_perf's combined {RssAnon + Swap} memory
       * footprint exceeds this value.
       * </pre>
       *
       * <code>optional uint32 max_daemon_memory_kb = 13;</code>
       * @return This builder for chaining.
       */
      public Builder clearMaxDaemonMemoryKb() {
        bitField0_ = (bitField0_ & ~0x00000020);
        maxDaemonMemoryKb_ = 0;
        onChanged();
        return this;
      }

      private int remoteDescriptorTimeoutMs_ ;
      /**
       * <pre>
       * Timeout for the remote /proc/&lt;pid&gt;/{maps,mem} file descriptors for a
       * sampled process. This is primarily for Android, where this lookup is
       * asynchronous. As long as the producer is waiting, the associated samples
       * will be kept enqueued (putting pressure on the capacity of the shared
       * unwinding queue). Once a lookup for a process expires, all associated
       * samples are discarded. However, if the lookup still succeeds after the
       * timeout, future samples will be handled normally.
       * If unset, an implementation-defined default is used.
       * </pre>
       *
       * <code>optional uint32 remote_descriptor_timeout_ms = 9;</code>
       * @return Whether the remoteDescriptorTimeoutMs field is set.
       */
      @java.lang.Override
      public boolean hasRemoteDescriptorTimeoutMs() {
        return ((bitField0_ & 0x00000040) != 0);
      }
      /**
       * <pre>
       * Timeout for the remote /proc/&lt;pid&gt;/{maps,mem} file descriptors for a
       * sampled process. This is primarily for Android, where this lookup is
       * asynchronous. As long as the producer is waiting, the associated samples
       * will be kept enqueued (putting pressure on the capacity of the shared
       * unwinding queue). Once a lookup for a process expires, all associated
       * samples are discarded. However, if the lookup still succeeds after the
       * timeout, future samples will be handled normally.
       * If unset, an implementation-defined default is used.
       * </pre>
       *
       * <code>optional uint32 remote_descriptor_timeout_ms = 9;</code>
       * @return The remoteDescriptorTimeoutMs.
       */
      @java.lang.Override
      public int getRemoteDescriptorTimeoutMs() {
        return remoteDescriptorTimeoutMs_;
      }
      /**
       * <pre>
       * Timeout for the remote /proc/&lt;pid&gt;/{maps,mem} file descriptors for a
       * sampled process. This is primarily for Android, where this lookup is
       * asynchronous. As long as the producer is waiting, the associated samples
       * will be kept enqueued (putting pressure on the capacity of the shared
       * unwinding queue). Once a lookup for a process expires, all associated
       * samples are discarded. However, if the lookup still succeeds after the
       * timeout, future samples will be handled normally.
       * If unset, an implementation-defined default is used.
       * </pre>
       *
       * <code>optional uint32 remote_descriptor_timeout_ms = 9;</code>
       * @param value The remoteDescriptorTimeoutMs to set.
       * @return This builder for chaining.
       */
      public Builder setRemoteDescriptorTimeoutMs(int value) {
        
        remoteDescriptorTimeoutMs_ = value;
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Timeout for the remote /proc/&lt;pid&gt;/{maps,mem} file descriptors for a
       * sampled process. This is primarily for Android, where this lookup is
       * asynchronous. As long as the producer is waiting, the associated samples
       * will be kept enqueued (putting pressure on the capacity of the shared
       * unwinding queue). Once a lookup for a process expires, all associated
       * samples are discarded. However, if the lookup still succeeds after the
       * timeout, future samples will be handled normally.
       * If unset, an implementation-defined default is used.
       * </pre>
       *
       * <code>optional uint32 remote_descriptor_timeout_ms = 9;</code>
       * @return This builder for chaining.
       */
      public Builder clearRemoteDescriptorTimeoutMs() {
        bitField0_ = (bitField0_ & ~0x00000040);
        remoteDescriptorTimeoutMs_ = 0;
        onChanged();
        return this;
      }

      private int unwindStateClearPeriodMs_ ;
      /**
       * <pre>
       * Optional period for clearing state cached by the unwinder. This is a heavy
       * operation that is only necessary for traces that target a wide set of
       * processes, and require the memory footprint to be reset periodically.
       * If unset, the cached state will not be cleared.
       * </pre>
       *
       * <code>optional uint32 unwind_state_clear_period_ms = 10;</code>
       * @return Whether the unwindStateClearPeriodMs field is set.
       */
      @java.lang.Override
      public boolean hasUnwindStateClearPeriodMs() {
        return ((bitField0_ & 0x00000080) != 0);
      }
      /**
       * <pre>
       * Optional period for clearing state cached by the unwinder. This is a heavy
       * operation that is only necessary for traces that target a wide set of
       * processes, and require the memory footprint to be reset periodically.
       * If unset, the cached state will not be cleared.
       * </pre>
       *
       * <code>optional uint32 unwind_state_clear_period_ms = 10;</code>
       * @return The unwindStateClearPeriodMs.
       */
      @java.lang.Override
      public int getUnwindStateClearPeriodMs() {
        return unwindStateClearPeriodMs_;
      }
      /**
       * <pre>
       * Optional period for clearing state cached by the unwinder. This is a heavy
       * operation that is only necessary for traces that target a wide set of
       * processes, and require the memory footprint to be reset periodically.
       * If unset, the cached state will not be cleared.
       * </pre>
       *
       * <code>optional uint32 unwind_state_clear_period_ms = 10;</code>
       * @param value The unwindStateClearPeriodMs to set.
       * @return This builder for chaining.
       */
      public Builder setUnwindStateClearPeriodMs(int value) {
        
        unwindStateClearPeriodMs_ = value;
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Optional period for clearing state cached by the unwinder. This is a heavy
       * operation that is only necessary for traces that target a wide set of
       * processes, and require the memory footprint to be reset periodically.
       * If unset, the cached state will not be cleared.
       * </pre>
       *
       * <code>optional uint32 unwind_state_clear_period_ms = 10;</code>
       * @return This builder for chaining.
       */
      public Builder clearUnwindStateClearPeriodMs() {
        bitField0_ = (bitField0_ & ~0x00000080);
        unwindStateClearPeriodMs_ = 0;
        onChanged();
        return this;
      }

      private com.google.protobuf.LazyStringList targetInstalledBy_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      private void ensureTargetInstalledByIsMutable() {
        if (!((bitField0_ & 0x00000100) != 0)) {
          targetInstalledBy_ = new com.google.protobuf.LazyStringArrayList(targetInstalledBy_);
          bitField0_ |= 0x00000100;
         }
      }
      /**
       * <pre>
       * If set, only profile target if it was installed by a package with one of
       * these names. Special values:
       * * "&#64;system": installed on the system partition
       * * "&#64;product": installed on the product partition
       * * "&#64;null": sideloaded
       * Supported on Android 12+.
       * </pre>
       *
       * <code>repeated string target_installed_by = 18;</code>
       * @return A list containing the targetInstalledBy.
       */
      public com.google.protobuf.ProtocolStringList
          getTargetInstalledByList() {
        return targetInstalledBy_.getUnmodifiableView();
      }
      /**
       * <pre>
       * If set, only profile target if it was installed by a package with one of
       * these names. Special values:
       * * "&#64;system": installed on the system partition
       * * "&#64;product": installed on the product partition
       * * "&#64;null": sideloaded
       * Supported on Android 12+.
       * </pre>
       *
       * <code>repeated string target_installed_by = 18;</code>
       * @return The count of targetInstalledBy.
       */
      public int getTargetInstalledByCount() {
        return targetInstalledBy_.size();
      }
      /**
       * <pre>
       * If set, only profile target if it was installed by a package with one of
       * these names. Special values:
       * * "&#64;system": installed on the system partition
       * * "&#64;product": installed on the product partition
       * * "&#64;null": sideloaded
       * Supported on Android 12+.
       * </pre>
       *
       * <code>repeated string target_installed_by = 18;</code>
       * @param index The index of the element to return.
       * @return The targetInstalledBy at the given index.
       */
      public java.lang.String getTargetInstalledBy(int index) {
        return targetInstalledBy_.get(index);
      }
      /**
       * <pre>
       * If set, only profile target if it was installed by a package with one of
       * these names. Special values:
       * * "&#64;system": installed on the system partition
       * * "&#64;product": installed on the product partition
       * * "&#64;null": sideloaded
       * Supported on Android 12+.
       * </pre>
       *
       * <code>repeated string target_installed_by = 18;</code>
       * @param index The index of the value to return.
       * @return The bytes of the targetInstalledBy at the given index.
       */
      public com.google.protobuf.ByteString
          getTargetInstalledByBytes(int index) {
        return targetInstalledBy_.getByteString(index);
      }
      /**
       * <pre>
       * If set, only profile target if it was installed by a package with one of
       * these names. Special values:
       * * "&#64;system": installed on the system partition
       * * "&#64;product": installed on the product partition
       * * "&#64;null": sideloaded
       * Supported on Android 12+.
       * </pre>
       *
       * <code>repeated string target_installed_by = 18;</code>
       * @param index The index to set the value at.
       * @param value The targetInstalledBy to set.
       * @return This builder for chaining.
       */
      public Builder setTargetInstalledBy(
          int index, java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureTargetInstalledByIsMutable();
        targetInstalledBy_.set(index, value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If set, only profile target if it was installed by a package with one of
       * these names. Special values:
       * * "&#64;system": installed on the system partition
       * * "&#64;product": installed on the product partition
       * * "&#64;null": sideloaded
       * Supported on Android 12+.
       * </pre>
       *
       * <code>repeated string target_installed_by = 18;</code>
       * @param value The targetInstalledBy to add.
       * @return This builder for chaining.
       */
      public Builder addTargetInstalledBy(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureTargetInstalledByIsMutable();
        targetInstalledBy_.add(value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If set, only profile target if it was installed by a package with one of
       * these names. Special values:
       * * "&#64;system": installed on the system partition
       * * "&#64;product": installed on the product partition
       * * "&#64;null": sideloaded
       * Supported on Android 12+.
       * </pre>
       *
       * <code>repeated string target_installed_by = 18;</code>
       * @param values The targetInstalledBy to add.
       * @return This builder for chaining.
       */
      public Builder addAllTargetInstalledBy(
          java.lang.Iterable<java.lang.String> values) {
        ensureTargetInstalledByIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, targetInstalledBy_);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If set, only profile target if it was installed by a package with one of
       * these names. Special values:
       * * "&#64;system": installed on the system partition
       * * "&#64;product": installed on the product partition
       * * "&#64;null": sideloaded
       * Supported on Android 12+.
       * </pre>
       *
       * <code>repeated string target_installed_by = 18;</code>
       * @return This builder for chaining.
       */
      public Builder clearTargetInstalledBy() {
        targetInstalledBy_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000100);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If set, only profile target if it was installed by a package with one of
       * these names. Special values:
       * * "&#64;system": installed on the system partition
       * * "&#64;product": installed on the product partition
       * * "&#64;null": sideloaded
       * Supported on Android 12+.
       * </pre>
       *
       * <code>repeated string target_installed_by = 18;</code>
       * @param value The bytes of the targetInstalledBy to add.
       * @return This builder for chaining.
       */
      public Builder addTargetInstalledByBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        ensureTargetInstalledByIsMutable();
        targetInstalledBy_.add(value);
        onChanged();
        return this;
      }

      private boolean allCpus_ ;
      /**
       * <pre>
       * Note: legacy configs had to set |all_cpus| to true to pass parsing.
       * We rely on this to detect such configs.
       * </pre>
       *
       * <code>optional bool all_cpus = 1;</code>
       * @return Whether the allCpus field is set.
       */
      @java.lang.Override
      public boolean hasAllCpus() {
        return ((bitField0_ & 0x00000200) != 0);
      }
      /**
       * <pre>
       * Note: legacy configs had to set |all_cpus| to true to pass parsing.
       * We rely on this to detect such configs.
       * </pre>
       *
       * <code>optional bool all_cpus = 1;</code>
       * @return The allCpus.
       */
      @java.lang.Override
      public boolean getAllCpus() {
        return allCpus_;
      }
      /**
       * <pre>
       * Note: legacy configs had to set |all_cpus| to true to pass parsing.
       * We rely on this to detect such configs.
       * </pre>
       *
       * <code>optional bool all_cpus = 1;</code>
       * @param value The allCpus to set.
       * @return This builder for chaining.
       */
      public Builder setAllCpus(boolean value) {
        
        allCpus_ = value;
        bitField0_ |= 0x00000200;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Note: legacy configs had to set |all_cpus| to true to pass parsing.
       * We rely on this to detect such configs.
       * </pre>
       *
       * <code>optional bool all_cpus = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearAllCpus() {
        bitField0_ = (bitField0_ & ~0x00000200);
        allCpus_ = false;
        onChanged();
        return this;
      }

      private int samplingFrequency_ ;
      /**
       * <code>optional uint32 sampling_frequency = 2;</code>
       * @return Whether the samplingFrequency field is set.
       */
      @java.lang.Override
      public boolean hasSamplingFrequency() {
        return ((bitField0_ & 0x00000400) != 0);
      }
      /**
       * <code>optional uint32 sampling_frequency = 2;</code>
       * @return The samplingFrequency.
       */
      @java.lang.Override
      public int getSamplingFrequency() {
        return samplingFrequency_;
      }
      /**
       * <code>optional uint32 sampling_frequency = 2;</code>
       * @param value The samplingFrequency to set.
       * @return This builder for chaining.
       */
      public Builder setSamplingFrequency(int value) {
        
        samplingFrequency_ = value;
        bitField0_ |= 0x00000400;
        onChanged();
        return this;
      }
      /**
       * <code>optional uint32 sampling_frequency = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearSamplingFrequency() {
        bitField0_ = (bitField0_ & ~0x00000400);
        samplingFrequency_ = 0;
        onChanged();
        return this;
      }

      private boolean kernelFrames_ ;
      /**
       * <code>optional bool kernel_frames = 12;</code>
       * @return Whether the kernelFrames field is set.
       */
      @java.lang.Override
      public boolean hasKernelFrames() {
        return ((bitField0_ & 0x00000800) != 0);
      }
      /**
       * <code>optional bool kernel_frames = 12;</code>
       * @return The kernelFrames.
       */
      @java.lang.Override
      public boolean getKernelFrames() {
        return kernelFrames_;
      }
      /**
       * <code>optional bool kernel_frames = 12;</code>
       * @param value The kernelFrames to set.
       * @return This builder for chaining.
       */
      public Builder setKernelFrames(boolean value) {
        
        kernelFrames_ = value;
        bitField0_ |= 0x00000800;
        onChanged();
        return this;
      }
      /**
       * <code>optional bool kernel_frames = 12;</code>
       * @return This builder for chaining.
       */
      public Builder clearKernelFrames() {
        bitField0_ = (bitField0_ & ~0x00000800);
        kernelFrames_ = false;
        onChanged();
        return this;
      }

      private com.google.protobuf.Internal.IntList targetPid_ = emptyIntList();
      private void ensureTargetPidIsMutable() {
        if (!((bitField0_ & 0x00001000) != 0)) {
          targetPid_ = mutableCopy(targetPid_);
          bitField0_ |= 0x00001000;
        }
      }
      /**
       * <code>repeated int32 target_pid = 4;</code>
       * @return A list containing the targetPid.
       */
      public java.util.List<java.lang.Integer>
          getTargetPidList() {
        return ((bitField0_ & 0x00001000) != 0) ?
                 java.util.Collections.unmodifiableList(targetPid_) : targetPid_;
      }
      /**
       * <code>repeated int32 target_pid = 4;</code>
       * @return The count of targetPid.
       */
      public int getTargetPidCount() {
        return targetPid_.size();
      }
      /**
       * <code>repeated int32 target_pid = 4;</code>
       * @param index The index of the element to return.
       * @return The targetPid at the given index.
       */
      public int getTargetPid(int index) {
        return targetPid_.getInt(index);
      }
      /**
       * <code>repeated int32 target_pid = 4;</code>
       * @param index The index to set the value at.
       * @param value The targetPid to set.
       * @return This builder for chaining.
       */
      public Builder setTargetPid(
          int index, int value) {
        
        ensureTargetPidIsMutable();
        targetPid_.setInt(index, value);
        onChanged();
        return this;
      }
      /**
       * <code>repeated int32 target_pid = 4;</code>
       * @param value The targetPid to add.
       * @return This builder for chaining.
       */
      public Builder addTargetPid(int value) {
        
        ensureTargetPidIsMutable();
        targetPid_.addInt(value);
        onChanged();
        return this;
      }
      /**
       * <code>repeated int32 target_pid = 4;</code>
       * @param values The targetPid to add.
       * @return This builder for chaining.
       */
      public Builder addAllTargetPid(
          java.lang.Iterable<? extends java.lang.Integer> values) {
        ensureTargetPidIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, targetPid_);
        onChanged();
        return this;
      }
      /**
       * <code>repeated int32 target_pid = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearTargetPid() {
        targetPid_ = emptyIntList();
        bitField0_ = (bitField0_ & ~0x00001000);
        onChanged();
        return this;
      }

      private com.google.protobuf.LazyStringList targetCmdline_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      private void ensureTargetCmdlineIsMutable() {
        if (!((bitField0_ & 0x00002000) != 0)) {
          targetCmdline_ = new com.google.protobuf.LazyStringArrayList(targetCmdline_);
          bitField0_ |= 0x00002000;
         }
      }
      /**
       * <code>repeated string target_cmdline = 5;</code>
       * @return A list containing the targetCmdline.
       */
      public com.google.protobuf.ProtocolStringList
          getTargetCmdlineList() {
        return targetCmdline_.getUnmodifiableView();
      }
      /**
       * <code>repeated string target_cmdline = 5;</code>
       * @return The count of targetCmdline.
       */
      public int getTargetCmdlineCount() {
        return targetCmdline_.size();
      }
      /**
       * <code>repeated string target_cmdline = 5;</code>
       * @param index The index of the element to return.
       * @return The targetCmdline at the given index.
       */
      public java.lang.String getTargetCmdline(int index) {
        return targetCmdline_.get(index);
      }
      /**
       * <code>repeated string target_cmdline = 5;</code>
       * @param index The index of the value to return.
       * @return The bytes of the targetCmdline at the given index.
       */
      public com.google.protobuf.ByteString
          getTargetCmdlineBytes(int index) {
        return targetCmdline_.getByteString(index);
      }
      /**
       * <code>repeated string target_cmdline = 5;</code>
       * @param index The index to set the value at.
       * @param value The targetCmdline to set.
       * @return This builder for chaining.
       */
      public Builder setTargetCmdline(
          int index, java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureTargetCmdlineIsMutable();
        targetCmdline_.set(index, value);
        onChanged();
        return this;
      }
      /**
       * <code>repeated string target_cmdline = 5;</code>
       * @param value The targetCmdline to add.
       * @return This builder for chaining.
       */
      public Builder addTargetCmdline(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureTargetCmdlineIsMutable();
        targetCmdline_.add(value);
        onChanged();
        return this;
      }
      /**
       * <code>repeated string target_cmdline = 5;</code>
       * @param values The targetCmdline to add.
       * @return This builder for chaining.
       */
      public Builder addAllTargetCmdline(
          java.lang.Iterable<java.lang.String> values) {
        ensureTargetCmdlineIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, targetCmdline_);
        onChanged();
        return this;
      }
      /**
       * <code>repeated string target_cmdline = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearTargetCmdline() {
        targetCmdline_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00002000);
        onChanged();
        return this;
      }
      /**
       * <code>repeated string target_cmdline = 5;</code>
       * @param value The bytes of the targetCmdline to add.
       * @return This builder for chaining.
       */
      public Builder addTargetCmdlineBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        ensureTargetCmdlineIsMutable();
        targetCmdline_.add(value);
        onChanged();
        return this;
      }

      private com.google.protobuf.Internal.IntList excludePid_ = emptyIntList();
      private void ensureExcludePidIsMutable() {
        if (!((bitField0_ & 0x00004000) != 0)) {
          excludePid_ = mutableCopy(excludePid_);
          bitField0_ |= 0x00004000;
        }
      }
      /**
       * <code>repeated int32 exclude_pid = 6;</code>
       * @return A list containing the excludePid.
       */
      public java.util.List<java.lang.Integer>
          getExcludePidList() {
        return ((bitField0_ & 0x00004000) != 0) ?
                 java.util.Collections.unmodifiableList(excludePid_) : excludePid_;
      }
      /**
       * <code>repeated int32 exclude_pid = 6;</code>
       * @return The count of excludePid.
       */
      public int getExcludePidCount() {
        return excludePid_.size();
      }
      /**
       * <code>repeated int32 exclude_pid = 6;</code>
       * @param index The index of the element to return.
       * @return The excludePid at the given index.
       */
      public int getExcludePid(int index) {
        return excludePid_.getInt(index);
      }
      /**
       * <code>repeated int32 exclude_pid = 6;</code>
       * @param index The index to set the value at.
       * @param value The excludePid to set.
       * @return This builder for chaining.
       */
      public Builder setExcludePid(
          int index, int value) {
        
        ensureExcludePidIsMutable();
        excludePid_.setInt(index, value);
        onChanged();
        return this;
      }
      /**
       * <code>repeated int32 exclude_pid = 6;</code>
       * @param value The excludePid to add.
       * @return This builder for chaining.
       */
      public Builder addExcludePid(int value) {
        
        ensureExcludePidIsMutable();
        excludePid_.addInt(value);
        onChanged();
        return this;
      }
      /**
       * <code>repeated int32 exclude_pid = 6;</code>
       * @param values The excludePid to add.
       * @return This builder for chaining.
       */
      public Builder addAllExcludePid(
          java.lang.Iterable<? extends java.lang.Integer> values) {
        ensureExcludePidIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, excludePid_);
        onChanged();
        return this;
      }
      /**
       * <code>repeated int32 exclude_pid = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearExcludePid() {
        excludePid_ = emptyIntList();
        bitField0_ = (bitField0_ & ~0x00004000);
        onChanged();
        return this;
      }

      private com.google.protobuf.LazyStringList excludeCmdline_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      private void ensureExcludeCmdlineIsMutable() {
        if (!((bitField0_ & 0x00008000) != 0)) {
          excludeCmdline_ = new com.google.protobuf.LazyStringArrayList(excludeCmdline_);
          bitField0_ |= 0x00008000;
         }
      }
      /**
       * <code>repeated string exclude_cmdline = 7;</code>
       * @return A list containing the excludeCmdline.
       */
      public com.google.protobuf.ProtocolStringList
          getExcludeCmdlineList() {
        return excludeCmdline_.getUnmodifiableView();
      }
      /**
       * <code>repeated string exclude_cmdline = 7;</code>
       * @return The count of excludeCmdline.
       */
      public int getExcludeCmdlineCount() {
        return excludeCmdline_.size();
      }
      /**
       * <code>repeated string exclude_cmdline = 7;</code>
       * @param index The index of the element to return.
       * @return The excludeCmdline at the given index.
       */
      public java.lang.String getExcludeCmdline(int index) {
        return excludeCmdline_.get(index);
      }
      /**
       * <code>repeated string exclude_cmdline = 7;</code>
       * @param index The index of the value to return.
       * @return The bytes of the excludeCmdline at the given index.
       */
      public com.google.protobuf.ByteString
          getExcludeCmdlineBytes(int index) {
        return excludeCmdline_.getByteString(index);
      }
      /**
       * <code>repeated string exclude_cmdline = 7;</code>
       * @param index The index to set the value at.
       * @param value The excludeCmdline to set.
       * @return This builder for chaining.
       */
      public Builder setExcludeCmdline(
          int index, java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureExcludeCmdlineIsMutable();
        excludeCmdline_.set(index, value);
        onChanged();
        return this;
      }
      /**
       * <code>repeated string exclude_cmdline = 7;</code>
       * @param value The excludeCmdline to add.
       * @return This builder for chaining.
       */
      public Builder addExcludeCmdline(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        ensureExcludeCmdlineIsMutable();
        excludeCmdline_.add(value);
        onChanged();
        return this;
      }
      /**
       * <code>repeated string exclude_cmdline = 7;</code>
       * @param values The excludeCmdline to add.
       * @return This builder for chaining.
       */
      public Builder addAllExcludeCmdline(
          java.lang.Iterable<java.lang.String> values) {
        ensureExcludeCmdlineIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, excludeCmdline_);
        onChanged();
        return this;
      }
      /**
       * <code>repeated string exclude_cmdline = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearExcludeCmdline() {
        excludeCmdline_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00008000);
        onChanged();
        return this;
      }
      /**
       * <code>repeated string exclude_cmdline = 7;</code>
       * @param value The bytes of the excludeCmdline to add.
       * @return This builder for chaining.
       */
      public Builder addExcludeCmdlineBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        ensureExcludeCmdlineIsMutable();
        excludeCmdline_.add(value);
        onChanged();
        return this;
      }

      private int additionalCmdlineCount_ ;
      /**
       * <code>optional uint32 additional_cmdline_count = 11;</code>
       * @return Whether the additionalCmdlineCount field is set.
       */
      @java.lang.Override
      public boolean hasAdditionalCmdlineCount() {
        return ((bitField0_ & 0x00010000) != 0);
      }
      /**
       * <code>optional uint32 additional_cmdline_count = 11;</code>
       * @return The additionalCmdlineCount.
       */
      @java.lang.Override
      public int getAdditionalCmdlineCount() {
        return additionalCmdlineCount_;
      }
      /**
       * <code>optional uint32 additional_cmdline_count = 11;</code>
       * @param value The additionalCmdlineCount to set.
       * @return This builder for chaining.
       */
      public Builder setAdditionalCmdlineCount(int value) {
        
        additionalCmdlineCount_ = value;
        bitField0_ |= 0x00010000;
        onChanged();
        return this;
      }
      /**
       * <code>optional uint32 additional_cmdline_count = 11;</code>
       * @return This builder for chaining.
       */
      public Builder clearAdditionalCmdlineCount() {
        bitField0_ = (bitField0_ & ~0x00010000);
        additionalCmdlineCount_ = 0;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:perfetto.protos.PerfEventConfig)
    }

    // @@protoc_insertion_point(class_scope:perfetto.protos.PerfEventConfig)
    private static final perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig();
    }

    public static perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<PerfEventConfig>
        PARSER = new com.google.protobuf.AbstractParser<PerfEventConfig>() {
      @java.lang.Override
      public PerfEventConfig parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<PerfEventConfig> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<PerfEventConfig> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public perfetto.protos.PerfEventConfigOuterClass.PerfEventConfig getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_perfetto_protos_PerfEventConfig_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_perfetto_protos_PerfEventConfig_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_perfetto_protos_PerfEventConfig_CallstackSampling_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_perfetto_protos_PerfEventConfig_CallstackSampling_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_perfetto_protos_PerfEventConfig_Scope_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_perfetto_protos_PerfEventConfig_Scope_fieldAccessorTable;

  public static com.google.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
    return descriptor;
  }
  private static  com.google.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
    java.lang.String[] descriptorData = {
      "\n8protos/perfetto/config/profiling/perf_" +
      "event_config.proto\022\017perfetto.protos\032(pro" +
      "tos/perfetto/common/perf_events.proto\"\327\007" +
      "\n\017PerfEventConfig\0226\n\010timebase\030\017 \001(\0132$.pe" +
      "rfetto.protos.PerfEvents.Timebase\022N\n\022cal" +
      "lstack_sampling\030\020 \001(\01322.perfetto.protos." +
      "PerfEventConfig.CallstackSampling\022\"\n\032rin" +
      "g_buffer_read_period_ms\030\010 \001(\r\022\031\n\021ring_bu" +
      "ffer_pages\030\003 \001(\r\022!\n\031max_enqueued_footpri" +
      "nt_kb\030\021 \001(\004\022\034\n\024max_daemon_memory_kb\030\r \001(" +
      "\r\022$\n\034remote_descriptor_timeout_ms\030\t \001(\r\022" +
      "$\n\034unwind_state_clear_period_ms\030\n \001(\r\022\033\n" +
      "\023target_installed_by\030\022 \003(\t\022\020\n\010all_cpus\030\001" +
      " \001(\010\022\032\n\022sampling_frequency\030\002 \001(\r\022\025\n\rkern" +
      "el_frames\030\014 \001(\010\022\022\n\ntarget_pid\030\004 \003(\005\022\026\n\016t" +
      "arget_cmdline\030\005 \003(\t\022\023\n\013exclude_pid\030\006 \003(\005" +
      "\022\027\n\017exclude_cmdline\030\007 \003(\t\022 \n\030additional_" +
      "cmdline_count\030\013 \001(\r\032\243\001\n\021CallstackSamplin" +
      "g\0225\n\005scope\030\001 \001(\0132&.perfetto.protos.PerfE" +
      "ventConfig.Scope\022\025\n\rkernel_frames\030\002 \001(\010\022" +
      "@\n\013user_frames\030\003 \001(\0162+.perfetto.protos.P" +
      "erfEventConfig.UnwindMode\032\240\001\n\005Scope\022\022\n\nt" +
      "arget_pid\030\001 \003(\005\022\026\n\016target_cmdline\030\002 \003(\t\022" +
      "\023\n\013exclude_pid\030\003 \003(\005\022\027\n\017exclude_cmdline\030" +
      "\004 \003(\t\022 \n\030additional_cmdline_count\030\005 \001(\r\022" +
      "\033\n\023process_shard_count\030\006 \001(\r\"C\n\nUnwindMo" +
      "de\022\022\n\016UNWIND_UNKNOWN\020\000\022\017\n\013UNWIND_SKIP\020\001\022" +
      "\020\n\014UNWIND_DWARF\020\002J\004\010\016\020\017"
    };
    descriptor = com.google.protobuf.Descriptors.FileDescriptor
      .internalBuildGeneratedFileFrom(descriptorData,
        new com.google.protobuf.Descriptors.FileDescriptor[] {
          perfetto.protos.PerfEventsOuterClass.getDescriptor(),
        });
    internal_static_perfetto_protos_PerfEventConfig_descriptor =
      getDescriptor().getMessageTypes().get(0);
    internal_static_perfetto_protos_PerfEventConfig_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_perfetto_protos_PerfEventConfig_descriptor,
        new java.lang.String[] { "Timebase", "CallstackSampling", "RingBufferReadPeriodMs", "RingBufferPages", "MaxEnqueuedFootprintKb", "MaxDaemonMemoryKb", "RemoteDescriptorTimeoutMs", "UnwindStateClearPeriodMs", "TargetInstalledBy", "AllCpus", "SamplingFrequency", "KernelFrames", "TargetPid", "TargetCmdline", "ExcludePid", "ExcludeCmdline", "AdditionalCmdlineCount", });
    internal_static_perfetto_protos_PerfEventConfig_CallstackSampling_descriptor =
      internal_static_perfetto_protos_PerfEventConfig_descriptor.getNestedTypes().get(0);
    internal_static_perfetto_protos_PerfEventConfig_CallstackSampling_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_perfetto_protos_PerfEventConfig_CallstackSampling_descriptor,
        new java.lang.String[] { "Scope", "KernelFrames", "UserFrames", });
    internal_static_perfetto_protos_PerfEventConfig_Scope_descriptor =
      internal_static_perfetto_protos_PerfEventConfig_descriptor.getNestedTypes().get(1);
    internal_static_perfetto_protos_PerfEventConfig_Scope_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_perfetto_protos_PerfEventConfig_Scope_descriptor,
        new java.lang.String[] { "TargetPid", "TargetCmdline", "ExcludePid", "ExcludeCmdline", "AdditionalCmdlineCount", "ProcessShardCount", });
    perfetto.protos.PerfEventsOuterClass.getDescriptor();
  }

  // @@protoc_insertion_point(outer_class_scope)
}
