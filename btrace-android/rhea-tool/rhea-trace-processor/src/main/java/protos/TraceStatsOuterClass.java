// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/common/trace_stats.proto

package perfetto.protos;

public final class TraceStatsOuterClass {
  private TraceStatsOuterClass() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }

  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistry registry) {
    registerAllExtensions(
        (com.google.protobuf.ExtensionRegistryLite) registry);
  }
  public interface TraceStatsOrBuilder extends
      // @@protoc_insertion_point(interface_extends:perfetto.protos.TraceStats)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Stats for the TraceBuffer(s) of the current trace session.
     * </pre>
     *
     * <code>repeated .perfetto.protos.TraceStats.BufferStats buffer_stats = 1;</code>
     */
    java.util.List<perfetto.protos.TraceStatsOuterClass.TraceStats.BufferStats> 
        getBufferStatsList();
    /**
     * <pre>
     * Stats for the TraceBuffer(s) of the current trace session.
     * </pre>
     *
     * <code>repeated .perfetto.protos.TraceStats.BufferStats buffer_stats = 1;</code>
     */
    perfetto.protos.TraceStatsOuterClass.TraceStats.BufferStats getBufferStats(int index);
    /**
     * <pre>
     * Stats for the TraceBuffer(s) of the current trace session.
     * </pre>
     *
     * <code>repeated .perfetto.protos.TraceStats.BufferStats buffer_stats = 1;</code>
     */
    int getBufferStatsCount();
    /**
     * <pre>
     * Stats for the TraceBuffer(s) of the current trace session.
     * </pre>
     *
     * <code>repeated .perfetto.protos.TraceStats.BufferStats buffer_stats = 1;</code>
     */
    java.util.List<? extends perfetto.protos.TraceStatsOuterClass.TraceStats.BufferStatsOrBuilder> 
        getBufferStatsOrBuilderList();
    /**
     * <pre>
     * Stats for the TraceBuffer(s) of the current trace session.
     * </pre>
     *
     * <code>repeated .perfetto.protos.TraceStats.BufferStats buffer_stats = 1;</code>
     */
    perfetto.protos.TraceStatsOuterClass.TraceStats.BufferStatsOrBuilder getBufferStatsOrBuilder(
        int index);

    /**
     * <pre>
     * Num. producers connected (whether they are involved in the current tracing
     * session or not).
     * </pre>
     *
     * <code>optional uint32 producers_connected = 2;</code>
     * @return Whether the producersConnected field is set.
     */
    boolean hasProducersConnected();
    /**
     * <pre>
     * Num. producers connected (whether they are involved in the current tracing
     * session or not).
     * </pre>
     *
     * <code>optional uint32 producers_connected = 2;</code>
     * @return The producersConnected.
     */
    int getProducersConnected();

    /**
     * <pre>
     * Num. producers ever seen for all trace sessions since startup (it's a good
     * proxy for inferring num. producers crashed / killed).
     * </pre>
     *
     * <code>optional uint64 producers_seen = 3;</code>
     * @return Whether the producersSeen field is set.
     */
    boolean hasProducersSeen();
    /**
     * <pre>
     * Num. producers ever seen for all trace sessions since startup (it's a good
     * proxy for inferring num. producers crashed / killed).
     * </pre>
     *
     * <code>optional uint64 producers_seen = 3;</code>
     * @return The producersSeen.
     */
    long getProducersSeen();

    /**
     * <pre>
     * Num. data sources registered for all trace sessions.
     * </pre>
     *
     * <code>optional uint32 data_sources_registered = 4;</code>
     * @return Whether the dataSourcesRegistered field is set.
     */
    boolean hasDataSourcesRegistered();
    /**
     * <pre>
     * Num. data sources registered for all trace sessions.
     * </pre>
     *
     * <code>optional uint32 data_sources_registered = 4;</code>
     * @return The dataSourcesRegistered.
     */
    int getDataSourcesRegistered();

    /**
     * <pre>
     * Num. data sources ever seen for all trace sessions since startup.
     * </pre>
     *
     * <code>optional uint64 data_sources_seen = 5;</code>
     * @return Whether the dataSourcesSeen field is set.
     */
    boolean hasDataSourcesSeen();
    /**
     * <pre>
     * Num. data sources ever seen for all trace sessions since startup.
     * </pre>
     *
     * <code>optional uint64 data_sources_seen = 5;</code>
     * @return The dataSourcesSeen.
     */
    long getDataSourcesSeen();

    /**
     * <pre>
     * Num. concurrently active tracing sessions.
     * </pre>
     *
     * <code>optional uint32 tracing_sessions = 6;</code>
     * @return Whether the tracingSessions field is set.
     */
    boolean hasTracingSessions();
    /**
     * <pre>
     * Num. concurrently active tracing sessions.
     * </pre>
     *
     * <code>optional uint32 tracing_sessions = 6;</code>
     * @return The tracingSessions.
     */
    int getTracingSessions();

    /**
     * <pre>
     * Num. buffers for all tracing session (not just the current one). This will
     * be &gt;= buffer_stats.size(), because the latter is only about the current
     * session.
     * </pre>
     *
     * <code>optional uint32 total_buffers = 7;</code>
     * @return Whether the totalBuffers field is set.
     */
    boolean hasTotalBuffers();
    /**
     * <pre>
     * Num. buffers for all tracing session (not just the current one). This will
     * be &gt;= buffer_stats.size(), because the latter is only about the current
     * session.
     * </pre>
     *
     * <code>optional uint32 total_buffers = 7;</code>
     * @return The totalBuffers.
     */
    int getTotalBuffers();

    /**
     * <pre>
     * Num. chunks that were discarded by the service before attempting to commit
     * them to a buffer, e.g. because the producer specified an invalid buffer ID.
     * </pre>
     *
     * <code>optional uint64 chunks_discarded = 8;</code>
     * @return Whether the chunksDiscarded field is set.
     */
    boolean hasChunksDiscarded();
    /**
     * <pre>
     * Num. chunks that were discarded by the service before attempting to commit
     * them to a buffer, e.g. because the producer specified an invalid buffer ID.
     * </pre>
     *
     * <code>optional uint64 chunks_discarded = 8;</code>
     * @return The chunksDiscarded.
     */
    long getChunksDiscarded();

    /**
     * <pre>
     * Num. patches that were discarded by the service before attempting to apply
     * them to a buffer, e.g. because the producer specified an invalid buffer ID.
     * </pre>
     *
     * <code>optional uint64 patches_discarded = 9;</code>
     * @return Whether the patchesDiscarded field is set.
     */
    boolean hasPatchesDiscarded();
    /**
     * <pre>
     * Num. patches that were discarded by the service before attempting to apply
     * them to a buffer, e.g. because the producer specified an invalid buffer ID.
     * </pre>
     *
     * <code>optional uint64 patches_discarded = 9;</code>
     * @return The patchesDiscarded.
     */
    long getPatchesDiscarded();

    /**
     * <pre>
     * Packets that failed validation of the TrustedPacket. If this is &gt; 0, there
     * is a bug in the producer.
     * </pre>
     *
     * <code>optional uint64 invalid_packets = 10;</code>
     * @return Whether the invalidPackets field is set.
     */
    boolean hasInvalidPackets();
    /**
     * <pre>
     * Packets that failed validation of the TrustedPacket. If this is &gt; 0, there
     * is a bug in the producer.
     * </pre>
     *
     * <code>optional uint64 invalid_packets = 10;</code>
     * @return The invalidPackets.
     */
    long getInvalidPackets();

    /**
     * <code>optional .perfetto.protos.TraceStats.FilterStats filter_stats = 11;</code>
     * @return Whether the filterStats field is set.
     */
    boolean hasFilterStats();
    /**
     * <code>optional .perfetto.protos.TraceStats.FilterStats filter_stats = 11;</code>
     * @return The filterStats.
     */
    perfetto.protos.TraceStatsOuterClass.TraceStats.FilterStats getFilterStats();
    /**
     * <code>optional .perfetto.protos.TraceStats.FilterStats filter_stats = 11;</code>
     */
    perfetto.protos.TraceStatsOuterClass.TraceStats.FilterStatsOrBuilder getFilterStatsOrBuilder();

    /**
     * <pre>
     * Count of Flush() requests (either from the Consumer, or self-induced
     * periodic flushes). The final Flush() is also included in the count.
     * </pre>
     *
     * <code>optional uint64 flushes_requested = 12;</code>
     * @return Whether the flushesRequested field is set.
     */
    boolean hasFlushesRequested();
    /**
     * <pre>
     * Count of Flush() requests (either from the Consumer, or self-induced
     * periodic flushes). The final Flush() is also included in the count.
     * </pre>
     *
     * <code>optional uint64 flushes_requested = 12;</code>
     * @return The flushesRequested.
     */
    long getFlushesRequested();

    /**
     * <pre>
     * The count of the Flush() requests that were completed successfully.
     * In a well behaving trace this should always be == `flush_requests`.
     * </pre>
     *
     * <code>optional uint64 flushes_succeeded = 13;</code>
     * @return Whether the flushesSucceeded field is set.
     */
    boolean hasFlushesSucceeded();
    /**
     * <pre>
     * The count of the Flush() requests that were completed successfully.
     * In a well behaving trace this should always be == `flush_requests`.
     * </pre>
     *
     * <code>optional uint64 flushes_succeeded = 13;</code>
     * @return The flushesSucceeded.
     */
    long getFlushesSucceeded();

    /**
     * <pre>
     * The count of the Flush() requests that failed (in most timed out).
     * In a well behaving trace this should always be == 0.
     * </pre>
     *
     * <code>optional uint64 flushes_failed = 14;</code>
     * @return Whether the flushesFailed field is set.
     */
    boolean hasFlushesFailed();
    /**
     * <pre>
     * The count of the Flush() requests that failed (in most timed out).
     * In a well behaving trace this should always be == 0.
     * </pre>
     *
     * <code>optional uint64 flushes_failed = 14;</code>
     * @return The flushesFailed.
     */
    long getFlushesFailed();

    /**
     * <code>optional .perfetto.protos.TraceStats.FinalFlushOutcome final_flush_outcome = 15;</code>
     * @return Whether the finalFlushOutcome field is set.
     */
    boolean hasFinalFlushOutcome();
    /**
     * <code>optional .perfetto.protos.TraceStats.FinalFlushOutcome final_flush_outcome = 15;</code>
     * @return The finalFlushOutcome.
     */
    perfetto.protos.TraceStatsOuterClass.TraceStats.FinalFlushOutcome getFinalFlushOutcome();
  }
  /**
   * <pre>
   * Statistics for the internals of the tracing service.
   * Next id: 16.
   * </pre>
   *
   * Protobuf type {@code perfetto.protos.TraceStats}
   */
  public static final class TraceStats extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:perfetto.protos.TraceStats)
      TraceStatsOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use TraceStats.newBuilder() to construct.
    private TraceStats(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private TraceStats() {
      bufferStats_ = java.util.Collections.emptyList();
      finalFlushOutcome_ = 0;
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new TraceStats();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return perfetto.protos.TraceStatsOuterClass.internal_static_perfetto_protos_TraceStats_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return perfetto.protos.TraceStatsOuterClass.internal_static_perfetto_protos_TraceStats_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              perfetto.protos.TraceStatsOuterClass.TraceStats.class, perfetto.protos.TraceStatsOuterClass.TraceStats.Builder.class);
    }

    /**
     * Protobuf enum {@code perfetto.protos.TraceStats.FinalFlushOutcome}
     */
    public enum FinalFlushOutcome
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <code>FINAL_FLUSH_UNSPECIFIED = 0;</code>
       */
      FINAL_FLUSH_UNSPECIFIED(0),
      /**
       * <code>FINAL_FLUSH_SUCCEEDED = 1;</code>
       */
      FINAL_FLUSH_SUCCEEDED(1),
      /**
       * <code>FINAL_FLUSH_FAILED = 2;</code>
       */
      FINAL_FLUSH_FAILED(2),
      ;

      /**
       * <code>FINAL_FLUSH_UNSPECIFIED = 0;</code>
       */
      public static final int FINAL_FLUSH_UNSPECIFIED_VALUE = 0;
      /**
       * <code>FINAL_FLUSH_SUCCEEDED = 1;</code>
       */
      public static final int FINAL_FLUSH_SUCCEEDED_VALUE = 1;
      /**
       * <code>FINAL_FLUSH_FAILED = 2;</code>
       */
      public static final int FINAL_FLUSH_FAILED_VALUE = 2;


      public final int getNumber() {
        return value;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static FinalFlushOutcome valueOf(int value) {
        return forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       */
      public static FinalFlushOutcome forNumber(int value) {
        switch (value) {
          case 0: return FINAL_FLUSH_UNSPECIFIED;
          case 1: return FINAL_FLUSH_SUCCEEDED;
          case 2: return FINAL_FLUSH_FAILED;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<FinalFlushOutcome>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          FinalFlushOutcome> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<FinalFlushOutcome>() {
              public FinalFlushOutcome findValueByNumber(int number) {
                return FinalFlushOutcome.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return perfetto.protos.TraceStatsOuterClass.TraceStats.getDescriptor().getEnumTypes().get(0);
      }

      private static final FinalFlushOutcome[] VALUES = values();

      public static FinalFlushOutcome valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private FinalFlushOutcome(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:perfetto.protos.TraceStats.FinalFlushOutcome)
    }

    public interface BufferStatsOrBuilder extends
        // @@protoc_insertion_point(interface_extends:perfetto.protos.TraceStats.BufferStats)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <pre>
       * Size of the circular buffer in bytes.
       * </pre>
       *
       * <code>optional uint64 buffer_size = 12;</code>
       * @return Whether the bufferSize field is set.
       */
      boolean hasBufferSize();
      /**
       * <pre>
       * Size of the circular buffer in bytes.
       * </pre>
       *
       * <code>optional uint64 buffer_size = 12;</code>
       * @return The bufferSize.
       */
      long getBufferSize();

      /**
       * <pre>
       * Num. bytes written into the circular buffer, including chunk headers.
       * </pre>
       *
       * <code>optional uint64 bytes_written = 1;</code>
       * @return Whether the bytesWritten field is set.
       */
      boolean hasBytesWritten();
      /**
       * <pre>
       * Num. bytes written into the circular buffer, including chunk headers.
       * </pre>
       *
       * <code>optional uint64 bytes_written = 1;</code>
       * @return The bytesWritten.
       */
      long getBytesWritten();

      /**
       * <pre>
       * Num. bytes overwritten before they have been read (i.e. loss of data).
       * </pre>
       *
       * <code>optional uint64 bytes_overwritten = 13;</code>
       * @return Whether the bytesOverwritten field is set.
       */
      boolean hasBytesOverwritten();
      /**
       * <pre>
       * Num. bytes overwritten before they have been read (i.e. loss of data).
       * </pre>
       *
       * <code>optional uint64 bytes_overwritten = 13;</code>
       * @return The bytesOverwritten.
       */
      long getBytesOverwritten();

      /**
       * <pre>
       * Total size of chunks that were fully read from the circular buffer by the
       * consumer. This may not be equal to |bytes_written| either in the middle
       * of tracing, or if |chunks_overwritten| is non-zero. Note that this is the
       * size of the chunks read from the buffer, including chunk headers, which
       * will be different from the total size of packets returned to the
       * consumer.
       * The current utilization of the trace buffer (mid-tracing) can be obtained
       * by subtracting |bytes_read| and |bytes_overwritten| from |bytes_written|,
       * adding the difference of |padding_bytes_written| and
       * |padding_bytes_cleared|, and comparing this sum to the |buffer_size|.
       * Note that this represents the total size of buffered data in the buffer,
       * yet this data may be spread non-contiguously through the buffer and may
       * be overridden before the utilization reaches 100%.
       * </pre>
       *
       * <code>optional uint64 bytes_read = 14;</code>
       * @return Whether the bytesRead field is set.
       */
      boolean hasBytesRead();
      /**
       * <pre>
       * Total size of chunks that were fully read from the circular buffer by the
       * consumer. This may not be equal to |bytes_written| either in the middle
       * of tracing, or if |chunks_overwritten| is non-zero. Note that this is the
       * size of the chunks read from the buffer, including chunk headers, which
       * will be different from the total size of packets returned to the
       * consumer.
       * The current utilization of the trace buffer (mid-tracing) can be obtained
       * by subtracting |bytes_read| and |bytes_overwritten| from |bytes_written|,
       * adding the difference of |padding_bytes_written| and
       * |padding_bytes_cleared|, and comparing this sum to the |buffer_size|.
       * Note that this represents the total size of buffered data in the buffer,
       * yet this data may be spread non-contiguously through the buffer and may
       * be overridden before the utilization reaches 100%.
       * </pre>
       *
       * <code>optional uint64 bytes_read = 14;</code>
       * @return The bytesRead.
       */
      long getBytesRead();

      /**
       * <pre>
       * Num. bytes that were allocated as padding between chunks in the circular
       * buffer.
       * </pre>
       *
       * <code>optional uint64 padding_bytes_written = 15;</code>
       * @return Whether the paddingBytesWritten field is set.
       */
      boolean hasPaddingBytesWritten();
      /**
       * <pre>
       * Num. bytes that were allocated as padding between chunks in the circular
       * buffer.
       * </pre>
       *
       * <code>optional uint64 padding_bytes_written = 15;</code>
       * @return The paddingBytesWritten.
       */
      long getPaddingBytesWritten();

      /**
       * <pre>
       * Num. of padding bytes that were removed from the circular buffer when
       * they were overwritten.
       * The difference between |padding_bytes_written| and
       * |padding_bytes_cleared| denotes the total size of padding currently
       * present in the buffer.
       * </pre>
       *
       * <code>optional uint64 padding_bytes_cleared = 16;</code>
       * @return Whether the paddingBytesCleared field is set.
       */
      boolean hasPaddingBytesCleared();
      /**
       * <pre>
       * Num. of padding bytes that were removed from the circular buffer when
       * they were overwritten.
       * The difference between |padding_bytes_written| and
       * |padding_bytes_cleared| denotes the total size of padding currently
       * present in the buffer.
       * </pre>
       *
       * <code>optional uint64 padding_bytes_cleared = 16;</code>
       * @return The paddingBytesCleared.
       */
      long getPaddingBytesCleared();

      /**
       * <pre>
       * Num. chunks (!= packets) written into the buffer.
       * </pre>
       *
       * <code>optional uint64 chunks_written = 2;</code>
       * @return Whether the chunksWritten field is set.
       */
      boolean hasChunksWritten();
      /**
       * <pre>
       * Num. chunks (!= packets) written into the buffer.
       * </pre>
       *
       * <code>optional uint64 chunks_written = 2;</code>
       * @return The chunksWritten.
       */
      long getChunksWritten();

      /**
       * <pre>
       * Num. chunks (!= packets) rewritten into the buffer. This means we rewrote
       * the same chunk with additional packets appended to the end.
       * </pre>
       *
       * <code>optional uint64 chunks_rewritten = 10;</code>
       * @return Whether the chunksRewritten field is set.
       */
      boolean hasChunksRewritten();
      /**
       * <pre>
       * Num. chunks (!= packets) rewritten into the buffer. This means we rewrote
       * the same chunk with additional packets appended to the end.
       * </pre>
       *
       * <code>optional uint64 chunks_rewritten = 10;</code>
       * @return The chunksRewritten.
       */
      long getChunksRewritten();

      /**
       * <pre>
       * Num. chunks overwritten before they have been read (i.e. loss of data).
       * </pre>
       *
       * <code>optional uint64 chunks_overwritten = 3;</code>
       * @return Whether the chunksOverwritten field is set.
       */
      boolean hasChunksOverwritten();
      /**
       * <pre>
       * Num. chunks overwritten before they have been read (i.e. loss of data).
       * </pre>
       *
       * <code>optional uint64 chunks_overwritten = 3;</code>
       * @return The chunksOverwritten.
       */
      long getChunksOverwritten();

      /**
       * <pre>
       * Num. chunks discarded (i.e. loss of data). Can be &gt; 0 only when a buffer
       * is configured with FillPolicy == DISCARD.
       * </pre>
       *
       * <code>optional uint64 chunks_discarded = 18;</code>
       * @return Whether the chunksDiscarded field is set.
       */
      boolean hasChunksDiscarded();
      /**
       * <pre>
       * Num. chunks discarded (i.e. loss of data). Can be &gt; 0 only when a buffer
       * is configured with FillPolicy == DISCARD.
       * </pre>
       *
       * <code>optional uint64 chunks_discarded = 18;</code>
       * @return The chunksDiscarded.
       */
      long getChunksDiscarded();

      /**
       * <pre>
       * Num. chunks (!= packets) that were fully read from the circular buffer by
       * the consumer. This may not be equal to |chunks_written| either in the
       * middle of tracing, or if |chunks_overwritten| is non-zero.
       * </pre>
       *
       * <code>optional uint64 chunks_read = 17;</code>
       * @return Whether the chunksRead field is set.
       */
      boolean hasChunksRead();
      /**
       * <pre>
       * Num. chunks (!= packets) that were fully read from the circular buffer by
       * the consumer. This may not be equal to |chunks_written| either in the
       * middle of tracing, or if |chunks_overwritten| is non-zero.
       * </pre>
       *
       * <code>optional uint64 chunks_read = 17;</code>
       * @return The chunksRead.
       */
      long getChunksRead();

      /**
       * <pre>
       * Num. chunks that were committed out of order.
       * </pre>
       *
       * <code>optional uint64 chunks_committed_out_of_order = 11;</code>
       * @return Whether the chunksCommittedOutOfOrder field is set.
       */
      boolean hasChunksCommittedOutOfOrder();
      /**
       * <pre>
       * Num. chunks that were committed out of order.
       * </pre>
       *
       * <code>optional uint64 chunks_committed_out_of_order = 11;</code>
       * @return The chunksCommittedOutOfOrder.
       */
      long getChunksCommittedOutOfOrder();

      /**
       * <pre>
       * Num. times the ring buffer wrapped around.
       * </pre>
       *
       * <code>optional uint64 write_wrap_count = 4;</code>
       * @return Whether the writeWrapCount field is set.
       */
      boolean hasWriteWrapCount();
      /**
       * <pre>
       * Num. times the ring buffer wrapped around.
       * </pre>
       *
       * <code>optional uint64 write_wrap_count = 4;</code>
       * @return The writeWrapCount.
       */
      long getWriteWrapCount();

      /**
       * <pre>
       * Num. out-of-band (OOB) patches that succeeded.
       * </pre>
       *
       * <code>optional uint64 patches_succeeded = 5;</code>
       * @return Whether the patchesSucceeded field is set.
       */
      boolean hasPatchesSucceeded();
      /**
       * <pre>
       * Num. out-of-band (OOB) patches that succeeded.
       * </pre>
       *
       * <code>optional uint64 patches_succeeded = 5;</code>
       * @return The patchesSucceeded.
       */
      long getPatchesSucceeded();

      /**
       * <pre>
       * Num. OOB patches that failed (e.g., the chunk to patch was gone).
       * </pre>
       *
       * <code>optional uint64 patches_failed = 6;</code>
       * @return Whether the patchesFailed field is set.
       */
      boolean hasPatchesFailed();
      /**
       * <pre>
       * Num. OOB patches that failed (e.g., the chunk to patch was gone).
       * </pre>
       *
       * <code>optional uint64 patches_failed = 6;</code>
       * @return The patchesFailed.
       */
      long getPatchesFailed();

      /**
       * <pre>
       * Num. readaheads (for large multi-chunk packet reads) that ended up in a
       * successful packet read.
       * </pre>
       *
       * <code>optional uint64 readaheads_succeeded = 7;</code>
       * @return Whether the readaheadsSucceeded field is set.
       */
      boolean hasReadaheadsSucceeded();
      /**
       * <pre>
       * Num. readaheads (for large multi-chunk packet reads) that ended up in a
       * successful packet read.
       * </pre>
       *
       * <code>optional uint64 readaheads_succeeded = 7;</code>
       * @return The readaheadsSucceeded.
       */
      long getReadaheadsSucceeded();

      /**
       * <pre>
       * Num. readaheads aborted because of missing chunks in the sequence stream.
       * Note that a small number &gt; 0 is totally expected: occasionally, when
       * issuing a read, the very last packet in a sequence might be incomplete
       * (because the producer is still writing it while we read). The read will
       * stop at that point, for that sequence, increasing this counter.
       * </pre>
       *
       * <code>optional uint64 readaheads_failed = 8;</code>
       * @return Whether the readaheadsFailed field is set.
       */
      boolean hasReadaheadsFailed();
      /**
       * <pre>
       * Num. readaheads aborted because of missing chunks in the sequence stream.
       * Note that a small number &gt; 0 is totally expected: occasionally, when
       * issuing a read, the very last packet in a sequence might be incomplete
       * (because the producer is still writing it while we read). The read will
       * stop at that point, for that sequence, increasing this counter.
       * </pre>
       *
       * <code>optional uint64 readaheads_failed = 8;</code>
       * @return The readaheadsFailed.
       */
      long getReadaheadsFailed();

      /**
       * <pre>
       * Num. of violations of the SharedMemoryABI found while writing or reading
       * the buffer. This is an indication of either a bug in the producer(s) or
       * malicious producer(s).
       * </pre>
       *
       * <code>optional uint64 abi_violations = 9;</code>
       * @return Whether the abiViolations field is set.
       */
      boolean hasAbiViolations();
      /**
       * <pre>
       * Num. of violations of the SharedMemoryABI found while writing or reading
       * the buffer. This is an indication of either a bug in the producer(s) or
       * malicious producer(s).
       * </pre>
       *
       * <code>optional uint64 abi_violations = 9;</code>
       * @return The abiViolations.
       */
      long getAbiViolations();

      /**
       * <pre>
       * Num. of times the service detected packet loss on a trace writer
       * sequence. This is usually caused by exhaustion of available chunks in the
       * writer process's SMB. Note that this relies on the client's TraceWriter
       * indicating this loss to the service -- packets lost for other reasons are
       * not reflected in this stat.
       * </pre>
       *
       * <code>optional uint64 trace_writer_packet_loss = 19;</code>
       * @return Whether the traceWriterPacketLoss field is set.
       */
      boolean hasTraceWriterPacketLoss();
      /**
       * <pre>
       * Num. of times the service detected packet loss on a trace writer
       * sequence. This is usually caused by exhaustion of available chunks in the
       * writer process's SMB. Note that this relies on the client's TraceWriter
       * indicating this loss to the service -- packets lost for other reasons are
       * not reflected in this stat.
       * </pre>
       *
       * <code>optional uint64 trace_writer_packet_loss = 19;</code>
       * @return The traceWriterPacketLoss.
       */
      long getTraceWriterPacketLoss();
    }
    /**
     * <pre>
     * From TraceBuffer::Stats.
     * Next id: 20.
     * </pre>
     *
     * Protobuf type {@code perfetto.protos.TraceStats.BufferStats}
     */
    public static final class BufferStats extends
        com.google.protobuf.GeneratedMessageV3 implements
        // @@protoc_insertion_point(message_implements:perfetto.protos.TraceStats.BufferStats)
        BufferStatsOrBuilder {
    private static final long serialVersionUID = 0L;
      // Use BufferStats.newBuilder() to construct.
      private BufferStats(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
      }
      private BufferStats() {
      }

      @java.lang.Override
      @SuppressWarnings({"unused"})
      protected java.lang.Object newInstance(
          UnusedPrivateParameter unused) {
        return new BufferStats();
      }

      @java.lang.Override
      public final com.google.protobuf.UnknownFieldSet
      getUnknownFields() {
        return this.unknownFields;
      }
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return perfetto.protos.TraceStatsOuterClass.internal_static_perfetto_protos_TraceStats_BufferStats_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return perfetto.protos.TraceStatsOuterClass.internal_static_perfetto_protos_TraceStats_BufferStats_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                perfetto.protos.TraceStatsOuterClass.TraceStats.BufferStats.class, perfetto.protos.TraceStatsOuterClass.TraceStats.BufferStats.Builder.class);
      }

      private int bitField0_;
      public static final int BUFFER_SIZE_FIELD_NUMBER = 12;
      private long bufferSize_ = 0L;
      /**
       * <pre>
       * Size of the circular buffer in bytes.
       * </pre>
       *
       * <code>optional uint64 buffer_size = 12;</code>
       * @return Whether the bufferSize field is set.
       */
      @java.lang.Override
      public boolean hasBufferSize() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Size of the circular buffer in bytes.
       * </pre>
       *
       * <code>optional uint64 buffer_size = 12;</code>
       * @return The bufferSize.
       */
      @java.lang.Override
      public long getBufferSize() {
        return bufferSize_;
      }

      public static final int BYTES_WRITTEN_FIELD_NUMBER = 1;
      private long bytesWritten_ = 0L;
      /**
       * <pre>
       * Num. bytes written into the circular buffer, including chunk headers.
       * </pre>
       *
       * <code>optional uint64 bytes_written = 1;</code>
       * @return Whether the bytesWritten field is set.
       */
      @java.lang.Override
      public boolean hasBytesWritten() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Num. bytes written into the circular buffer, including chunk headers.
       * </pre>
       *
       * <code>optional uint64 bytes_written = 1;</code>
       * @return The bytesWritten.
       */
      @java.lang.Override
      public long getBytesWritten() {
        return bytesWritten_;
      }

      public static final int BYTES_OVERWRITTEN_FIELD_NUMBER = 13;
      private long bytesOverwritten_ = 0L;
      /**
       * <pre>
       * Num. bytes overwritten before they have been read (i.e. loss of data).
       * </pre>
       *
       * <code>optional uint64 bytes_overwritten = 13;</code>
       * @return Whether the bytesOverwritten field is set.
       */
      @java.lang.Override
      public boolean hasBytesOverwritten() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * Num. bytes overwritten before they have been read (i.e. loss of data).
       * </pre>
       *
       * <code>optional uint64 bytes_overwritten = 13;</code>
       * @return The bytesOverwritten.
       */
      @java.lang.Override
      public long getBytesOverwritten() {
        return bytesOverwritten_;
      }

      public static final int BYTES_READ_FIELD_NUMBER = 14;
      private long bytesRead_ = 0L;
      /**
       * <pre>
       * Total size of chunks that were fully read from the circular buffer by the
       * consumer. This may not be equal to |bytes_written| either in the middle
       * of tracing, or if |chunks_overwritten| is non-zero. Note that this is the
       * size of the chunks read from the buffer, including chunk headers, which
       * will be different from the total size of packets returned to the
       * consumer.
       * The current utilization of the trace buffer (mid-tracing) can be obtained
       * by subtracting |bytes_read| and |bytes_overwritten| from |bytes_written|,
       * adding the difference of |padding_bytes_written| and
       * |padding_bytes_cleared|, and comparing this sum to the |buffer_size|.
       * Note that this represents the total size of buffered data in the buffer,
       * yet this data may be spread non-contiguously through the buffer and may
       * be overridden before the utilization reaches 100%.
       * </pre>
       *
       * <code>optional uint64 bytes_read = 14;</code>
       * @return Whether the bytesRead field is set.
       */
      @java.lang.Override
      public boolean hasBytesRead() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * Total size of chunks that were fully read from the circular buffer by the
       * consumer. This may not be equal to |bytes_written| either in the middle
       * of tracing, or if |chunks_overwritten| is non-zero. Note that this is the
       * size of the chunks read from the buffer, including chunk headers, which
       * will be different from the total size of packets returned to the
       * consumer.
       * The current utilization of the trace buffer (mid-tracing) can be obtained
       * by subtracting |bytes_read| and |bytes_overwritten| from |bytes_written|,
       * adding the difference of |padding_bytes_written| and
       * |padding_bytes_cleared|, and comparing this sum to the |buffer_size|.
       * Note that this represents the total size of buffered data in the buffer,
       * yet this data may be spread non-contiguously through the buffer and may
       * be overridden before the utilization reaches 100%.
       * </pre>
       *
       * <code>optional uint64 bytes_read = 14;</code>
       * @return The bytesRead.
       */
      @java.lang.Override
      public long getBytesRead() {
        return bytesRead_;
      }

      public static final int PADDING_BYTES_WRITTEN_FIELD_NUMBER = 15;
      private long paddingBytesWritten_ = 0L;
      /**
       * <pre>
       * Num. bytes that were allocated as padding between chunks in the circular
       * buffer.
       * </pre>
       *
       * <code>optional uint64 padding_bytes_written = 15;</code>
       * @return Whether the paddingBytesWritten field is set.
       */
      @java.lang.Override
      public boolean hasPaddingBytesWritten() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * Num. bytes that were allocated as padding between chunks in the circular
       * buffer.
       * </pre>
       *
       * <code>optional uint64 padding_bytes_written = 15;</code>
       * @return The paddingBytesWritten.
       */
      @java.lang.Override
      public long getPaddingBytesWritten() {
        return paddingBytesWritten_;
      }

      public static final int PADDING_BYTES_CLEARED_FIELD_NUMBER = 16;
      private long paddingBytesCleared_ = 0L;
      /**
       * <pre>
       * Num. of padding bytes that were removed from the circular buffer when
       * they were overwritten.
       * The difference between |padding_bytes_written| and
       * |padding_bytes_cleared| denotes the total size of padding currently
       * present in the buffer.
       * </pre>
       *
       * <code>optional uint64 padding_bytes_cleared = 16;</code>
       * @return Whether the paddingBytesCleared field is set.
       */
      @java.lang.Override
      public boolean hasPaddingBytesCleared() {
        return ((bitField0_ & 0x00000020) != 0);
      }
      /**
       * <pre>
       * Num. of padding bytes that were removed from the circular buffer when
       * they were overwritten.
       * The difference between |padding_bytes_written| and
       * |padding_bytes_cleared| denotes the total size of padding currently
       * present in the buffer.
       * </pre>
       *
       * <code>optional uint64 padding_bytes_cleared = 16;</code>
       * @return The paddingBytesCleared.
       */
      @java.lang.Override
      public long getPaddingBytesCleared() {
        return paddingBytesCleared_;
      }

      public static final int CHUNKS_WRITTEN_FIELD_NUMBER = 2;
      private long chunksWritten_ = 0L;
      /**
       * <pre>
       * Num. chunks (!= packets) written into the buffer.
       * </pre>
       *
       * <code>optional uint64 chunks_written = 2;</code>
       * @return Whether the chunksWritten field is set.
       */
      @java.lang.Override
      public boolean hasChunksWritten() {
        return ((bitField0_ & 0x00000040) != 0);
      }
      /**
       * <pre>
       * Num. chunks (!= packets) written into the buffer.
       * </pre>
       *
       * <code>optional uint64 chunks_written = 2;</code>
       * @return The chunksWritten.
       */
      @java.lang.Override
      public long getChunksWritten() {
        return chunksWritten_;
      }

      public static final int CHUNKS_REWRITTEN_FIELD_NUMBER = 10;
      private long chunksRewritten_ = 0L;
      /**
       * <pre>
       * Num. chunks (!= packets) rewritten into the buffer. This means we rewrote
       * the same chunk with additional packets appended to the end.
       * </pre>
       *
       * <code>optional uint64 chunks_rewritten = 10;</code>
       * @return Whether the chunksRewritten field is set.
       */
      @java.lang.Override
      public boolean hasChunksRewritten() {
        return ((bitField0_ & 0x00000080) != 0);
      }
      /**
       * <pre>
       * Num. chunks (!= packets) rewritten into the buffer. This means we rewrote
       * the same chunk with additional packets appended to the end.
       * </pre>
       *
       * <code>optional uint64 chunks_rewritten = 10;</code>
       * @return The chunksRewritten.
       */
      @java.lang.Override
      public long getChunksRewritten() {
        return chunksRewritten_;
      }

      public static final int CHUNKS_OVERWRITTEN_FIELD_NUMBER = 3;
      private long chunksOverwritten_ = 0L;
      /**
       * <pre>
       * Num. chunks overwritten before they have been read (i.e. loss of data).
       * </pre>
       *
       * <code>optional uint64 chunks_overwritten = 3;</code>
       * @return Whether the chunksOverwritten field is set.
       */
      @java.lang.Override
      public boolean hasChunksOverwritten() {
        return ((bitField0_ & 0x00000100) != 0);
      }
      /**
       * <pre>
       * Num. chunks overwritten before they have been read (i.e. loss of data).
       * </pre>
       *
       * <code>optional uint64 chunks_overwritten = 3;</code>
       * @return The chunksOverwritten.
       */
      @java.lang.Override
      public long getChunksOverwritten() {
        return chunksOverwritten_;
      }

      public static final int CHUNKS_DISCARDED_FIELD_NUMBER = 18;
      private long chunksDiscarded_ = 0L;
      /**
       * <pre>
       * Num. chunks discarded (i.e. loss of data). Can be &gt; 0 only when a buffer
       * is configured with FillPolicy == DISCARD.
       * </pre>
       *
       * <code>optional uint64 chunks_discarded = 18;</code>
       * @return Whether the chunksDiscarded field is set.
       */
      @java.lang.Override
      public boolean hasChunksDiscarded() {
        return ((bitField0_ & 0x00000200) != 0);
      }
      /**
       * <pre>
       * Num. chunks discarded (i.e. loss of data). Can be &gt; 0 only when a buffer
       * is configured with FillPolicy == DISCARD.
       * </pre>
       *
       * <code>optional uint64 chunks_discarded = 18;</code>
       * @return The chunksDiscarded.
       */
      @java.lang.Override
      public long getChunksDiscarded() {
        return chunksDiscarded_;
      }

      public static final int CHUNKS_READ_FIELD_NUMBER = 17;
      private long chunksRead_ = 0L;
      /**
       * <pre>
       * Num. chunks (!= packets) that were fully read from the circular buffer by
       * the consumer. This may not be equal to |chunks_written| either in the
       * middle of tracing, or if |chunks_overwritten| is non-zero.
       * </pre>
       *
       * <code>optional uint64 chunks_read = 17;</code>
       * @return Whether the chunksRead field is set.
       */
      @java.lang.Override
      public boolean hasChunksRead() {
        return ((bitField0_ & 0x00000400) != 0);
      }
      /**
       * <pre>
       * Num. chunks (!= packets) that were fully read from the circular buffer by
       * the consumer. This may not be equal to |chunks_written| either in the
       * middle of tracing, or if |chunks_overwritten| is non-zero.
       * </pre>
       *
       * <code>optional uint64 chunks_read = 17;</code>
       * @return The chunksRead.
       */
      @java.lang.Override
      public long getChunksRead() {
        return chunksRead_;
      }

      public static final int CHUNKS_COMMITTED_OUT_OF_ORDER_FIELD_NUMBER = 11;
      private long chunksCommittedOutOfOrder_ = 0L;
      /**
       * <pre>
       * Num. chunks that were committed out of order.
       * </pre>
       *
       * <code>optional uint64 chunks_committed_out_of_order = 11;</code>
       * @return Whether the chunksCommittedOutOfOrder field is set.
       */
      @java.lang.Override
      public boolean hasChunksCommittedOutOfOrder() {
        return ((bitField0_ & 0x00000800) != 0);
      }
      /**
       * <pre>
       * Num. chunks that were committed out of order.
       * </pre>
       *
       * <code>optional uint64 chunks_committed_out_of_order = 11;</code>
       * @return The chunksCommittedOutOfOrder.
       */
      @java.lang.Override
      public long getChunksCommittedOutOfOrder() {
        return chunksCommittedOutOfOrder_;
      }

      public static final int WRITE_WRAP_COUNT_FIELD_NUMBER = 4;
      private long writeWrapCount_ = 0L;
      /**
       * <pre>
       * Num. times the ring buffer wrapped around.
       * </pre>
       *
       * <code>optional uint64 write_wrap_count = 4;</code>
       * @return Whether the writeWrapCount field is set.
       */
      @java.lang.Override
      public boolean hasWriteWrapCount() {
        return ((bitField0_ & 0x00001000) != 0);
      }
      /**
       * <pre>
       * Num. times the ring buffer wrapped around.
       * </pre>
       *
       * <code>optional uint64 write_wrap_count = 4;</code>
       * @return The writeWrapCount.
       */
      @java.lang.Override
      public long getWriteWrapCount() {
        return writeWrapCount_;
      }

      public static final int PATCHES_SUCCEEDED_FIELD_NUMBER = 5;
      private long patchesSucceeded_ = 0L;
      /**
       * <pre>
       * Num. out-of-band (OOB) patches that succeeded.
       * </pre>
       *
       * <code>optional uint64 patches_succeeded = 5;</code>
       * @return Whether the patchesSucceeded field is set.
       */
      @java.lang.Override
      public boolean hasPatchesSucceeded() {
        return ((bitField0_ & 0x00002000) != 0);
      }
      /**
       * <pre>
       * Num. out-of-band (OOB) patches that succeeded.
       * </pre>
       *
       * <code>optional uint64 patches_succeeded = 5;</code>
       * @return The patchesSucceeded.
       */
      @java.lang.Override
      public long getPatchesSucceeded() {
        return patchesSucceeded_;
      }

      public static final int PATCHES_FAILED_FIELD_NUMBER = 6;
      private long patchesFailed_ = 0L;
      /**
       * <pre>
       * Num. OOB patches that failed (e.g., the chunk to patch was gone).
       * </pre>
       *
       * <code>optional uint64 patches_failed = 6;</code>
       * @return Whether the patchesFailed field is set.
       */
      @java.lang.Override
      public boolean hasPatchesFailed() {
        return ((bitField0_ & 0x00004000) != 0);
      }
      /**
       * <pre>
       * Num. OOB patches that failed (e.g., the chunk to patch was gone).
       * </pre>
       *
       * <code>optional uint64 patches_failed = 6;</code>
       * @return The patchesFailed.
       */
      @java.lang.Override
      public long getPatchesFailed() {
        return patchesFailed_;
      }

      public static final int READAHEADS_SUCCEEDED_FIELD_NUMBER = 7;
      private long readaheadsSucceeded_ = 0L;
      /**
       * <pre>
       * Num. readaheads (for large multi-chunk packet reads) that ended up in a
       * successful packet read.
       * </pre>
       *
       * <code>optional uint64 readaheads_succeeded = 7;</code>
       * @return Whether the readaheadsSucceeded field is set.
       */
      @java.lang.Override
      public boolean hasReadaheadsSucceeded() {
        return ((bitField0_ & 0x00008000) != 0);
      }
      /**
       * <pre>
       * Num. readaheads (for large multi-chunk packet reads) that ended up in a
       * successful packet read.
       * </pre>
       *
       * <code>optional uint64 readaheads_succeeded = 7;</code>
       * @return The readaheadsSucceeded.
       */
      @java.lang.Override
      public long getReadaheadsSucceeded() {
        return readaheadsSucceeded_;
      }

      public static final int READAHEADS_FAILED_FIELD_NUMBER = 8;
      private long readaheadsFailed_ = 0L;
      /**
       * <pre>
       * Num. readaheads aborted because of missing chunks in the sequence stream.
       * Note that a small number &gt; 0 is totally expected: occasionally, when
       * issuing a read, the very last packet in a sequence might be incomplete
       * (because the producer is still writing it while we read). The read will
       * stop at that point, for that sequence, increasing this counter.
       * </pre>
       *
       * <code>optional uint64 readaheads_failed = 8;</code>
       * @return Whether the readaheadsFailed field is set.
       */
      @java.lang.Override
      public boolean hasReadaheadsFailed() {
        return ((bitField0_ & 0x00010000) != 0);
      }
      /**
       * <pre>
       * Num. readaheads aborted because of missing chunks in the sequence stream.
       * Note that a small number &gt; 0 is totally expected: occasionally, when
       * issuing a read, the very last packet in a sequence might be incomplete
       * (because the producer is still writing it while we read). The read will
       * stop at that point, for that sequence, increasing this counter.
       * </pre>
       *
       * <code>optional uint64 readaheads_failed = 8;</code>
       * @return The readaheadsFailed.
       */
      @java.lang.Override
      public long getReadaheadsFailed() {
        return readaheadsFailed_;
      }

      public static final int ABI_VIOLATIONS_FIELD_NUMBER = 9;
      private long abiViolations_ = 0L;
      /**
       * <pre>
       * Num. of violations of the SharedMemoryABI found while writing or reading
       * the buffer. This is an indication of either a bug in the producer(s) or
       * malicious producer(s).
       * </pre>
       *
       * <code>optional uint64 abi_violations = 9;</code>
       * @return Whether the abiViolations field is set.
       */
      @java.lang.Override
      public boolean hasAbiViolations() {
        return ((bitField0_ & 0x00020000) != 0);
      }
      /**
       * <pre>
       * Num. of violations of the SharedMemoryABI found while writing or reading
       * the buffer. This is an indication of either a bug in the producer(s) or
       * malicious producer(s).
       * </pre>
       *
       * <code>optional uint64 abi_violations = 9;</code>
       * @return The abiViolations.
       */
      @java.lang.Override
      public long getAbiViolations() {
        return abiViolations_;
      }

      public static final int TRACE_WRITER_PACKET_LOSS_FIELD_NUMBER = 19;
      private long traceWriterPacketLoss_ = 0L;
      /**
       * <pre>
       * Num. of times the service detected packet loss on a trace writer
       * sequence. This is usually caused by exhaustion of available chunks in the
       * writer process's SMB. Note that this relies on the client's TraceWriter
       * indicating this loss to the service -- packets lost for other reasons are
       * not reflected in this stat.
       * </pre>
       *
       * <code>optional uint64 trace_writer_packet_loss = 19;</code>
       * @return Whether the traceWriterPacketLoss field is set.
       */
      @java.lang.Override
      public boolean hasTraceWriterPacketLoss() {
        return ((bitField0_ & 0x00040000) != 0);
      }
      /**
       * <pre>
       * Num. of times the service detected packet loss on a trace writer
       * sequence. This is usually caused by exhaustion of available chunks in the
       * writer process's SMB. Note that this relies on the client's TraceWriter
       * indicating this loss to the service -- packets lost for other reasons are
       * not reflected in this stat.
       * </pre>
       *
       * <code>optional uint64 trace_writer_packet_loss = 19;</code>
       * @return The traceWriterPacketLoss.
       */
      @java.lang.Override
      public long getTraceWriterPacketLoss() {
        return traceWriterPacketLoss_;
      }

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        if (((bitField0_ & 0x00000002) != 0)) {
          output.writeUInt64(1, bytesWritten_);
        }
        if (((bitField0_ & 0x00000040) != 0)) {
          output.writeUInt64(2, chunksWritten_);
        }
        if (((bitField0_ & 0x00000100) != 0)) {
          output.writeUInt64(3, chunksOverwritten_);
        }
        if (((bitField0_ & 0x00001000) != 0)) {
          output.writeUInt64(4, writeWrapCount_);
        }
        if (((bitField0_ & 0x00002000) != 0)) {
          output.writeUInt64(5, patchesSucceeded_);
        }
        if (((bitField0_ & 0x00004000) != 0)) {
          output.writeUInt64(6, patchesFailed_);
        }
        if (((bitField0_ & 0x00008000) != 0)) {
          output.writeUInt64(7, readaheadsSucceeded_);
        }
        if (((bitField0_ & 0x00010000) != 0)) {
          output.writeUInt64(8, readaheadsFailed_);
        }
        if (((bitField0_ & 0x00020000) != 0)) {
          output.writeUInt64(9, abiViolations_);
        }
        if (((bitField0_ & 0x00000080) != 0)) {
          output.writeUInt64(10, chunksRewritten_);
        }
        if (((bitField0_ & 0x00000800) != 0)) {
          output.writeUInt64(11, chunksCommittedOutOfOrder_);
        }
        if (((bitField0_ & 0x00000001) != 0)) {
          output.writeUInt64(12, bufferSize_);
        }
        if (((bitField0_ & 0x00000004) != 0)) {
          output.writeUInt64(13, bytesOverwritten_);
        }
        if (((bitField0_ & 0x00000008) != 0)) {
          output.writeUInt64(14, bytesRead_);
        }
        if (((bitField0_ & 0x00000010) != 0)) {
          output.writeUInt64(15, paddingBytesWritten_);
        }
        if (((bitField0_ & 0x00000020) != 0)) {
          output.writeUInt64(16, paddingBytesCleared_);
        }
        if (((bitField0_ & 0x00000400) != 0)) {
          output.writeUInt64(17, chunksRead_);
        }
        if (((bitField0_ & 0x00000200) != 0)) {
          output.writeUInt64(18, chunksDiscarded_);
        }
        if (((bitField0_ & 0x00040000) != 0)) {
          output.writeUInt64(19, traceWriterPacketLoss_);
        }
        getUnknownFields().writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (((bitField0_ & 0x00000002) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt64Size(1, bytesWritten_);
        }
        if (((bitField0_ & 0x00000040) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt64Size(2, chunksWritten_);
        }
        if (((bitField0_ & 0x00000100) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt64Size(3, chunksOverwritten_);
        }
        if (((bitField0_ & 0x00001000) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt64Size(4, writeWrapCount_);
        }
        if (((bitField0_ & 0x00002000) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt64Size(5, patchesSucceeded_);
        }
        if (((bitField0_ & 0x00004000) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt64Size(6, patchesFailed_);
        }
        if (((bitField0_ & 0x00008000) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt64Size(7, readaheadsSucceeded_);
        }
        if (((bitField0_ & 0x00010000) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt64Size(8, readaheadsFailed_);
        }
        if (((bitField0_ & 0x00020000) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt64Size(9, abiViolations_);
        }
        if (((bitField0_ & 0x00000080) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt64Size(10, chunksRewritten_);
        }
        if (((bitField0_ & 0x00000800) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt64Size(11, chunksCommittedOutOfOrder_);
        }
        if (((bitField0_ & 0x00000001) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt64Size(12, bufferSize_);
        }
        if (((bitField0_ & 0x00000004) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt64Size(13, bytesOverwritten_);
        }
        if (((bitField0_ & 0x00000008) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt64Size(14, bytesRead_);
        }
        if (((bitField0_ & 0x00000010) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt64Size(15, paddingBytesWritten_);
        }
        if (((bitField0_ & 0x00000020) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt64Size(16, paddingBytesCleared_);
        }
        if (((bitField0_ & 0x00000400) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt64Size(17, chunksRead_);
        }
        if (((bitField0_ & 0x00000200) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt64Size(18, chunksDiscarded_);
        }
        if (((bitField0_ & 0x00040000) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt64Size(19, traceWriterPacketLoss_);
        }
        size += getUnknownFields().getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof perfetto.protos.TraceStatsOuterClass.TraceStats.BufferStats)) {
          return super.equals(obj);
        }
        perfetto.protos.TraceStatsOuterClass.TraceStats.BufferStats other = (perfetto.protos.TraceStatsOuterClass.TraceStats.BufferStats) obj;

        if (hasBufferSize() != other.hasBufferSize()) return false;
        if (hasBufferSize()) {
          if (getBufferSize()
              != other.getBufferSize()) return false;
        }
        if (hasBytesWritten() != other.hasBytesWritten()) return false;
        if (hasBytesWritten()) {
          if (getBytesWritten()
              != other.getBytesWritten()) return false;
        }
        if (hasBytesOverwritten() != other.hasBytesOverwritten()) return false;
        if (hasBytesOverwritten()) {
          if (getBytesOverwritten()
              != other.getBytesOverwritten()) return false;
        }
        if (hasBytesRead() != other.hasBytesRead()) return false;
        if (hasBytesRead()) {
          if (getBytesRead()
              != other.getBytesRead()) return false;
        }
        if (hasPaddingBytesWritten() != other.hasPaddingBytesWritten()) return false;
        if (hasPaddingBytesWritten()) {
          if (getPaddingBytesWritten()
              != other.getPaddingBytesWritten()) return false;
        }
        if (hasPaddingBytesCleared() != other.hasPaddingBytesCleared()) return false;
        if (hasPaddingBytesCleared()) {
          if (getPaddingBytesCleared()
              != other.getPaddingBytesCleared()) return false;
        }
        if (hasChunksWritten() != other.hasChunksWritten()) return false;
        if (hasChunksWritten()) {
          if (getChunksWritten()
              != other.getChunksWritten()) return false;
        }
        if (hasChunksRewritten() != other.hasChunksRewritten()) return false;
        if (hasChunksRewritten()) {
          if (getChunksRewritten()
              != other.getChunksRewritten()) return false;
        }
        if (hasChunksOverwritten() != other.hasChunksOverwritten()) return false;
        if (hasChunksOverwritten()) {
          if (getChunksOverwritten()
              != other.getChunksOverwritten()) return false;
        }
        if (hasChunksDiscarded() != other.hasChunksDiscarded()) return false;
        if (hasChunksDiscarded()) {
          if (getChunksDiscarded()
              != other.getChunksDiscarded()) return false;
        }
        if (hasChunksRead() != other.hasChunksRead()) return false;
        if (hasChunksRead()) {
          if (getChunksRead()
              != other.getChunksRead()) return false;
        }
        if (hasChunksCommittedOutOfOrder() != other.hasChunksCommittedOutOfOrder()) return false;
        if (hasChunksCommittedOutOfOrder()) {
          if (getChunksCommittedOutOfOrder()
              != other.getChunksCommittedOutOfOrder()) return false;
        }
        if (hasWriteWrapCount() != other.hasWriteWrapCount()) return false;
        if (hasWriteWrapCount()) {
          if (getWriteWrapCount()
              != other.getWriteWrapCount()) return false;
        }
        if (hasPatchesSucceeded() != other.hasPatchesSucceeded()) return false;
        if (hasPatchesSucceeded()) {
          if (getPatchesSucceeded()
              != other.getPatchesSucceeded()) return false;
        }
        if (hasPatchesFailed() != other.hasPatchesFailed()) return false;
        if (hasPatchesFailed()) {
          if (getPatchesFailed()
              != other.getPatchesFailed()) return false;
        }
        if (hasReadaheadsSucceeded() != other.hasReadaheadsSucceeded()) return false;
        if (hasReadaheadsSucceeded()) {
          if (getReadaheadsSucceeded()
              != other.getReadaheadsSucceeded()) return false;
        }
        if (hasReadaheadsFailed() != other.hasReadaheadsFailed()) return false;
        if (hasReadaheadsFailed()) {
          if (getReadaheadsFailed()
              != other.getReadaheadsFailed()) return false;
        }
        if (hasAbiViolations() != other.hasAbiViolations()) return false;
        if (hasAbiViolations()) {
          if (getAbiViolations()
              != other.getAbiViolations()) return false;
        }
        if (hasTraceWriterPacketLoss() != other.hasTraceWriterPacketLoss()) return false;
        if (hasTraceWriterPacketLoss()) {
          if (getTraceWriterPacketLoss()
              != other.getTraceWriterPacketLoss()) return false;
        }
        if (!getUnknownFields().equals(other.getUnknownFields())) return false;
        return true;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        if (hasBufferSize()) {
          hash = (37 * hash) + BUFFER_SIZE_FIELD_NUMBER;
          hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
              getBufferSize());
        }
        if (hasBytesWritten()) {
          hash = (37 * hash) + BYTES_WRITTEN_FIELD_NUMBER;
          hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
              getBytesWritten());
        }
        if (hasBytesOverwritten()) {
          hash = (37 * hash) + BYTES_OVERWRITTEN_FIELD_NUMBER;
          hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
              getBytesOverwritten());
        }
        if (hasBytesRead()) {
          hash = (37 * hash) + BYTES_READ_FIELD_NUMBER;
          hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
              getBytesRead());
        }
        if (hasPaddingBytesWritten()) {
          hash = (37 * hash) + PADDING_BYTES_WRITTEN_FIELD_NUMBER;
          hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
              getPaddingBytesWritten());
        }
        if (hasPaddingBytesCleared()) {
          hash = (37 * hash) + PADDING_BYTES_CLEARED_FIELD_NUMBER;
          hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
              getPaddingBytesCleared());
        }
        if (hasChunksWritten()) {
          hash = (37 * hash) + CHUNKS_WRITTEN_FIELD_NUMBER;
          hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
              getChunksWritten());
        }
        if (hasChunksRewritten()) {
          hash = (37 * hash) + CHUNKS_REWRITTEN_FIELD_NUMBER;
          hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
              getChunksRewritten());
        }
        if (hasChunksOverwritten()) {
          hash = (37 * hash) + CHUNKS_OVERWRITTEN_FIELD_NUMBER;
          hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
              getChunksOverwritten());
        }
        if (hasChunksDiscarded()) {
          hash = (37 * hash) + CHUNKS_DISCARDED_FIELD_NUMBER;
          hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
              getChunksDiscarded());
        }
        if (hasChunksRead()) {
          hash = (37 * hash) + CHUNKS_READ_FIELD_NUMBER;
          hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
              getChunksRead());
        }
        if (hasChunksCommittedOutOfOrder()) {
          hash = (37 * hash) + CHUNKS_COMMITTED_OUT_OF_ORDER_FIELD_NUMBER;
          hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
              getChunksCommittedOutOfOrder());
        }
        if (hasWriteWrapCount()) {
          hash = (37 * hash) + WRITE_WRAP_COUNT_FIELD_NUMBER;
          hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
              getWriteWrapCount());
        }
        if (hasPatchesSucceeded()) {
          hash = (37 * hash) + PATCHES_SUCCEEDED_FIELD_NUMBER;
          hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
              getPatchesSucceeded());
        }
        if (hasPatchesFailed()) {
          hash = (37 * hash) + PATCHES_FAILED_FIELD_NUMBER;
          hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
              getPatchesFailed());
        }
        if (hasReadaheadsSucceeded()) {
          hash = (37 * hash) + READAHEADS_SUCCEEDED_FIELD_NUMBER;
          hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
              getReadaheadsSucceeded());
        }
        if (hasReadaheadsFailed()) {
          hash = (37 * hash) + READAHEADS_FAILED_FIELD_NUMBER;
          hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
              getReadaheadsFailed());
        }
        if (hasAbiViolations()) {
          hash = (37 * hash) + ABI_VIOLATIONS_FIELD_NUMBER;
          hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
              getAbiViolations());
        }
        if (hasTraceWriterPacketLoss()) {
          hash = (37 * hash) + TRACE_WRITER_PACKET_LOSS_FIELD_NUMBER;
          hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
              getTraceWriterPacketLoss());
        }
        hash = (29 * hash) + getUnknownFields().hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static perfetto.protos.TraceStatsOuterClass.TraceStats.BufferStats parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static perfetto.protos.TraceStatsOuterClass.TraceStats.BufferStats parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static perfetto.protos.TraceStatsOuterClass.TraceStats.BufferStats parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static perfetto.protos.TraceStatsOuterClass.TraceStats.BufferStats parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static perfetto.protos.TraceStatsOuterClass.TraceStats.BufferStats parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static perfetto.protos.TraceStatsOuterClass.TraceStats.BufferStats parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static perfetto.protos.TraceStatsOuterClass.TraceStats.BufferStats parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static perfetto.protos.TraceStatsOuterClass.TraceStats.BufferStats parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }
      public static perfetto.protos.TraceStatsOuterClass.TraceStats.BufferStats parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input);
      }
      public static perfetto.protos.TraceStatsOuterClass.TraceStats.BufferStats parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static perfetto.protos.TraceStatsOuterClass.TraceStats.BufferStats parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static perfetto.protos.TraceStatsOuterClass.TraceStats.BufferStats parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(perfetto.protos.TraceStatsOuterClass.TraceStats.BufferStats prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * <pre>
       * From TraceBuffer::Stats.
       * Next id: 20.
       * </pre>
       *
       * Protobuf type {@code perfetto.protos.TraceStats.BufferStats}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:perfetto.protos.TraceStats.BufferStats)
          perfetto.protos.TraceStatsOuterClass.TraceStats.BufferStatsOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return perfetto.protos.TraceStatsOuterClass.internal_static_perfetto_protos_TraceStats_BufferStats_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return perfetto.protos.TraceStatsOuterClass.internal_static_perfetto_protos_TraceStats_BufferStats_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  perfetto.protos.TraceStatsOuterClass.TraceStats.BufferStats.class, perfetto.protos.TraceStatsOuterClass.TraceStats.BufferStats.Builder.class);
        }

        // Construct using perfetto.protos.TraceStatsOuterClass.TraceStats.BufferStats.newBuilder()
        private Builder() {

        }

        private Builder(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
          super(parent);

        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          bitField0_ = 0;
          bufferSize_ = 0L;
          bytesWritten_ = 0L;
          bytesOverwritten_ = 0L;
          bytesRead_ = 0L;
          paddingBytesWritten_ = 0L;
          paddingBytesCleared_ = 0L;
          chunksWritten_ = 0L;
          chunksRewritten_ = 0L;
          chunksOverwritten_ = 0L;
          chunksDiscarded_ = 0L;
          chunksRead_ = 0L;
          chunksCommittedOutOfOrder_ = 0L;
          writeWrapCount_ = 0L;
          patchesSucceeded_ = 0L;
          patchesFailed_ = 0L;
          readaheadsSucceeded_ = 0L;
          readaheadsFailed_ = 0L;
          abiViolations_ = 0L;
          traceWriterPacketLoss_ = 0L;
          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return perfetto.protos.TraceStatsOuterClass.internal_static_perfetto_protos_TraceStats_BufferStats_descriptor;
        }

        @java.lang.Override
        public perfetto.protos.TraceStatsOuterClass.TraceStats.BufferStats getDefaultInstanceForType() {
          return perfetto.protos.TraceStatsOuterClass.TraceStats.BufferStats.getDefaultInstance();
        }

        @java.lang.Override
        public perfetto.protos.TraceStatsOuterClass.TraceStats.BufferStats build() {
          perfetto.protos.TraceStatsOuterClass.TraceStats.BufferStats result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public perfetto.protos.TraceStatsOuterClass.TraceStats.BufferStats buildPartial() {
          perfetto.protos.TraceStatsOuterClass.TraceStats.BufferStats result = new perfetto.protos.TraceStatsOuterClass.TraceStats.BufferStats(this);
          if (bitField0_ != 0) { buildPartial0(result); }
          onBuilt();
          return result;
        }

        private void buildPartial0(perfetto.protos.TraceStatsOuterClass.TraceStats.BufferStats result) {
          int from_bitField0_ = bitField0_;
          int to_bitField0_ = 0;
          if (((from_bitField0_ & 0x00000001) != 0)) {
            result.bufferSize_ = bufferSize_;
            to_bitField0_ |= 0x00000001;
          }
          if (((from_bitField0_ & 0x00000002) != 0)) {
            result.bytesWritten_ = bytesWritten_;
            to_bitField0_ |= 0x00000002;
          }
          if (((from_bitField0_ & 0x00000004) != 0)) {
            result.bytesOverwritten_ = bytesOverwritten_;
            to_bitField0_ |= 0x00000004;
          }
          if (((from_bitField0_ & 0x00000008) != 0)) {
            result.bytesRead_ = bytesRead_;
            to_bitField0_ |= 0x00000008;
          }
          if (((from_bitField0_ & 0x00000010) != 0)) {
            result.paddingBytesWritten_ = paddingBytesWritten_;
            to_bitField0_ |= 0x00000010;
          }
          if (((from_bitField0_ & 0x00000020) != 0)) {
            result.paddingBytesCleared_ = paddingBytesCleared_;
            to_bitField0_ |= 0x00000020;
          }
          if (((from_bitField0_ & 0x00000040) != 0)) {
            result.chunksWritten_ = chunksWritten_;
            to_bitField0_ |= 0x00000040;
          }
          if (((from_bitField0_ & 0x00000080) != 0)) {
            result.chunksRewritten_ = chunksRewritten_;
            to_bitField0_ |= 0x00000080;
          }
          if (((from_bitField0_ & 0x00000100) != 0)) {
            result.chunksOverwritten_ = chunksOverwritten_;
            to_bitField0_ |= 0x00000100;
          }
          if (((from_bitField0_ & 0x00000200) != 0)) {
            result.chunksDiscarded_ = chunksDiscarded_;
            to_bitField0_ |= 0x00000200;
          }
          if (((from_bitField0_ & 0x00000400) != 0)) {
            result.chunksRead_ = chunksRead_;
            to_bitField0_ |= 0x00000400;
          }
          if (((from_bitField0_ & 0x00000800) != 0)) {
            result.chunksCommittedOutOfOrder_ = chunksCommittedOutOfOrder_;
            to_bitField0_ |= 0x00000800;
          }
          if (((from_bitField0_ & 0x00001000) != 0)) {
            result.writeWrapCount_ = writeWrapCount_;
            to_bitField0_ |= 0x00001000;
          }
          if (((from_bitField0_ & 0x00002000) != 0)) {
            result.patchesSucceeded_ = patchesSucceeded_;
            to_bitField0_ |= 0x00002000;
          }
          if (((from_bitField0_ & 0x00004000) != 0)) {
            result.patchesFailed_ = patchesFailed_;
            to_bitField0_ |= 0x00004000;
          }
          if (((from_bitField0_ & 0x00008000) != 0)) {
            result.readaheadsSucceeded_ = readaheadsSucceeded_;
            to_bitField0_ |= 0x00008000;
          }
          if (((from_bitField0_ & 0x00010000) != 0)) {
            result.readaheadsFailed_ = readaheadsFailed_;
            to_bitField0_ |= 0x00010000;
          }
          if (((from_bitField0_ & 0x00020000) != 0)) {
            result.abiViolations_ = abiViolations_;
            to_bitField0_ |= 0x00020000;
          }
          if (((from_bitField0_ & 0x00040000) != 0)) {
            result.traceWriterPacketLoss_ = traceWriterPacketLoss_;
            to_bitField0_ |= 0x00040000;
          }
          result.bitField0_ |= to_bitField0_;
        }

        @java.lang.Override
        public Builder clone() {
          return super.clone();
        }
        @java.lang.Override
        public Builder setField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.setField(field, value);
        }
        @java.lang.Override
        public Builder clearField(
            com.google.protobuf.Descriptors.FieldDescriptor field) {
          return super.clearField(field);
        }
        @java.lang.Override
        public Builder clearOneof(
            com.google.protobuf.Descriptors.OneofDescriptor oneof) {
          return super.clearOneof(oneof);
        }
        @java.lang.Override
        public Builder setRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            int index, java.lang.Object value) {
          return super.setRepeatedField(field, index, value);
        }
        @java.lang.Override
        public Builder addRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.addRepeatedField(field, value);
        }
        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof perfetto.protos.TraceStatsOuterClass.TraceStats.BufferStats) {
            return mergeFrom((perfetto.protos.TraceStatsOuterClass.TraceStats.BufferStats)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(perfetto.protos.TraceStatsOuterClass.TraceStats.BufferStats other) {
          if (other == perfetto.protos.TraceStatsOuterClass.TraceStats.BufferStats.getDefaultInstance()) return this;
          if (other.hasBufferSize()) {
            setBufferSize(other.getBufferSize());
          }
          if (other.hasBytesWritten()) {
            setBytesWritten(other.getBytesWritten());
          }
          if (other.hasBytesOverwritten()) {
            setBytesOverwritten(other.getBytesOverwritten());
          }
          if (other.hasBytesRead()) {
            setBytesRead(other.getBytesRead());
          }
          if (other.hasPaddingBytesWritten()) {
            setPaddingBytesWritten(other.getPaddingBytesWritten());
          }
          if (other.hasPaddingBytesCleared()) {
            setPaddingBytesCleared(other.getPaddingBytesCleared());
          }
          if (other.hasChunksWritten()) {
            setChunksWritten(other.getChunksWritten());
          }
          if (other.hasChunksRewritten()) {
            setChunksRewritten(other.getChunksRewritten());
          }
          if (other.hasChunksOverwritten()) {
            setChunksOverwritten(other.getChunksOverwritten());
          }
          if (other.hasChunksDiscarded()) {
            setChunksDiscarded(other.getChunksDiscarded());
          }
          if (other.hasChunksRead()) {
            setChunksRead(other.getChunksRead());
          }
          if (other.hasChunksCommittedOutOfOrder()) {
            setChunksCommittedOutOfOrder(other.getChunksCommittedOutOfOrder());
          }
          if (other.hasWriteWrapCount()) {
            setWriteWrapCount(other.getWriteWrapCount());
          }
          if (other.hasPatchesSucceeded()) {
            setPatchesSucceeded(other.getPatchesSucceeded());
          }
          if (other.hasPatchesFailed()) {
            setPatchesFailed(other.getPatchesFailed());
          }
          if (other.hasReadaheadsSucceeded()) {
            setReadaheadsSucceeded(other.getReadaheadsSucceeded());
          }
          if (other.hasReadaheadsFailed()) {
            setReadaheadsFailed(other.getReadaheadsFailed());
          }
          if (other.hasAbiViolations()) {
            setAbiViolations(other.getAbiViolations());
          }
          if (other.hasTraceWriterPacketLoss()) {
            setTraceWriterPacketLoss(other.getTraceWriterPacketLoss());
          }
          this.mergeUnknownFields(other.getUnknownFields());
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          if (extensionRegistry == null) {
            throw new java.lang.NullPointerException();
          }
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                case 8: {
                  bytesWritten_ = input.readUInt64();
                  bitField0_ |= 0x00000002;
                  break;
                } // case 8
                case 16: {
                  chunksWritten_ = input.readUInt64();
                  bitField0_ |= 0x00000040;
                  break;
                } // case 16
                case 24: {
                  chunksOverwritten_ = input.readUInt64();
                  bitField0_ |= 0x00000100;
                  break;
                } // case 24
                case 32: {
                  writeWrapCount_ = input.readUInt64();
                  bitField0_ |= 0x00001000;
                  break;
                } // case 32
                case 40: {
                  patchesSucceeded_ = input.readUInt64();
                  bitField0_ |= 0x00002000;
                  break;
                } // case 40
                case 48: {
                  patchesFailed_ = input.readUInt64();
                  bitField0_ |= 0x00004000;
                  break;
                } // case 48
                case 56: {
                  readaheadsSucceeded_ = input.readUInt64();
                  bitField0_ |= 0x00008000;
                  break;
                } // case 56
                case 64: {
                  readaheadsFailed_ = input.readUInt64();
                  bitField0_ |= 0x00010000;
                  break;
                } // case 64
                case 72: {
                  abiViolations_ = input.readUInt64();
                  bitField0_ |= 0x00020000;
                  break;
                } // case 72
                case 80: {
                  chunksRewritten_ = input.readUInt64();
                  bitField0_ |= 0x00000080;
                  break;
                } // case 80
                case 88: {
                  chunksCommittedOutOfOrder_ = input.readUInt64();
                  bitField0_ |= 0x00000800;
                  break;
                } // case 88
                case 96: {
                  bufferSize_ = input.readUInt64();
                  bitField0_ |= 0x00000001;
                  break;
                } // case 96
                case 104: {
                  bytesOverwritten_ = input.readUInt64();
                  bitField0_ |= 0x00000004;
                  break;
                } // case 104
                case 112: {
                  bytesRead_ = input.readUInt64();
                  bitField0_ |= 0x00000008;
                  break;
                } // case 112
                case 120: {
                  paddingBytesWritten_ = input.readUInt64();
                  bitField0_ |= 0x00000010;
                  break;
                } // case 120
                case 128: {
                  paddingBytesCleared_ = input.readUInt64();
                  bitField0_ |= 0x00000020;
                  break;
                } // case 128
                case 136: {
                  chunksRead_ = input.readUInt64();
                  bitField0_ |= 0x00000400;
                  break;
                } // case 136
                case 144: {
                  chunksDiscarded_ = input.readUInt64();
                  bitField0_ |= 0x00000200;
                  break;
                } // case 144
                case 152: {
                  traceWriterPacketLoss_ = input.readUInt64();
                  bitField0_ |= 0x00040000;
                  break;
                } // case 152
                default: {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
              } // switch (tag)
            } // while (!done)
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.unwrapIOException();
          } finally {
            onChanged();
          } // finally
          return this;
        }
        private int bitField0_;

        private long bufferSize_ ;
        /**
         * <pre>
         * Size of the circular buffer in bytes.
         * </pre>
         *
         * <code>optional uint64 buffer_size = 12;</code>
         * @return Whether the bufferSize field is set.
         */
        @java.lang.Override
        public boolean hasBufferSize() {
          return ((bitField0_ & 0x00000001) != 0);
        }
        /**
         * <pre>
         * Size of the circular buffer in bytes.
         * </pre>
         *
         * <code>optional uint64 buffer_size = 12;</code>
         * @return The bufferSize.
         */
        @java.lang.Override
        public long getBufferSize() {
          return bufferSize_;
        }
        /**
         * <pre>
         * Size of the circular buffer in bytes.
         * </pre>
         *
         * <code>optional uint64 buffer_size = 12;</code>
         * @param value The bufferSize to set.
         * @return This builder for chaining.
         */
        public Builder setBufferSize(long value) {
          
          bufferSize_ = value;
          bitField0_ |= 0x00000001;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Size of the circular buffer in bytes.
         * </pre>
         *
         * <code>optional uint64 buffer_size = 12;</code>
         * @return This builder for chaining.
         */
        public Builder clearBufferSize() {
          bitField0_ = (bitField0_ & ~0x00000001);
          bufferSize_ = 0L;
          onChanged();
          return this;
        }

        private long bytesWritten_ ;
        /**
         * <pre>
         * Num. bytes written into the circular buffer, including chunk headers.
         * </pre>
         *
         * <code>optional uint64 bytes_written = 1;</code>
         * @return Whether the bytesWritten field is set.
         */
        @java.lang.Override
        public boolean hasBytesWritten() {
          return ((bitField0_ & 0x00000002) != 0);
        }
        /**
         * <pre>
         * Num. bytes written into the circular buffer, including chunk headers.
         * </pre>
         *
         * <code>optional uint64 bytes_written = 1;</code>
         * @return The bytesWritten.
         */
        @java.lang.Override
        public long getBytesWritten() {
          return bytesWritten_;
        }
        /**
         * <pre>
         * Num. bytes written into the circular buffer, including chunk headers.
         * </pre>
         *
         * <code>optional uint64 bytes_written = 1;</code>
         * @param value The bytesWritten to set.
         * @return This builder for chaining.
         */
        public Builder setBytesWritten(long value) {
          
          bytesWritten_ = value;
          bitField0_ |= 0x00000002;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Num. bytes written into the circular buffer, including chunk headers.
         * </pre>
         *
         * <code>optional uint64 bytes_written = 1;</code>
         * @return This builder for chaining.
         */
        public Builder clearBytesWritten() {
          bitField0_ = (bitField0_ & ~0x00000002);
          bytesWritten_ = 0L;
          onChanged();
          return this;
        }

        private long bytesOverwritten_ ;
        /**
         * <pre>
         * Num. bytes overwritten before they have been read (i.e. loss of data).
         * </pre>
         *
         * <code>optional uint64 bytes_overwritten = 13;</code>
         * @return Whether the bytesOverwritten field is set.
         */
        @java.lang.Override
        public boolean hasBytesOverwritten() {
          return ((bitField0_ & 0x00000004) != 0);
        }
        /**
         * <pre>
         * Num. bytes overwritten before they have been read (i.e. loss of data).
         * </pre>
         *
         * <code>optional uint64 bytes_overwritten = 13;</code>
         * @return The bytesOverwritten.
         */
        @java.lang.Override
        public long getBytesOverwritten() {
          return bytesOverwritten_;
        }
        /**
         * <pre>
         * Num. bytes overwritten before they have been read (i.e. loss of data).
         * </pre>
         *
         * <code>optional uint64 bytes_overwritten = 13;</code>
         * @param value The bytesOverwritten to set.
         * @return This builder for chaining.
         */
        public Builder setBytesOverwritten(long value) {
          
          bytesOverwritten_ = value;
          bitField0_ |= 0x00000004;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Num. bytes overwritten before they have been read (i.e. loss of data).
         * </pre>
         *
         * <code>optional uint64 bytes_overwritten = 13;</code>
         * @return This builder for chaining.
         */
        public Builder clearBytesOverwritten() {
          bitField0_ = (bitField0_ & ~0x00000004);
          bytesOverwritten_ = 0L;
          onChanged();
          return this;
        }

        private long bytesRead_ ;
        /**
         * <pre>
         * Total size of chunks that were fully read from the circular buffer by the
         * consumer. This may not be equal to |bytes_written| either in the middle
         * of tracing, or if |chunks_overwritten| is non-zero. Note that this is the
         * size of the chunks read from the buffer, including chunk headers, which
         * will be different from the total size of packets returned to the
         * consumer.
         * The current utilization of the trace buffer (mid-tracing) can be obtained
         * by subtracting |bytes_read| and |bytes_overwritten| from |bytes_written|,
         * adding the difference of |padding_bytes_written| and
         * |padding_bytes_cleared|, and comparing this sum to the |buffer_size|.
         * Note that this represents the total size of buffered data in the buffer,
         * yet this data may be spread non-contiguously through the buffer and may
         * be overridden before the utilization reaches 100%.
         * </pre>
         *
         * <code>optional uint64 bytes_read = 14;</code>
         * @return Whether the bytesRead field is set.
         */
        @java.lang.Override
        public boolean hasBytesRead() {
          return ((bitField0_ & 0x00000008) != 0);
        }
        /**
         * <pre>
         * Total size of chunks that were fully read from the circular buffer by the
         * consumer. This may not be equal to |bytes_written| either in the middle
         * of tracing, or if |chunks_overwritten| is non-zero. Note that this is the
         * size of the chunks read from the buffer, including chunk headers, which
         * will be different from the total size of packets returned to the
         * consumer.
         * The current utilization of the trace buffer (mid-tracing) can be obtained
         * by subtracting |bytes_read| and |bytes_overwritten| from |bytes_written|,
         * adding the difference of |padding_bytes_written| and
         * |padding_bytes_cleared|, and comparing this sum to the |buffer_size|.
         * Note that this represents the total size of buffered data in the buffer,
         * yet this data may be spread non-contiguously through the buffer and may
         * be overridden before the utilization reaches 100%.
         * </pre>
         *
         * <code>optional uint64 bytes_read = 14;</code>
         * @return The bytesRead.
         */
        @java.lang.Override
        public long getBytesRead() {
          return bytesRead_;
        }
        /**
         * <pre>
         * Total size of chunks that were fully read from the circular buffer by the
         * consumer. This may not be equal to |bytes_written| either in the middle
         * of tracing, or if |chunks_overwritten| is non-zero. Note that this is the
         * size of the chunks read from the buffer, including chunk headers, which
         * will be different from the total size of packets returned to the
         * consumer.
         * The current utilization of the trace buffer (mid-tracing) can be obtained
         * by subtracting |bytes_read| and |bytes_overwritten| from |bytes_written|,
         * adding the difference of |padding_bytes_written| and
         * |padding_bytes_cleared|, and comparing this sum to the |buffer_size|.
         * Note that this represents the total size of buffered data in the buffer,
         * yet this data may be spread non-contiguously through the buffer and may
         * be overridden before the utilization reaches 100%.
         * </pre>
         *
         * <code>optional uint64 bytes_read = 14;</code>
         * @param value The bytesRead to set.
         * @return This builder for chaining.
         */
        public Builder setBytesRead(long value) {
          
          bytesRead_ = value;
          bitField0_ |= 0x00000008;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Total size of chunks that were fully read from the circular buffer by the
         * consumer. This may not be equal to |bytes_written| either in the middle
         * of tracing, or if |chunks_overwritten| is non-zero. Note that this is the
         * size of the chunks read from the buffer, including chunk headers, which
         * will be different from the total size of packets returned to the
         * consumer.
         * The current utilization of the trace buffer (mid-tracing) can be obtained
         * by subtracting |bytes_read| and |bytes_overwritten| from |bytes_written|,
         * adding the difference of |padding_bytes_written| and
         * |padding_bytes_cleared|, and comparing this sum to the |buffer_size|.
         * Note that this represents the total size of buffered data in the buffer,
         * yet this data may be spread non-contiguously through the buffer and may
         * be overridden before the utilization reaches 100%.
         * </pre>
         *
         * <code>optional uint64 bytes_read = 14;</code>
         * @return This builder for chaining.
         */
        public Builder clearBytesRead() {
          bitField0_ = (bitField0_ & ~0x00000008);
          bytesRead_ = 0L;
          onChanged();
          return this;
        }

        private long paddingBytesWritten_ ;
        /**
         * <pre>
         * Num. bytes that were allocated as padding between chunks in the circular
         * buffer.
         * </pre>
         *
         * <code>optional uint64 padding_bytes_written = 15;</code>
         * @return Whether the paddingBytesWritten field is set.
         */
        @java.lang.Override
        public boolean hasPaddingBytesWritten() {
          return ((bitField0_ & 0x00000010) != 0);
        }
        /**
         * <pre>
         * Num. bytes that were allocated as padding between chunks in the circular
         * buffer.
         * </pre>
         *
         * <code>optional uint64 padding_bytes_written = 15;</code>
         * @return The paddingBytesWritten.
         */
        @java.lang.Override
        public long getPaddingBytesWritten() {
          return paddingBytesWritten_;
        }
        /**
         * <pre>
         * Num. bytes that were allocated as padding between chunks in the circular
         * buffer.
         * </pre>
         *
         * <code>optional uint64 padding_bytes_written = 15;</code>
         * @param value The paddingBytesWritten to set.
         * @return This builder for chaining.
         */
        public Builder setPaddingBytesWritten(long value) {
          
          paddingBytesWritten_ = value;
          bitField0_ |= 0x00000010;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Num. bytes that were allocated as padding between chunks in the circular
         * buffer.
         * </pre>
         *
         * <code>optional uint64 padding_bytes_written = 15;</code>
         * @return This builder for chaining.
         */
        public Builder clearPaddingBytesWritten() {
          bitField0_ = (bitField0_ & ~0x00000010);
          paddingBytesWritten_ = 0L;
          onChanged();
          return this;
        }

        private long paddingBytesCleared_ ;
        /**
         * <pre>
         * Num. of padding bytes that were removed from the circular buffer when
         * they were overwritten.
         * The difference between |padding_bytes_written| and
         * |padding_bytes_cleared| denotes the total size of padding currently
         * present in the buffer.
         * </pre>
         *
         * <code>optional uint64 padding_bytes_cleared = 16;</code>
         * @return Whether the paddingBytesCleared field is set.
         */
        @java.lang.Override
        public boolean hasPaddingBytesCleared() {
          return ((bitField0_ & 0x00000020) != 0);
        }
        /**
         * <pre>
         * Num. of padding bytes that were removed from the circular buffer when
         * they were overwritten.
         * The difference between |padding_bytes_written| and
         * |padding_bytes_cleared| denotes the total size of padding currently
         * present in the buffer.
         * </pre>
         *
         * <code>optional uint64 padding_bytes_cleared = 16;</code>
         * @return The paddingBytesCleared.
         */
        @java.lang.Override
        public long getPaddingBytesCleared() {
          return paddingBytesCleared_;
        }
        /**
         * <pre>
         * Num. of padding bytes that were removed from the circular buffer when
         * they were overwritten.
         * The difference between |padding_bytes_written| and
         * |padding_bytes_cleared| denotes the total size of padding currently
         * present in the buffer.
         * </pre>
         *
         * <code>optional uint64 padding_bytes_cleared = 16;</code>
         * @param value The paddingBytesCleared to set.
         * @return This builder for chaining.
         */
        public Builder setPaddingBytesCleared(long value) {
          
          paddingBytesCleared_ = value;
          bitField0_ |= 0x00000020;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Num. of padding bytes that were removed from the circular buffer when
         * they were overwritten.
         * The difference between |padding_bytes_written| and
         * |padding_bytes_cleared| denotes the total size of padding currently
         * present in the buffer.
         * </pre>
         *
         * <code>optional uint64 padding_bytes_cleared = 16;</code>
         * @return This builder for chaining.
         */
        public Builder clearPaddingBytesCleared() {
          bitField0_ = (bitField0_ & ~0x00000020);
          paddingBytesCleared_ = 0L;
          onChanged();
          return this;
        }

        private long chunksWritten_ ;
        /**
         * <pre>
         * Num. chunks (!= packets) written into the buffer.
         * </pre>
         *
         * <code>optional uint64 chunks_written = 2;</code>
         * @return Whether the chunksWritten field is set.
         */
        @java.lang.Override
        public boolean hasChunksWritten() {
          return ((bitField0_ & 0x00000040) != 0);
        }
        /**
         * <pre>
         * Num. chunks (!= packets) written into the buffer.
         * </pre>
         *
         * <code>optional uint64 chunks_written = 2;</code>
         * @return The chunksWritten.
         */
        @java.lang.Override
        public long getChunksWritten() {
          return chunksWritten_;
        }
        /**
         * <pre>
         * Num. chunks (!= packets) written into the buffer.
         * </pre>
         *
         * <code>optional uint64 chunks_written = 2;</code>
         * @param value The chunksWritten to set.
         * @return This builder for chaining.
         */
        public Builder setChunksWritten(long value) {
          
          chunksWritten_ = value;
          bitField0_ |= 0x00000040;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Num. chunks (!= packets) written into the buffer.
         * </pre>
         *
         * <code>optional uint64 chunks_written = 2;</code>
         * @return This builder for chaining.
         */
        public Builder clearChunksWritten() {
          bitField0_ = (bitField0_ & ~0x00000040);
          chunksWritten_ = 0L;
          onChanged();
          return this;
        }

        private long chunksRewritten_ ;
        /**
         * <pre>
         * Num. chunks (!= packets) rewritten into the buffer. This means we rewrote
         * the same chunk with additional packets appended to the end.
         * </pre>
         *
         * <code>optional uint64 chunks_rewritten = 10;</code>
         * @return Whether the chunksRewritten field is set.
         */
        @java.lang.Override
        public boolean hasChunksRewritten() {
          return ((bitField0_ & 0x00000080) != 0);
        }
        /**
         * <pre>
         * Num. chunks (!= packets) rewritten into the buffer. This means we rewrote
         * the same chunk with additional packets appended to the end.
         * </pre>
         *
         * <code>optional uint64 chunks_rewritten = 10;</code>
         * @return The chunksRewritten.
         */
        @java.lang.Override
        public long getChunksRewritten() {
          return chunksRewritten_;
        }
        /**
         * <pre>
         * Num. chunks (!= packets) rewritten into the buffer. This means we rewrote
         * the same chunk with additional packets appended to the end.
         * </pre>
         *
         * <code>optional uint64 chunks_rewritten = 10;</code>
         * @param value The chunksRewritten to set.
         * @return This builder for chaining.
         */
        public Builder setChunksRewritten(long value) {
          
          chunksRewritten_ = value;
          bitField0_ |= 0x00000080;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Num. chunks (!= packets) rewritten into the buffer. This means we rewrote
         * the same chunk with additional packets appended to the end.
         * </pre>
         *
         * <code>optional uint64 chunks_rewritten = 10;</code>
         * @return This builder for chaining.
         */
        public Builder clearChunksRewritten() {
          bitField0_ = (bitField0_ & ~0x00000080);
          chunksRewritten_ = 0L;
          onChanged();
          return this;
        }

        private long chunksOverwritten_ ;
        /**
         * <pre>
         * Num. chunks overwritten before they have been read (i.e. loss of data).
         * </pre>
         *
         * <code>optional uint64 chunks_overwritten = 3;</code>
         * @return Whether the chunksOverwritten field is set.
         */
        @java.lang.Override
        public boolean hasChunksOverwritten() {
          return ((bitField0_ & 0x00000100) != 0);
        }
        /**
         * <pre>
         * Num. chunks overwritten before they have been read (i.e. loss of data).
         * </pre>
         *
         * <code>optional uint64 chunks_overwritten = 3;</code>
         * @return The chunksOverwritten.
         */
        @java.lang.Override
        public long getChunksOverwritten() {
          return chunksOverwritten_;
        }
        /**
         * <pre>
         * Num. chunks overwritten before they have been read (i.e. loss of data).
         * </pre>
         *
         * <code>optional uint64 chunks_overwritten = 3;</code>
         * @param value The chunksOverwritten to set.
         * @return This builder for chaining.
         */
        public Builder setChunksOverwritten(long value) {
          
          chunksOverwritten_ = value;
          bitField0_ |= 0x00000100;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Num. chunks overwritten before they have been read (i.e. loss of data).
         * </pre>
         *
         * <code>optional uint64 chunks_overwritten = 3;</code>
         * @return This builder for chaining.
         */
        public Builder clearChunksOverwritten() {
          bitField0_ = (bitField0_ & ~0x00000100);
          chunksOverwritten_ = 0L;
          onChanged();
          return this;
        }

        private long chunksDiscarded_ ;
        /**
         * <pre>
         * Num. chunks discarded (i.e. loss of data). Can be &gt; 0 only when a buffer
         * is configured with FillPolicy == DISCARD.
         * </pre>
         *
         * <code>optional uint64 chunks_discarded = 18;</code>
         * @return Whether the chunksDiscarded field is set.
         */
        @java.lang.Override
        public boolean hasChunksDiscarded() {
          return ((bitField0_ & 0x00000200) != 0);
        }
        /**
         * <pre>
         * Num. chunks discarded (i.e. loss of data). Can be &gt; 0 only when a buffer
         * is configured with FillPolicy == DISCARD.
         * </pre>
         *
         * <code>optional uint64 chunks_discarded = 18;</code>
         * @return The chunksDiscarded.
         */
        @java.lang.Override
        public long getChunksDiscarded() {
          return chunksDiscarded_;
        }
        /**
         * <pre>
         * Num. chunks discarded (i.e. loss of data). Can be &gt; 0 only when a buffer
         * is configured with FillPolicy == DISCARD.
         * </pre>
         *
         * <code>optional uint64 chunks_discarded = 18;</code>
         * @param value The chunksDiscarded to set.
         * @return This builder for chaining.
         */
        public Builder setChunksDiscarded(long value) {
          
          chunksDiscarded_ = value;
          bitField0_ |= 0x00000200;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Num. chunks discarded (i.e. loss of data). Can be &gt; 0 only when a buffer
         * is configured with FillPolicy == DISCARD.
         * </pre>
         *
         * <code>optional uint64 chunks_discarded = 18;</code>
         * @return This builder for chaining.
         */
        public Builder clearChunksDiscarded() {
          bitField0_ = (bitField0_ & ~0x00000200);
          chunksDiscarded_ = 0L;
          onChanged();
          return this;
        }

        private long chunksRead_ ;
        /**
         * <pre>
         * Num. chunks (!= packets) that were fully read from the circular buffer by
         * the consumer. This may not be equal to |chunks_written| either in the
         * middle of tracing, or if |chunks_overwritten| is non-zero.
         * </pre>
         *
         * <code>optional uint64 chunks_read = 17;</code>
         * @return Whether the chunksRead field is set.
         */
        @java.lang.Override
        public boolean hasChunksRead() {
          return ((bitField0_ & 0x00000400) != 0);
        }
        /**
         * <pre>
         * Num. chunks (!= packets) that were fully read from the circular buffer by
         * the consumer. This may not be equal to |chunks_written| either in the
         * middle of tracing, or if |chunks_overwritten| is non-zero.
         * </pre>
         *
         * <code>optional uint64 chunks_read = 17;</code>
         * @return The chunksRead.
         */
        @java.lang.Override
        public long getChunksRead() {
          return chunksRead_;
        }
        /**
         * <pre>
         * Num. chunks (!= packets) that were fully read from the circular buffer by
         * the consumer. This may not be equal to |chunks_written| either in the
         * middle of tracing, or if |chunks_overwritten| is non-zero.
         * </pre>
         *
         * <code>optional uint64 chunks_read = 17;</code>
         * @param value The chunksRead to set.
         * @return This builder for chaining.
         */
        public Builder setChunksRead(long value) {
          
          chunksRead_ = value;
          bitField0_ |= 0x00000400;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Num. chunks (!= packets) that were fully read from the circular buffer by
         * the consumer. This may not be equal to |chunks_written| either in the
         * middle of tracing, or if |chunks_overwritten| is non-zero.
         * </pre>
         *
         * <code>optional uint64 chunks_read = 17;</code>
         * @return This builder for chaining.
         */
        public Builder clearChunksRead() {
          bitField0_ = (bitField0_ & ~0x00000400);
          chunksRead_ = 0L;
          onChanged();
          return this;
        }

        private long chunksCommittedOutOfOrder_ ;
        /**
         * <pre>
         * Num. chunks that were committed out of order.
         * </pre>
         *
         * <code>optional uint64 chunks_committed_out_of_order = 11;</code>
         * @return Whether the chunksCommittedOutOfOrder field is set.
         */
        @java.lang.Override
        public boolean hasChunksCommittedOutOfOrder() {
          return ((bitField0_ & 0x00000800) != 0);
        }
        /**
         * <pre>
         * Num. chunks that were committed out of order.
         * </pre>
         *
         * <code>optional uint64 chunks_committed_out_of_order = 11;</code>
         * @return The chunksCommittedOutOfOrder.
         */
        @java.lang.Override
        public long getChunksCommittedOutOfOrder() {
          return chunksCommittedOutOfOrder_;
        }
        /**
         * <pre>
         * Num. chunks that were committed out of order.
         * </pre>
         *
         * <code>optional uint64 chunks_committed_out_of_order = 11;</code>
         * @param value The chunksCommittedOutOfOrder to set.
         * @return This builder for chaining.
         */
        public Builder setChunksCommittedOutOfOrder(long value) {
          
          chunksCommittedOutOfOrder_ = value;
          bitField0_ |= 0x00000800;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Num. chunks that were committed out of order.
         * </pre>
         *
         * <code>optional uint64 chunks_committed_out_of_order = 11;</code>
         * @return This builder for chaining.
         */
        public Builder clearChunksCommittedOutOfOrder() {
          bitField0_ = (bitField0_ & ~0x00000800);
          chunksCommittedOutOfOrder_ = 0L;
          onChanged();
          return this;
        }

        private long writeWrapCount_ ;
        /**
         * <pre>
         * Num. times the ring buffer wrapped around.
         * </pre>
         *
         * <code>optional uint64 write_wrap_count = 4;</code>
         * @return Whether the writeWrapCount field is set.
         */
        @java.lang.Override
        public boolean hasWriteWrapCount() {
          return ((bitField0_ & 0x00001000) != 0);
        }
        /**
         * <pre>
         * Num. times the ring buffer wrapped around.
         * </pre>
         *
         * <code>optional uint64 write_wrap_count = 4;</code>
         * @return The writeWrapCount.
         */
        @java.lang.Override
        public long getWriteWrapCount() {
          return writeWrapCount_;
        }
        /**
         * <pre>
         * Num. times the ring buffer wrapped around.
         * </pre>
         *
         * <code>optional uint64 write_wrap_count = 4;</code>
         * @param value The writeWrapCount to set.
         * @return This builder for chaining.
         */
        public Builder setWriteWrapCount(long value) {
          
          writeWrapCount_ = value;
          bitField0_ |= 0x00001000;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Num. times the ring buffer wrapped around.
         * </pre>
         *
         * <code>optional uint64 write_wrap_count = 4;</code>
         * @return This builder for chaining.
         */
        public Builder clearWriteWrapCount() {
          bitField0_ = (bitField0_ & ~0x00001000);
          writeWrapCount_ = 0L;
          onChanged();
          return this;
        }

        private long patchesSucceeded_ ;
        /**
         * <pre>
         * Num. out-of-band (OOB) patches that succeeded.
         * </pre>
         *
         * <code>optional uint64 patches_succeeded = 5;</code>
         * @return Whether the patchesSucceeded field is set.
         */
        @java.lang.Override
        public boolean hasPatchesSucceeded() {
          return ((bitField0_ & 0x00002000) != 0);
        }
        /**
         * <pre>
         * Num. out-of-band (OOB) patches that succeeded.
         * </pre>
         *
         * <code>optional uint64 patches_succeeded = 5;</code>
         * @return The patchesSucceeded.
         */
        @java.lang.Override
        public long getPatchesSucceeded() {
          return patchesSucceeded_;
        }
        /**
         * <pre>
         * Num. out-of-band (OOB) patches that succeeded.
         * </pre>
         *
         * <code>optional uint64 patches_succeeded = 5;</code>
         * @param value The patchesSucceeded to set.
         * @return This builder for chaining.
         */
        public Builder setPatchesSucceeded(long value) {
          
          patchesSucceeded_ = value;
          bitField0_ |= 0x00002000;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Num. out-of-band (OOB) patches that succeeded.
         * </pre>
         *
         * <code>optional uint64 patches_succeeded = 5;</code>
         * @return This builder for chaining.
         */
        public Builder clearPatchesSucceeded() {
          bitField0_ = (bitField0_ & ~0x00002000);
          patchesSucceeded_ = 0L;
          onChanged();
          return this;
        }

        private long patchesFailed_ ;
        /**
         * <pre>
         * Num. OOB patches that failed (e.g., the chunk to patch was gone).
         * </pre>
         *
         * <code>optional uint64 patches_failed = 6;</code>
         * @return Whether the patchesFailed field is set.
         */
        @java.lang.Override
        public boolean hasPatchesFailed() {
          return ((bitField0_ & 0x00004000) != 0);
        }
        /**
         * <pre>
         * Num. OOB patches that failed (e.g., the chunk to patch was gone).
         * </pre>
         *
         * <code>optional uint64 patches_failed = 6;</code>
         * @return The patchesFailed.
         */
        @java.lang.Override
        public long getPatchesFailed() {
          return patchesFailed_;
        }
        /**
         * <pre>
         * Num. OOB patches that failed (e.g., the chunk to patch was gone).
         * </pre>
         *
         * <code>optional uint64 patches_failed = 6;</code>
         * @param value The patchesFailed to set.
         * @return This builder for chaining.
         */
        public Builder setPatchesFailed(long value) {
          
          patchesFailed_ = value;
          bitField0_ |= 0x00004000;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Num. OOB patches that failed (e.g., the chunk to patch was gone).
         * </pre>
         *
         * <code>optional uint64 patches_failed = 6;</code>
         * @return This builder for chaining.
         */
        public Builder clearPatchesFailed() {
          bitField0_ = (bitField0_ & ~0x00004000);
          patchesFailed_ = 0L;
          onChanged();
          return this;
        }

        private long readaheadsSucceeded_ ;
        /**
         * <pre>
         * Num. readaheads (for large multi-chunk packet reads) that ended up in a
         * successful packet read.
         * </pre>
         *
         * <code>optional uint64 readaheads_succeeded = 7;</code>
         * @return Whether the readaheadsSucceeded field is set.
         */
        @java.lang.Override
        public boolean hasReadaheadsSucceeded() {
          return ((bitField0_ & 0x00008000) != 0);
        }
        /**
         * <pre>
         * Num. readaheads (for large multi-chunk packet reads) that ended up in a
         * successful packet read.
         * </pre>
         *
         * <code>optional uint64 readaheads_succeeded = 7;</code>
         * @return The readaheadsSucceeded.
         */
        @java.lang.Override
        public long getReadaheadsSucceeded() {
          return readaheadsSucceeded_;
        }
        /**
         * <pre>
         * Num. readaheads (for large multi-chunk packet reads) that ended up in a
         * successful packet read.
         * </pre>
         *
         * <code>optional uint64 readaheads_succeeded = 7;</code>
         * @param value The readaheadsSucceeded to set.
         * @return This builder for chaining.
         */
        public Builder setReadaheadsSucceeded(long value) {
          
          readaheadsSucceeded_ = value;
          bitField0_ |= 0x00008000;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Num. readaheads (for large multi-chunk packet reads) that ended up in a
         * successful packet read.
         * </pre>
         *
         * <code>optional uint64 readaheads_succeeded = 7;</code>
         * @return This builder for chaining.
         */
        public Builder clearReadaheadsSucceeded() {
          bitField0_ = (bitField0_ & ~0x00008000);
          readaheadsSucceeded_ = 0L;
          onChanged();
          return this;
        }

        private long readaheadsFailed_ ;
        /**
         * <pre>
         * Num. readaheads aborted because of missing chunks in the sequence stream.
         * Note that a small number &gt; 0 is totally expected: occasionally, when
         * issuing a read, the very last packet in a sequence might be incomplete
         * (because the producer is still writing it while we read). The read will
         * stop at that point, for that sequence, increasing this counter.
         * </pre>
         *
         * <code>optional uint64 readaheads_failed = 8;</code>
         * @return Whether the readaheadsFailed field is set.
         */
        @java.lang.Override
        public boolean hasReadaheadsFailed() {
          return ((bitField0_ & 0x00010000) != 0);
        }
        /**
         * <pre>
         * Num. readaheads aborted because of missing chunks in the sequence stream.
         * Note that a small number &gt; 0 is totally expected: occasionally, when
         * issuing a read, the very last packet in a sequence might be incomplete
         * (because the producer is still writing it while we read). The read will
         * stop at that point, for that sequence, increasing this counter.
         * </pre>
         *
         * <code>optional uint64 readaheads_failed = 8;</code>
         * @return The readaheadsFailed.
         */
        @java.lang.Override
        public long getReadaheadsFailed() {
          return readaheadsFailed_;
        }
        /**
         * <pre>
         * Num. readaheads aborted because of missing chunks in the sequence stream.
         * Note that a small number &gt; 0 is totally expected: occasionally, when
         * issuing a read, the very last packet in a sequence might be incomplete
         * (because the producer is still writing it while we read). The read will
         * stop at that point, for that sequence, increasing this counter.
         * </pre>
         *
         * <code>optional uint64 readaheads_failed = 8;</code>
         * @param value The readaheadsFailed to set.
         * @return This builder for chaining.
         */
        public Builder setReadaheadsFailed(long value) {
          
          readaheadsFailed_ = value;
          bitField0_ |= 0x00010000;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Num. readaheads aborted because of missing chunks in the sequence stream.
         * Note that a small number &gt; 0 is totally expected: occasionally, when
         * issuing a read, the very last packet in a sequence might be incomplete
         * (because the producer is still writing it while we read). The read will
         * stop at that point, for that sequence, increasing this counter.
         * </pre>
         *
         * <code>optional uint64 readaheads_failed = 8;</code>
         * @return This builder for chaining.
         */
        public Builder clearReadaheadsFailed() {
          bitField0_ = (bitField0_ & ~0x00010000);
          readaheadsFailed_ = 0L;
          onChanged();
          return this;
        }

        private long abiViolations_ ;
        /**
         * <pre>
         * Num. of violations of the SharedMemoryABI found while writing or reading
         * the buffer. This is an indication of either a bug in the producer(s) or
         * malicious producer(s).
         * </pre>
         *
         * <code>optional uint64 abi_violations = 9;</code>
         * @return Whether the abiViolations field is set.
         */
        @java.lang.Override
        public boolean hasAbiViolations() {
          return ((bitField0_ & 0x00020000) != 0);
        }
        /**
         * <pre>
         * Num. of violations of the SharedMemoryABI found while writing or reading
         * the buffer. This is an indication of either a bug in the producer(s) or
         * malicious producer(s).
         * </pre>
         *
         * <code>optional uint64 abi_violations = 9;</code>
         * @return The abiViolations.
         */
        @java.lang.Override
        public long getAbiViolations() {
          return abiViolations_;
        }
        /**
         * <pre>
         * Num. of violations of the SharedMemoryABI found while writing or reading
         * the buffer. This is an indication of either a bug in the producer(s) or
         * malicious producer(s).
         * </pre>
         *
         * <code>optional uint64 abi_violations = 9;</code>
         * @param value The abiViolations to set.
         * @return This builder for chaining.
         */
        public Builder setAbiViolations(long value) {
          
          abiViolations_ = value;
          bitField0_ |= 0x00020000;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Num. of violations of the SharedMemoryABI found while writing or reading
         * the buffer. This is an indication of either a bug in the producer(s) or
         * malicious producer(s).
         * </pre>
         *
         * <code>optional uint64 abi_violations = 9;</code>
         * @return This builder for chaining.
         */
        public Builder clearAbiViolations() {
          bitField0_ = (bitField0_ & ~0x00020000);
          abiViolations_ = 0L;
          onChanged();
          return this;
        }

        private long traceWriterPacketLoss_ ;
        /**
         * <pre>
         * Num. of times the service detected packet loss on a trace writer
         * sequence. This is usually caused by exhaustion of available chunks in the
         * writer process's SMB. Note that this relies on the client's TraceWriter
         * indicating this loss to the service -- packets lost for other reasons are
         * not reflected in this stat.
         * </pre>
         *
         * <code>optional uint64 trace_writer_packet_loss = 19;</code>
         * @return Whether the traceWriterPacketLoss field is set.
         */
        @java.lang.Override
        public boolean hasTraceWriterPacketLoss() {
          return ((bitField0_ & 0x00040000) != 0);
        }
        /**
         * <pre>
         * Num. of times the service detected packet loss on a trace writer
         * sequence. This is usually caused by exhaustion of available chunks in the
         * writer process's SMB. Note that this relies on the client's TraceWriter
         * indicating this loss to the service -- packets lost for other reasons are
         * not reflected in this stat.
         * </pre>
         *
         * <code>optional uint64 trace_writer_packet_loss = 19;</code>
         * @return The traceWriterPacketLoss.
         */
        @java.lang.Override
        public long getTraceWriterPacketLoss() {
          return traceWriterPacketLoss_;
        }
        /**
         * <pre>
         * Num. of times the service detected packet loss on a trace writer
         * sequence. This is usually caused by exhaustion of available chunks in the
         * writer process's SMB. Note that this relies on the client's TraceWriter
         * indicating this loss to the service -- packets lost for other reasons are
         * not reflected in this stat.
         * </pre>
         *
         * <code>optional uint64 trace_writer_packet_loss = 19;</code>
         * @param value The traceWriterPacketLoss to set.
         * @return This builder for chaining.
         */
        public Builder setTraceWriterPacketLoss(long value) {
          
          traceWriterPacketLoss_ = value;
          bitField0_ |= 0x00040000;
          onChanged();
          return this;
        }
        /**
         * <pre>
         * Num. of times the service detected packet loss on a trace writer
         * sequence. This is usually caused by exhaustion of available chunks in the
         * writer process's SMB. Note that this relies on the client's TraceWriter
         * indicating this loss to the service -- packets lost for other reasons are
         * not reflected in this stat.
         * </pre>
         *
         * <code>optional uint64 trace_writer_packet_loss = 19;</code>
         * @return This builder for chaining.
         */
        public Builder clearTraceWriterPacketLoss() {
          bitField0_ = (bitField0_ & ~0x00040000);
          traceWriterPacketLoss_ = 0L;
          onChanged();
          return this;
        }
        @java.lang.Override
        public final Builder setUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.setUnknownFields(unknownFields);
        }

        @java.lang.Override
        public final Builder mergeUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.mergeUnknownFields(unknownFields);
        }


        // @@protoc_insertion_point(builder_scope:perfetto.protos.TraceStats.BufferStats)
      }

      // @@protoc_insertion_point(class_scope:perfetto.protos.TraceStats.BufferStats)
      private static final perfetto.protos.TraceStatsOuterClass.TraceStats.BufferStats DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new perfetto.protos.TraceStatsOuterClass.TraceStats.BufferStats();
      }

      public static perfetto.protos.TraceStatsOuterClass.TraceStats.BufferStats getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      @java.lang.Deprecated public static final com.google.protobuf.Parser<BufferStats>
          PARSER = new com.google.protobuf.AbstractParser<BufferStats>() {
        @java.lang.Override
        public BufferStats parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          Builder builder = newBuilder();
          try {
            builder.mergeFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.setUnfinishedMessage(builder.buildPartial());
          } catch (com.google.protobuf.UninitializedMessageException e) {
            throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
          } catch (java.io.IOException e) {
            throw new com.google.protobuf.InvalidProtocolBufferException(e)
                .setUnfinishedMessage(builder.buildPartial());
          }
          return builder.buildPartial();
        }
      };

      public static com.google.protobuf.Parser<BufferStats> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<BufferStats> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public perfetto.protos.TraceStatsOuterClass.TraceStats.BufferStats getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    public interface FilterStatsOrBuilder extends
        // @@protoc_insertion_point(interface_extends:perfetto.protos.TraceStats.FilterStats)
        com.google.protobuf.MessageOrBuilder {

      /**
       * <code>optional uint64 input_packets = 1;</code>
       * @return Whether the inputPackets field is set.
       */
      boolean hasInputPackets();
      /**
       * <code>optional uint64 input_packets = 1;</code>
       * @return The inputPackets.
       */
      long getInputPackets();

      /**
       * <code>optional uint64 input_bytes = 2;</code>
       * @return Whether the inputBytes field is set.
       */
      boolean hasInputBytes();
      /**
       * <code>optional uint64 input_bytes = 2;</code>
       * @return The inputBytes.
       */
      long getInputBytes();

      /**
       * <code>optional uint64 output_bytes = 3;</code>
       * @return Whether the outputBytes field is set.
       */
      boolean hasOutputBytes();
      /**
       * <code>optional uint64 output_bytes = 3;</code>
       * @return The outputBytes.
       */
      long getOutputBytes();

      /**
       * <code>optional uint64 errors = 4;</code>
       * @return Whether the errors field is set.
       */
      boolean hasErrors();
      /**
       * <code>optional uint64 errors = 4;</code>
       * @return The errors.
       */
      long getErrors();
    }
    /**
     * <pre>
     * This is set only when the TraceConfig specifies a TraceFilter.
     * </pre>
     *
     * Protobuf type {@code perfetto.protos.TraceStats.FilterStats}
     */
    public static final class FilterStats extends
        com.google.protobuf.GeneratedMessageV3 implements
        // @@protoc_insertion_point(message_implements:perfetto.protos.TraceStats.FilterStats)
        FilterStatsOrBuilder {
    private static final long serialVersionUID = 0L;
      // Use FilterStats.newBuilder() to construct.
      private FilterStats(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
        super(builder);
      }
      private FilterStats() {
      }

      @java.lang.Override
      @SuppressWarnings({"unused"})
      protected java.lang.Object newInstance(
          UnusedPrivateParameter unused) {
        return new FilterStats();
      }

      @java.lang.Override
      public final com.google.protobuf.UnknownFieldSet
      getUnknownFields() {
        return this.unknownFields;
      }
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return perfetto.protos.TraceStatsOuterClass.internal_static_perfetto_protos_TraceStats_FilterStats_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return perfetto.protos.TraceStatsOuterClass.internal_static_perfetto_protos_TraceStats_FilterStats_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                perfetto.protos.TraceStatsOuterClass.TraceStats.FilterStats.class, perfetto.protos.TraceStatsOuterClass.TraceStats.FilterStats.Builder.class);
      }

      private int bitField0_;
      public static final int INPUT_PACKETS_FIELD_NUMBER = 1;
      private long inputPackets_ = 0L;
      /**
       * <code>optional uint64 input_packets = 1;</code>
       * @return Whether the inputPackets field is set.
       */
      @java.lang.Override
      public boolean hasInputPackets() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <code>optional uint64 input_packets = 1;</code>
       * @return The inputPackets.
       */
      @java.lang.Override
      public long getInputPackets() {
        return inputPackets_;
      }

      public static final int INPUT_BYTES_FIELD_NUMBER = 2;
      private long inputBytes_ = 0L;
      /**
       * <code>optional uint64 input_bytes = 2;</code>
       * @return Whether the inputBytes field is set.
       */
      @java.lang.Override
      public boolean hasInputBytes() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <code>optional uint64 input_bytes = 2;</code>
       * @return The inputBytes.
       */
      @java.lang.Override
      public long getInputBytes() {
        return inputBytes_;
      }

      public static final int OUTPUT_BYTES_FIELD_NUMBER = 3;
      private long outputBytes_ = 0L;
      /**
       * <code>optional uint64 output_bytes = 3;</code>
       * @return Whether the outputBytes field is set.
       */
      @java.lang.Override
      public boolean hasOutputBytes() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <code>optional uint64 output_bytes = 3;</code>
       * @return The outputBytes.
       */
      @java.lang.Override
      public long getOutputBytes() {
        return outputBytes_;
      }

      public static final int ERRORS_FIELD_NUMBER = 4;
      private long errors_ = 0L;
      /**
       * <code>optional uint64 errors = 4;</code>
       * @return Whether the errors field is set.
       */
      @java.lang.Override
      public boolean hasErrors() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <code>optional uint64 errors = 4;</code>
       * @return The errors.
       */
      @java.lang.Override
      public long getErrors() {
        return errors_;
      }

      private byte memoizedIsInitialized = -1;
      @java.lang.Override
      public final boolean isInitialized() {
        byte isInitialized = memoizedIsInitialized;
        if (isInitialized == 1) return true;
        if (isInitialized == 0) return false;

        memoizedIsInitialized = 1;
        return true;
      }

      @java.lang.Override
      public void writeTo(com.google.protobuf.CodedOutputStream output)
                          throws java.io.IOException {
        if (((bitField0_ & 0x00000001) != 0)) {
          output.writeUInt64(1, inputPackets_);
        }
        if (((bitField0_ & 0x00000002) != 0)) {
          output.writeUInt64(2, inputBytes_);
        }
        if (((bitField0_ & 0x00000004) != 0)) {
          output.writeUInt64(3, outputBytes_);
        }
        if (((bitField0_ & 0x00000008) != 0)) {
          output.writeUInt64(4, errors_);
        }
        getUnknownFields().writeTo(output);
      }

      @java.lang.Override
      public int getSerializedSize() {
        int size = memoizedSize;
        if (size != -1) return size;

        size = 0;
        if (((bitField0_ & 0x00000001) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt64Size(1, inputPackets_);
        }
        if (((bitField0_ & 0x00000002) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt64Size(2, inputBytes_);
        }
        if (((bitField0_ & 0x00000004) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt64Size(3, outputBytes_);
        }
        if (((bitField0_ & 0x00000008) != 0)) {
          size += com.google.protobuf.CodedOutputStream
            .computeUInt64Size(4, errors_);
        }
        size += getUnknownFields().getSerializedSize();
        memoizedSize = size;
        return size;
      }

      @java.lang.Override
      public boolean equals(final java.lang.Object obj) {
        if (obj == this) {
         return true;
        }
        if (!(obj instanceof perfetto.protos.TraceStatsOuterClass.TraceStats.FilterStats)) {
          return super.equals(obj);
        }
        perfetto.protos.TraceStatsOuterClass.TraceStats.FilterStats other = (perfetto.protos.TraceStatsOuterClass.TraceStats.FilterStats) obj;

        if (hasInputPackets() != other.hasInputPackets()) return false;
        if (hasInputPackets()) {
          if (getInputPackets()
              != other.getInputPackets()) return false;
        }
        if (hasInputBytes() != other.hasInputBytes()) return false;
        if (hasInputBytes()) {
          if (getInputBytes()
              != other.getInputBytes()) return false;
        }
        if (hasOutputBytes() != other.hasOutputBytes()) return false;
        if (hasOutputBytes()) {
          if (getOutputBytes()
              != other.getOutputBytes()) return false;
        }
        if (hasErrors() != other.hasErrors()) return false;
        if (hasErrors()) {
          if (getErrors()
              != other.getErrors()) return false;
        }
        if (!getUnknownFields().equals(other.getUnknownFields())) return false;
        return true;
      }

      @java.lang.Override
      public int hashCode() {
        if (memoizedHashCode != 0) {
          return memoizedHashCode;
        }
        int hash = 41;
        hash = (19 * hash) + getDescriptor().hashCode();
        if (hasInputPackets()) {
          hash = (37 * hash) + INPUT_PACKETS_FIELD_NUMBER;
          hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
              getInputPackets());
        }
        if (hasInputBytes()) {
          hash = (37 * hash) + INPUT_BYTES_FIELD_NUMBER;
          hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
              getInputBytes());
        }
        if (hasOutputBytes()) {
          hash = (37 * hash) + OUTPUT_BYTES_FIELD_NUMBER;
          hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
              getOutputBytes());
        }
        if (hasErrors()) {
          hash = (37 * hash) + ERRORS_FIELD_NUMBER;
          hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
              getErrors());
        }
        hash = (29 * hash) + getUnknownFields().hashCode();
        memoizedHashCode = hash;
        return hash;
      }

      public static perfetto.protos.TraceStatsOuterClass.TraceStats.FilterStats parseFrom(
          java.nio.ByteBuffer data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static perfetto.protos.TraceStatsOuterClass.TraceStats.FilterStats parseFrom(
          java.nio.ByteBuffer data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static perfetto.protos.TraceStatsOuterClass.TraceStats.FilterStats parseFrom(
          com.google.protobuf.ByteString data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static perfetto.protos.TraceStatsOuterClass.TraceStats.FilterStats parseFrom(
          com.google.protobuf.ByteString data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static perfetto.protos.TraceStatsOuterClass.TraceStats.FilterStats parseFrom(byte[] data)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data);
      }
      public static perfetto.protos.TraceStatsOuterClass.TraceStats.FilterStats parseFrom(
          byte[] data,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return PARSER.parseFrom(data, extensionRegistry);
      }
      public static perfetto.protos.TraceStatsOuterClass.TraceStats.FilterStats parseFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static perfetto.protos.TraceStatsOuterClass.TraceStats.FilterStats parseFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }
      public static perfetto.protos.TraceStatsOuterClass.TraceStats.FilterStats parseDelimitedFrom(java.io.InputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input);
      }
      public static perfetto.protos.TraceStatsOuterClass.TraceStats.FilterStats parseDelimitedFrom(
          java.io.InputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
      }
      public static perfetto.protos.TraceStatsOuterClass.TraceStats.FilterStats parseFrom(
          com.google.protobuf.CodedInputStream input)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input);
      }
      public static perfetto.protos.TraceStatsOuterClass.TraceStats.FilterStats parseFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        return com.google.protobuf.GeneratedMessageV3
            .parseWithIOException(PARSER, input, extensionRegistry);
      }

      @java.lang.Override
      public Builder newBuilderForType() { return newBuilder(); }
      public static Builder newBuilder() {
        return DEFAULT_INSTANCE.toBuilder();
      }
      public static Builder newBuilder(perfetto.protos.TraceStatsOuterClass.TraceStats.FilterStats prototype) {
        return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
      }
      @java.lang.Override
      public Builder toBuilder() {
        return this == DEFAULT_INSTANCE
            ? new Builder() : new Builder().mergeFrom(this);
      }

      @java.lang.Override
      protected Builder newBuilderForType(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        Builder builder = new Builder(parent);
        return builder;
      }
      /**
       * <pre>
       * This is set only when the TraceConfig specifies a TraceFilter.
       * </pre>
       *
       * Protobuf type {@code perfetto.protos.TraceStats.FilterStats}
       */
      public static final class Builder extends
          com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
          // @@protoc_insertion_point(builder_implements:perfetto.protos.TraceStats.FilterStats)
          perfetto.protos.TraceStatsOuterClass.TraceStats.FilterStatsOrBuilder {
        public static final com.google.protobuf.Descriptors.Descriptor
            getDescriptor() {
          return perfetto.protos.TraceStatsOuterClass.internal_static_perfetto_protos_TraceStats_FilterStats_descriptor;
        }

        @java.lang.Override
        protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
            internalGetFieldAccessorTable() {
          return perfetto.protos.TraceStatsOuterClass.internal_static_perfetto_protos_TraceStats_FilterStats_fieldAccessorTable
              .ensureFieldAccessorsInitialized(
                  perfetto.protos.TraceStatsOuterClass.TraceStats.FilterStats.class, perfetto.protos.TraceStatsOuterClass.TraceStats.FilterStats.Builder.class);
        }

        // Construct using perfetto.protos.TraceStatsOuterClass.TraceStats.FilterStats.newBuilder()
        private Builder() {

        }

        private Builder(
            com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
          super(parent);

        }
        @java.lang.Override
        public Builder clear() {
          super.clear();
          bitField0_ = 0;
          inputPackets_ = 0L;
          inputBytes_ = 0L;
          outputBytes_ = 0L;
          errors_ = 0L;
          return this;
        }

        @java.lang.Override
        public com.google.protobuf.Descriptors.Descriptor
            getDescriptorForType() {
          return perfetto.protos.TraceStatsOuterClass.internal_static_perfetto_protos_TraceStats_FilterStats_descriptor;
        }

        @java.lang.Override
        public perfetto.protos.TraceStatsOuterClass.TraceStats.FilterStats getDefaultInstanceForType() {
          return perfetto.protos.TraceStatsOuterClass.TraceStats.FilterStats.getDefaultInstance();
        }

        @java.lang.Override
        public perfetto.protos.TraceStatsOuterClass.TraceStats.FilterStats build() {
          perfetto.protos.TraceStatsOuterClass.TraceStats.FilterStats result = buildPartial();
          if (!result.isInitialized()) {
            throw newUninitializedMessageException(result);
          }
          return result;
        }

        @java.lang.Override
        public perfetto.protos.TraceStatsOuterClass.TraceStats.FilterStats buildPartial() {
          perfetto.protos.TraceStatsOuterClass.TraceStats.FilterStats result = new perfetto.protos.TraceStatsOuterClass.TraceStats.FilterStats(this);
          if (bitField0_ != 0) { buildPartial0(result); }
          onBuilt();
          return result;
        }

        private void buildPartial0(perfetto.protos.TraceStatsOuterClass.TraceStats.FilterStats result) {
          int from_bitField0_ = bitField0_;
          int to_bitField0_ = 0;
          if (((from_bitField0_ & 0x00000001) != 0)) {
            result.inputPackets_ = inputPackets_;
            to_bitField0_ |= 0x00000001;
          }
          if (((from_bitField0_ & 0x00000002) != 0)) {
            result.inputBytes_ = inputBytes_;
            to_bitField0_ |= 0x00000002;
          }
          if (((from_bitField0_ & 0x00000004) != 0)) {
            result.outputBytes_ = outputBytes_;
            to_bitField0_ |= 0x00000004;
          }
          if (((from_bitField0_ & 0x00000008) != 0)) {
            result.errors_ = errors_;
            to_bitField0_ |= 0x00000008;
          }
          result.bitField0_ |= to_bitField0_;
        }

        @java.lang.Override
        public Builder clone() {
          return super.clone();
        }
        @java.lang.Override
        public Builder setField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.setField(field, value);
        }
        @java.lang.Override
        public Builder clearField(
            com.google.protobuf.Descriptors.FieldDescriptor field) {
          return super.clearField(field);
        }
        @java.lang.Override
        public Builder clearOneof(
            com.google.protobuf.Descriptors.OneofDescriptor oneof) {
          return super.clearOneof(oneof);
        }
        @java.lang.Override
        public Builder setRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            int index, java.lang.Object value) {
          return super.setRepeatedField(field, index, value);
        }
        @java.lang.Override
        public Builder addRepeatedField(
            com.google.protobuf.Descriptors.FieldDescriptor field,
            java.lang.Object value) {
          return super.addRepeatedField(field, value);
        }
        @java.lang.Override
        public Builder mergeFrom(com.google.protobuf.Message other) {
          if (other instanceof perfetto.protos.TraceStatsOuterClass.TraceStats.FilterStats) {
            return mergeFrom((perfetto.protos.TraceStatsOuterClass.TraceStats.FilterStats)other);
          } else {
            super.mergeFrom(other);
            return this;
          }
        }

        public Builder mergeFrom(perfetto.protos.TraceStatsOuterClass.TraceStats.FilterStats other) {
          if (other == perfetto.protos.TraceStatsOuterClass.TraceStats.FilterStats.getDefaultInstance()) return this;
          if (other.hasInputPackets()) {
            setInputPackets(other.getInputPackets());
          }
          if (other.hasInputBytes()) {
            setInputBytes(other.getInputBytes());
          }
          if (other.hasOutputBytes()) {
            setOutputBytes(other.getOutputBytes());
          }
          if (other.hasErrors()) {
            setErrors(other.getErrors());
          }
          this.mergeUnknownFields(other.getUnknownFields());
          onChanged();
          return this;
        }

        @java.lang.Override
        public final boolean isInitialized() {
          return true;
        }

        @java.lang.Override
        public Builder mergeFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws java.io.IOException {
          if (extensionRegistry == null) {
            throw new java.lang.NullPointerException();
          }
          try {
            boolean done = false;
            while (!done) {
              int tag = input.readTag();
              switch (tag) {
                case 0:
                  done = true;
                  break;
                case 8: {
                  inputPackets_ = input.readUInt64();
                  bitField0_ |= 0x00000001;
                  break;
                } // case 8
                case 16: {
                  inputBytes_ = input.readUInt64();
                  bitField0_ |= 0x00000002;
                  break;
                } // case 16
                case 24: {
                  outputBytes_ = input.readUInt64();
                  bitField0_ |= 0x00000004;
                  break;
                } // case 24
                case 32: {
                  errors_ = input.readUInt64();
                  bitField0_ |= 0x00000008;
                  break;
                } // case 32
                default: {
                  if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                    done = true; // was an endgroup tag
                  }
                  break;
                } // default:
              } // switch (tag)
            } // while (!done)
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.unwrapIOException();
          } finally {
            onChanged();
          } // finally
          return this;
        }
        private int bitField0_;

        private long inputPackets_ ;
        /**
         * <code>optional uint64 input_packets = 1;</code>
         * @return Whether the inputPackets field is set.
         */
        @java.lang.Override
        public boolean hasInputPackets() {
          return ((bitField0_ & 0x00000001) != 0);
        }
        /**
         * <code>optional uint64 input_packets = 1;</code>
         * @return The inputPackets.
         */
        @java.lang.Override
        public long getInputPackets() {
          return inputPackets_;
        }
        /**
         * <code>optional uint64 input_packets = 1;</code>
         * @param value The inputPackets to set.
         * @return This builder for chaining.
         */
        public Builder setInputPackets(long value) {
          
          inputPackets_ = value;
          bitField0_ |= 0x00000001;
          onChanged();
          return this;
        }
        /**
         * <code>optional uint64 input_packets = 1;</code>
         * @return This builder for chaining.
         */
        public Builder clearInputPackets() {
          bitField0_ = (bitField0_ & ~0x00000001);
          inputPackets_ = 0L;
          onChanged();
          return this;
        }

        private long inputBytes_ ;
        /**
         * <code>optional uint64 input_bytes = 2;</code>
         * @return Whether the inputBytes field is set.
         */
        @java.lang.Override
        public boolean hasInputBytes() {
          return ((bitField0_ & 0x00000002) != 0);
        }
        /**
         * <code>optional uint64 input_bytes = 2;</code>
         * @return The inputBytes.
         */
        @java.lang.Override
        public long getInputBytes() {
          return inputBytes_;
        }
        /**
         * <code>optional uint64 input_bytes = 2;</code>
         * @param value The inputBytes to set.
         * @return This builder for chaining.
         */
        public Builder setInputBytes(long value) {
          
          inputBytes_ = value;
          bitField0_ |= 0x00000002;
          onChanged();
          return this;
        }
        /**
         * <code>optional uint64 input_bytes = 2;</code>
         * @return This builder for chaining.
         */
        public Builder clearInputBytes() {
          bitField0_ = (bitField0_ & ~0x00000002);
          inputBytes_ = 0L;
          onChanged();
          return this;
        }

        private long outputBytes_ ;
        /**
         * <code>optional uint64 output_bytes = 3;</code>
         * @return Whether the outputBytes field is set.
         */
        @java.lang.Override
        public boolean hasOutputBytes() {
          return ((bitField0_ & 0x00000004) != 0);
        }
        /**
         * <code>optional uint64 output_bytes = 3;</code>
         * @return The outputBytes.
         */
        @java.lang.Override
        public long getOutputBytes() {
          return outputBytes_;
        }
        /**
         * <code>optional uint64 output_bytes = 3;</code>
         * @param value The outputBytes to set.
         * @return This builder for chaining.
         */
        public Builder setOutputBytes(long value) {
          
          outputBytes_ = value;
          bitField0_ |= 0x00000004;
          onChanged();
          return this;
        }
        /**
         * <code>optional uint64 output_bytes = 3;</code>
         * @return This builder for chaining.
         */
        public Builder clearOutputBytes() {
          bitField0_ = (bitField0_ & ~0x00000004);
          outputBytes_ = 0L;
          onChanged();
          return this;
        }

        private long errors_ ;
        /**
         * <code>optional uint64 errors = 4;</code>
         * @return Whether the errors field is set.
         */
        @java.lang.Override
        public boolean hasErrors() {
          return ((bitField0_ & 0x00000008) != 0);
        }
        /**
         * <code>optional uint64 errors = 4;</code>
         * @return The errors.
         */
        @java.lang.Override
        public long getErrors() {
          return errors_;
        }
        /**
         * <code>optional uint64 errors = 4;</code>
         * @param value The errors to set.
         * @return This builder for chaining.
         */
        public Builder setErrors(long value) {
          
          errors_ = value;
          bitField0_ |= 0x00000008;
          onChanged();
          return this;
        }
        /**
         * <code>optional uint64 errors = 4;</code>
         * @return This builder for chaining.
         */
        public Builder clearErrors() {
          bitField0_ = (bitField0_ & ~0x00000008);
          errors_ = 0L;
          onChanged();
          return this;
        }
        @java.lang.Override
        public final Builder setUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.setUnknownFields(unknownFields);
        }

        @java.lang.Override
        public final Builder mergeUnknownFields(
            final com.google.protobuf.UnknownFieldSet unknownFields) {
          return super.mergeUnknownFields(unknownFields);
        }


        // @@protoc_insertion_point(builder_scope:perfetto.protos.TraceStats.FilterStats)
      }

      // @@protoc_insertion_point(class_scope:perfetto.protos.TraceStats.FilterStats)
      private static final perfetto.protos.TraceStatsOuterClass.TraceStats.FilterStats DEFAULT_INSTANCE;
      static {
        DEFAULT_INSTANCE = new perfetto.protos.TraceStatsOuterClass.TraceStats.FilterStats();
      }

      public static perfetto.protos.TraceStatsOuterClass.TraceStats.FilterStats getDefaultInstance() {
        return DEFAULT_INSTANCE;
      }

      @java.lang.Deprecated public static final com.google.protobuf.Parser<FilterStats>
          PARSER = new com.google.protobuf.AbstractParser<FilterStats>() {
        @java.lang.Override
        public FilterStats parsePartialFrom(
            com.google.protobuf.CodedInputStream input,
            com.google.protobuf.ExtensionRegistryLite extensionRegistry)
            throws com.google.protobuf.InvalidProtocolBufferException {
          Builder builder = newBuilder();
          try {
            builder.mergeFrom(input, extensionRegistry);
          } catch (com.google.protobuf.InvalidProtocolBufferException e) {
            throw e.setUnfinishedMessage(builder.buildPartial());
          } catch (com.google.protobuf.UninitializedMessageException e) {
            throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
          } catch (java.io.IOException e) {
            throw new com.google.protobuf.InvalidProtocolBufferException(e)
                .setUnfinishedMessage(builder.buildPartial());
          }
          return builder.buildPartial();
        }
      };

      public static com.google.protobuf.Parser<FilterStats> parser() {
        return PARSER;
      }

      @java.lang.Override
      public com.google.protobuf.Parser<FilterStats> getParserForType() {
        return PARSER;
      }

      @java.lang.Override
      public perfetto.protos.TraceStatsOuterClass.TraceStats.FilterStats getDefaultInstanceForType() {
        return DEFAULT_INSTANCE;
      }

    }

    private int bitField0_;
    public static final int BUFFER_STATS_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private java.util.List<perfetto.protos.TraceStatsOuterClass.TraceStats.BufferStats> bufferStats_;
    /**
     * <pre>
     * Stats for the TraceBuffer(s) of the current trace session.
     * </pre>
     *
     * <code>repeated .perfetto.protos.TraceStats.BufferStats buffer_stats = 1;</code>
     */
    @java.lang.Override
    public java.util.List<perfetto.protos.TraceStatsOuterClass.TraceStats.BufferStats> getBufferStatsList() {
      return bufferStats_;
    }
    /**
     * <pre>
     * Stats for the TraceBuffer(s) of the current trace session.
     * </pre>
     *
     * <code>repeated .perfetto.protos.TraceStats.BufferStats buffer_stats = 1;</code>
     */
    @java.lang.Override
    public java.util.List<? extends perfetto.protos.TraceStatsOuterClass.TraceStats.BufferStatsOrBuilder> 
        getBufferStatsOrBuilderList() {
      return bufferStats_;
    }
    /**
     * <pre>
     * Stats for the TraceBuffer(s) of the current trace session.
     * </pre>
     *
     * <code>repeated .perfetto.protos.TraceStats.BufferStats buffer_stats = 1;</code>
     */
    @java.lang.Override
    public int getBufferStatsCount() {
      return bufferStats_.size();
    }
    /**
     * <pre>
     * Stats for the TraceBuffer(s) of the current trace session.
     * </pre>
     *
     * <code>repeated .perfetto.protos.TraceStats.BufferStats buffer_stats = 1;</code>
     */
    @java.lang.Override
    public perfetto.protos.TraceStatsOuterClass.TraceStats.BufferStats getBufferStats(int index) {
      return bufferStats_.get(index);
    }
    /**
     * <pre>
     * Stats for the TraceBuffer(s) of the current trace session.
     * </pre>
     *
     * <code>repeated .perfetto.protos.TraceStats.BufferStats buffer_stats = 1;</code>
     */
    @java.lang.Override
    public perfetto.protos.TraceStatsOuterClass.TraceStats.BufferStatsOrBuilder getBufferStatsOrBuilder(
        int index) {
      return bufferStats_.get(index);
    }

    public static final int PRODUCERS_CONNECTED_FIELD_NUMBER = 2;
    private int producersConnected_ = 0;
    /**
     * <pre>
     * Num. producers connected (whether they are involved in the current tracing
     * session or not).
     * </pre>
     *
     * <code>optional uint32 producers_connected = 2;</code>
     * @return Whether the producersConnected field is set.
     */
    @java.lang.Override
    public boolean hasProducersConnected() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Num. producers connected (whether they are involved in the current tracing
     * session or not).
     * </pre>
     *
     * <code>optional uint32 producers_connected = 2;</code>
     * @return The producersConnected.
     */
    @java.lang.Override
    public int getProducersConnected() {
      return producersConnected_;
    }

    public static final int PRODUCERS_SEEN_FIELD_NUMBER = 3;
    private long producersSeen_ = 0L;
    /**
     * <pre>
     * Num. producers ever seen for all trace sessions since startup (it's a good
     * proxy for inferring num. producers crashed / killed).
     * </pre>
     *
     * <code>optional uint64 producers_seen = 3;</code>
     * @return Whether the producersSeen field is set.
     */
    @java.lang.Override
    public boolean hasProducersSeen() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Num. producers ever seen for all trace sessions since startup (it's a good
     * proxy for inferring num. producers crashed / killed).
     * </pre>
     *
     * <code>optional uint64 producers_seen = 3;</code>
     * @return The producersSeen.
     */
    @java.lang.Override
    public long getProducersSeen() {
      return producersSeen_;
    }

    public static final int DATA_SOURCES_REGISTERED_FIELD_NUMBER = 4;
    private int dataSourcesRegistered_ = 0;
    /**
     * <pre>
     * Num. data sources registered for all trace sessions.
     * </pre>
     *
     * <code>optional uint32 data_sources_registered = 4;</code>
     * @return Whether the dataSourcesRegistered field is set.
     */
    @java.lang.Override
    public boolean hasDataSourcesRegistered() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * Num. data sources registered for all trace sessions.
     * </pre>
     *
     * <code>optional uint32 data_sources_registered = 4;</code>
     * @return The dataSourcesRegistered.
     */
    @java.lang.Override
    public int getDataSourcesRegistered() {
      return dataSourcesRegistered_;
    }

    public static final int DATA_SOURCES_SEEN_FIELD_NUMBER = 5;
    private long dataSourcesSeen_ = 0L;
    /**
     * <pre>
     * Num. data sources ever seen for all trace sessions since startup.
     * </pre>
     *
     * <code>optional uint64 data_sources_seen = 5;</code>
     * @return Whether the dataSourcesSeen field is set.
     */
    @java.lang.Override
    public boolean hasDataSourcesSeen() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * Num. data sources ever seen for all trace sessions since startup.
     * </pre>
     *
     * <code>optional uint64 data_sources_seen = 5;</code>
     * @return The dataSourcesSeen.
     */
    @java.lang.Override
    public long getDataSourcesSeen() {
      return dataSourcesSeen_;
    }

    public static final int TRACING_SESSIONS_FIELD_NUMBER = 6;
    private int tracingSessions_ = 0;
    /**
     * <pre>
     * Num. concurrently active tracing sessions.
     * </pre>
     *
     * <code>optional uint32 tracing_sessions = 6;</code>
     * @return Whether the tracingSessions field is set.
     */
    @java.lang.Override
    public boolean hasTracingSessions() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * Num. concurrently active tracing sessions.
     * </pre>
     *
     * <code>optional uint32 tracing_sessions = 6;</code>
     * @return The tracingSessions.
     */
    @java.lang.Override
    public int getTracingSessions() {
      return tracingSessions_;
    }

    public static final int TOTAL_BUFFERS_FIELD_NUMBER = 7;
    private int totalBuffers_ = 0;
    /**
     * <pre>
     * Num. buffers for all tracing session (not just the current one). This will
     * be &gt;= buffer_stats.size(), because the latter is only about the current
     * session.
     * </pre>
     *
     * <code>optional uint32 total_buffers = 7;</code>
     * @return Whether the totalBuffers field is set.
     */
    @java.lang.Override
    public boolean hasTotalBuffers() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * Num. buffers for all tracing session (not just the current one). This will
     * be &gt;= buffer_stats.size(), because the latter is only about the current
     * session.
     * </pre>
     *
     * <code>optional uint32 total_buffers = 7;</code>
     * @return The totalBuffers.
     */
    @java.lang.Override
    public int getTotalBuffers() {
      return totalBuffers_;
    }

    public static final int CHUNKS_DISCARDED_FIELD_NUMBER = 8;
    private long chunksDiscarded_ = 0L;
    /**
     * <pre>
     * Num. chunks that were discarded by the service before attempting to commit
     * them to a buffer, e.g. because the producer specified an invalid buffer ID.
     * </pre>
     *
     * <code>optional uint64 chunks_discarded = 8;</code>
     * @return Whether the chunksDiscarded field is set.
     */
    @java.lang.Override
    public boolean hasChunksDiscarded() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <pre>
     * Num. chunks that were discarded by the service before attempting to commit
     * them to a buffer, e.g. because the producer specified an invalid buffer ID.
     * </pre>
     *
     * <code>optional uint64 chunks_discarded = 8;</code>
     * @return The chunksDiscarded.
     */
    @java.lang.Override
    public long getChunksDiscarded() {
      return chunksDiscarded_;
    }

    public static final int PATCHES_DISCARDED_FIELD_NUMBER = 9;
    private long patchesDiscarded_ = 0L;
    /**
     * <pre>
     * Num. patches that were discarded by the service before attempting to apply
     * them to a buffer, e.g. because the producer specified an invalid buffer ID.
     * </pre>
     *
     * <code>optional uint64 patches_discarded = 9;</code>
     * @return Whether the patchesDiscarded field is set.
     */
    @java.lang.Override
    public boolean hasPatchesDiscarded() {
      return ((bitField0_ & 0x00000080) != 0);
    }
    /**
     * <pre>
     * Num. patches that were discarded by the service before attempting to apply
     * them to a buffer, e.g. because the producer specified an invalid buffer ID.
     * </pre>
     *
     * <code>optional uint64 patches_discarded = 9;</code>
     * @return The patchesDiscarded.
     */
    @java.lang.Override
    public long getPatchesDiscarded() {
      return patchesDiscarded_;
    }

    public static final int INVALID_PACKETS_FIELD_NUMBER = 10;
    private long invalidPackets_ = 0L;
    /**
     * <pre>
     * Packets that failed validation of the TrustedPacket. If this is &gt; 0, there
     * is a bug in the producer.
     * </pre>
     *
     * <code>optional uint64 invalid_packets = 10;</code>
     * @return Whether the invalidPackets field is set.
     */
    @java.lang.Override
    public boolean hasInvalidPackets() {
      return ((bitField0_ & 0x00000100) != 0);
    }
    /**
     * <pre>
     * Packets that failed validation of the TrustedPacket. If this is &gt; 0, there
     * is a bug in the producer.
     * </pre>
     *
     * <code>optional uint64 invalid_packets = 10;</code>
     * @return The invalidPackets.
     */
    @java.lang.Override
    public long getInvalidPackets() {
      return invalidPackets_;
    }

    public static final int FILTER_STATS_FIELD_NUMBER = 11;
    private perfetto.protos.TraceStatsOuterClass.TraceStats.FilterStats filterStats_;
    /**
     * <code>optional .perfetto.protos.TraceStats.FilterStats filter_stats = 11;</code>
     * @return Whether the filterStats field is set.
     */
    @java.lang.Override
    public boolean hasFilterStats() {
      return ((bitField0_ & 0x00000200) != 0);
    }
    /**
     * <code>optional .perfetto.protos.TraceStats.FilterStats filter_stats = 11;</code>
     * @return The filterStats.
     */
    @java.lang.Override
    public perfetto.protos.TraceStatsOuterClass.TraceStats.FilterStats getFilterStats() {
      return filterStats_ == null ? perfetto.protos.TraceStatsOuterClass.TraceStats.FilterStats.getDefaultInstance() : filterStats_;
    }
    /**
     * <code>optional .perfetto.protos.TraceStats.FilterStats filter_stats = 11;</code>
     */
    @java.lang.Override
    public perfetto.protos.TraceStatsOuterClass.TraceStats.FilterStatsOrBuilder getFilterStatsOrBuilder() {
      return filterStats_ == null ? perfetto.protos.TraceStatsOuterClass.TraceStats.FilterStats.getDefaultInstance() : filterStats_;
    }

    public static final int FLUSHES_REQUESTED_FIELD_NUMBER = 12;
    private long flushesRequested_ = 0L;
    /**
     * <pre>
     * Count of Flush() requests (either from the Consumer, or self-induced
     * periodic flushes). The final Flush() is also included in the count.
     * </pre>
     *
     * <code>optional uint64 flushes_requested = 12;</code>
     * @return Whether the flushesRequested field is set.
     */
    @java.lang.Override
    public boolean hasFlushesRequested() {
      return ((bitField0_ & 0x00000400) != 0);
    }
    /**
     * <pre>
     * Count of Flush() requests (either from the Consumer, or self-induced
     * periodic flushes). The final Flush() is also included in the count.
     * </pre>
     *
     * <code>optional uint64 flushes_requested = 12;</code>
     * @return The flushesRequested.
     */
    @java.lang.Override
    public long getFlushesRequested() {
      return flushesRequested_;
    }

    public static final int FLUSHES_SUCCEEDED_FIELD_NUMBER = 13;
    private long flushesSucceeded_ = 0L;
    /**
     * <pre>
     * The count of the Flush() requests that were completed successfully.
     * In a well behaving trace this should always be == `flush_requests`.
     * </pre>
     *
     * <code>optional uint64 flushes_succeeded = 13;</code>
     * @return Whether the flushesSucceeded field is set.
     */
    @java.lang.Override
    public boolean hasFlushesSucceeded() {
      return ((bitField0_ & 0x00000800) != 0);
    }
    /**
     * <pre>
     * The count of the Flush() requests that were completed successfully.
     * In a well behaving trace this should always be == `flush_requests`.
     * </pre>
     *
     * <code>optional uint64 flushes_succeeded = 13;</code>
     * @return The flushesSucceeded.
     */
    @java.lang.Override
    public long getFlushesSucceeded() {
      return flushesSucceeded_;
    }

    public static final int FLUSHES_FAILED_FIELD_NUMBER = 14;
    private long flushesFailed_ = 0L;
    /**
     * <pre>
     * The count of the Flush() requests that failed (in most timed out).
     * In a well behaving trace this should always be == 0.
     * </pre>
     *
     * <code>optional uint64 flushes_failed = 14;</code>
     * @return Whether the flushesFailed field is set.
     */
    @java.lang.Override
    public boolean hasFlushesFailed() {
      return ((bitField0_ & 0x00001000) != 0);
    }
    /**
     * <pre>
     * The count of the Flush() requests that failed (in most timed out).
     * In a well behaving trace this should always be == 0.
     * </pre>
     *
     * <code>optional uint64 flushes_failed = 14;</code>
     * @return The flushesFailed.
     */
    @java.lang.Override
    public long getFlushesFailed() {
      return flushesFailed_;
    }

    public static final int FINAL_FLUSH_OUTCOME_FIELD_NUMBER = 15;
    private int finalFlushOutcome_ = 0;
    /**
     * <code>optional .perfetto.protos.TraceStats.FinalFlushOutcome final_flush_outcome = 15;</code>
     * @return Whether the finalFlushOutcome field is set.
     */
    @java.lang.Override public boolean hasFinalFlushOutcome() {
      return ((bitField0_ & 0x00002000) != 0);
    }
    /**
     * <code>optional .perfetto.protos.TraceStats.FinalFlushOutcome final_flush_outcome = 15;</code>
     * @return The finalFlushOutcome.
     */
    @java.lang.Override public perfetto.protos.TraceStatsOuterClass.TraceStats.FinalFlushOutcome getFinalFlushOutcome() {
      perfetto.protos.TraceStatsOuterClass.TraceStats.FinalFlushOutcome result = perfetto.protos.TraceStatsOuterClass.TraceStats.FinalFlushOutcome.forNumber(finalFlushOutcome_);
      return result == null ? perfetto.protos.TraceStatsOuterClass.TraceStats.FinalFlushOutcome.FINAL_FLUSH_UNSPECIFIED : result;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < bufferStats_.size(); i++) {
        output.writeMessage(1, bufferStats_.get(i));
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        output.writeUInt32(2, producersConnected_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeUInt64(3, producersSeen_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeUInt32(4, dataSourcesRegistered_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        output.writeUInt64(5, dataSourcesSeen_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        output.writeUInt32(6, tracingSessions_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        output.writeUInt32(7, totalBuffers_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        output.writeUInt64(8, chunksDiscarded_);
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        output.writeUInt64(9, patchesDiscarded_);
      }
      if (((bitField0_ & 0x00000100) != 0)) {
        output.writeUInt64(10, invalidPackets_);
      }
      if (((bitField0_ & 0x00000200) != 0)) {
        output.writeMessage(11, getFilterStats());
      }
      if (((bitField0_ & 0x00000400) != 0)) {
        output.writeUInt64(12, flushesRequested_);
      }
      if (((bitField0_ & 0x00000800) != 0)) {
        output.writeUInt64(13, flushesSucceeded_);
      }
      if (((bitField0_ & 0x00001000) != 0)) {
        output.writeUInt64(14, flushesFailed_);
      }
      if (((bitField0_ & 0x00002000) != 0)) {
        output.writeEnum(15, finalFlushOutcome_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < bufferStats_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, bufferStats_.get(i));
      }
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(2, producersConnected_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(3, producersSeen_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(4, dataSourcesRegistered_);
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(5, dataSourcesSeen_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(6, tracingSessions_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(7, totalBuffers_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(8, chunksDiscarded_);
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(9, patchesDiscarded_);
      }
      if (((bitField0_ & 0x00000100) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(10, invalidPackets_);
      }
      if (((bitField0_ & 0x00000200) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(11, getFilterStats());
      }
      if (((bitField0_ & 0x00000400) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(12, flushesRequested_);
      }
      if (((bitField0_ & 0x00000800) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(13, flushesSucceeded_);
      }
      if (((bitField0_ & 0x00001000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(14, flushesFailed_);
      }
      if (((bitField0_ & 0x00002000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(15, finalFlushOutcome_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof perfetto.protos.TraceStatsOuterClass.TraceStats)) {
        return super.equals(obj);
      }
      perfetto.protos.TraceStatsOuterClass.TraceStats other = (perfetto.protos.TraceStatsOuterClass.TraceStats) obj;

      if (!getBufferStatsList()
          .equals(other.getBufferStatsList())) return false;
      if (hasProducersConnected() != other.hasProducersConnected()) return false;
      if (hasProducersConnected()) {
        if (getProducersConnected()
            != other.getProducersConnected()) return false;
      }
      if (hasProducersSeen() != other.hasProducersSeen()) return false;
      if (hasProducersSeen()) {
        if (getProducersSeen()
            != other.getProducersSeen()) return false;
      }
      if (hasDataSourcesRegistered() != other.hasDataSourcesRegistered()) return false;
      if (hasDataSourcesRegistered()) {
        if (getDataSourcesRegistered()
            != other.getDataSourcesRegistered()) return false;
      }
      if (hasDataSourcesSeen() != other.hasDataSourcesSeen()) return false;
      if (hasDataSourcesSeen()) {
        if (getDataSourcesSeen()
            != other.getDataSourcesSeen()) return false;
      }
      if (hasTracingSessions() != other.hasTracingSessions()) return false;
      if (hasTracingSessions()) {
        if (getTracingSessions()
            != other.getTracingSessions()) return false;
      }
      if (hasTotalBuffers() != other.hasTotalBuffers()) return false;
      if (hasTotalBuffers()) {
        if (getTotalBuffers()
            != other.getTotalBuffers()) return false;
      }
      if (hasChunksDiscarded() != other.hasChunksDiscarded()) return false;
      if (hasChunksDiscarded()) {
        if (getChunksDiscarded()
            != other.getChunksDiscarded()) return false;
      }
      if (hasPatchesDiscarded() != other.hasPatchesDiscarded()) return false;
      if (hasPatchesDiscarded()) {
        if (getPatchesDiscarded()
            != other.getPatchesDiscarded()) return false;
      }
      if (hasInvalidPackets() != other.hasInvalidPackets()) return false;
      if (hasInvalidPackets()) {
        if (getInvalidPackets()
            != other.getInvalidPackets()) return false;
      }
      if (hasFilterStats() != other.hasFilterStats()) return false;
      if (hasFilterStats()) {
        if (!getFilterStats()
            .equals(other.getFilterStats())) return false;
      }
      if (hasFlushesRequested() != other.hasFlushesRequested()) return false;
      if (hasFlushesRequested()) {
        if (getFlushesRequested()
            != other.getFlushesRequested()) return false;
      }
      if (hasFlushesSucceeded() != other.hasFlushesSucceeded()) return false;
      if (hasFlushesSucceeded()) {
        if (getFlushesSucceeded()
            != other.getFlushesSucceeded()) return false;
      }
      if (hasFlushesFailed() != other.hasFlushesFailed()) return false;
      if (hasFlushesFailed()) {
        if (getFlushesFailed()
            != other.getFlushesFailed()) return false;
      }
      if (hasFinalFlushOutcome() != other.hasFinalFlushOutcome()) return false;
      if (hasFinalFlushOutcome()) {
        if (finalFlushOutcome_ != other.finalFlushOutcome_) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getBufferStatsCount() > 0) {
        hash = (37 * hash) + BUFFER_STATS_FIELD_NUMBER;
        hash = (53 * hash) + getBufferStatsList().hashCode();
      }
      if (hasProducersConnected()) {
        hash = (37 * hash) + PRODUCERS_CONNECTED_FIELD_NUMBER;
        hash = (53 * hash) + getProducersConnected();
      }
      if (hasProducersSeen()) {
        hash = (37 * hash) + PRODUCERS_SEEN_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getProducersSeen());
      }
      if (hasDataSourcesRegistered()) {
        hash = (37 * hash) + DATA_SOURCES_REGISTERED_FIELD_NUMBER;
        hash = (53 * hash) + getDataSourcesRegistered();
      }
      if (hasDataSourcesSeen()) {
        hash = (37 * hash) + DATA_SOURCES_SEEN_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getDataSourcesSeen());
      }
      if (hasTracingSessions()) {
        hash = (37 * hash) + TRACING_SESSIONS_FIELD_NUMBER;
        hash = (53 * hash) + getTracingSessions();
      }
      if (hasTotalBuffers()) {
        hash = (37 * hash) + TOTAL_BUFFERS_FIELD_NUMBER;
        hash = (53 * hash) + getTotalBuffers();
      }
      if (hasChunksDiscarded()) {
        hash = (37 * hash) + CHUNKS_DISCARDED_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getChunksDiscarded());
      }
      if (hasPatchesDiscarded()) {
        hash = (37 * hash) + PATCHES_DISCARDED_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getPatchesDiscarded());
      }
      if (hasInvalidPackets()) {
        hash = (37 * hash) + INVALID_PACKETS_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getInvalidPackets());
      }
      if (hasFilterStats()) {
        hash = (37 * hash) + FILTER_STATS_FIELD_NUMBER;
        hash = (53 * hash) + getFilterStats().hashCode();
      }
      if (hasFlushesRequested()) {
        hash = (37 * hash) + FLUSHES_REQUESTED_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getFlushesRequested());
      }
      if (hasFlushesSucceeded()) {
        hash = (37 * hash) + FLUSHES_SUCCEEDED_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getFlushesSucceeded());
      }
      if (hasFlushesFailed()) {
        hash = (37 * hash) + FLUSHES_FAILED_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getFlushesFailed());
      }
      if (hasFinalFlushOutcome()) {
        hash = (37 * hash) + FINAL_FLUSH_OUTCOME_FIELD_NUMBER;
        hash = (53 * hash) + finalFlushOutcome_;
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static perfetto.protos.TraceStatsOuterClass.TraceStats parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static perfetto.protos.TraceStatsOuterClass.TraceStats parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static perfetto.protos.TraceStatsOuterClass.TraceStats parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static perfetto.protos.TraceStatsOuterClass.TraceStats parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static perfetto.protos.TraceStatsOuterClass.TraceStats parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static perfetto.protos.TraceStatsOuterClass.TraceStats parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static perfetto.protos.TraceStatsOuterClass.TraceStats parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static perfetto.protos.TraceStatsOuterClass.TraceStats parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static perfetto.protos.TraceStatsOuterClass.TraceStats parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static perfetto.protos.TraceStatsOuterClass.TraceStats parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static perfetto.protos.TraceStatsOuterClass.TraceStats parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static perfetto.protos.TraceStatsOuterClass.TraceStats parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(perfetto.protos.TraceStatsOuterClass.TraceStats prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Statistics for the internals of the tracing service.
     * Next id: 16.
     * </pre>
     *
     * Protobuf type {@code perfetto.protos.TraceStats}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:perfetto.protos.TraceStats)
        perfetto.protos.TraceStatsOuterClass.TraceStatsOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return perfetto.protos.TraceStatsOuterClass.internal_static_perfetto_protos_TraceStats_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return perfetto.protos.TraceStatsOuterClass.internal_static_perfetto_protos_TraceStats_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                perfetto.protos.TraceStatsOuterClass.TraceStats.class, perfetto.protos.TraceStatsOuterClass.TraceStats.Builder.class);
      }

      // Construct using perfetto.protos.TraceStatsOuterClass.TraceStats.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getBufferStatsFieldBuilder();
          getFilterStatsFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        if (bufferStatsBuilder_ == null) {
          bufferStats_ = java.util.Collections.emptyList();
        } else {
          bufferStats_ = null;
          bufferStatsBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        producersConnected_ = 0;
        producersSeen_ = 0L;
        dataSourcesRegistered_ = 0;
        dataSourcesSeen_ = 0L;
        tracingSessions_ = 0;
        totalBuffers_ = 0;
        chunksDiscarded_ = 0L;
        patchesDiscarded_ = 0L;
        invalidPackets_ = 0L;
        filterStats_ = null;
        if (filterStatsBuilder_ != null) {
          filterStatsBuilder_.dispose();
          filterStatsBuilder_ = null;
        }
        flushesRequested_ = 0L;
        flushesSucceeded_ = 0L;
        flushesFailed_ = 0L;
        finalFlushOutcome_ = 0;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return perfetto.protos.TraceStatsOuterClass.internal_static_perfetto_protos_TraceStats_descriptor;
      }

      @java.lang.Override
      public perfetto.protos.TraceStatsOuterClass.TraceStats getDefaultInstanceForType() {
        return perfetto.protos.TraceStatsOuterClass.TraceStats.getDefaultInstance();
      }

      @java.lang.Override
      public perfetto.protos.TraceStatsOuterClass.TraceStats build() {
        perfetto.protos.TraceStatsOuterClass.TraceStats result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public perfetto.protos.TraceStatsOuterClass.TraceStats buildPartial() {
        perfetto.protos.TraceStatsOuterClass.TraceStats result = new perfetto.protos.TraceStatsOuterClass.TraceStats(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(perfetto.protos.TraceStatsOuterClass.TraceStats result) {
        if (bufferStatsBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0)) {
            bufferStats_ = java.util.Collections.unmodifiableList(bufferStats_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.bufferStats_ = bufferStats_;
        } else {
          result.bufferStats_ = bufferStatsBuilder_.build();
        }
      }

      private void buildPartial0(perfetto.protos.TraceStatsOuterClass.TraceStats result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.producersConnected_ = producersConnected_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.producersSeen_ = producersSeen_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.dataSourcesRegistered_ = dataSourcesRegistered_;
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.dataSourcesSeen_ = dataSourcesSeen_;
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          result.tracingSessions_ = tracingSessions_;
          to_bitField0_ |= 0x00000010;
        }
        if (((from_bitField0_ & 0x00000040) != 0)) {
          result.totalBuffers_ = totalBuffers_;
          to_bitField0_ |= 0x00000020;
        }
        if (((from_bitField0_ & 0x00000080) != 0)) {
          result.chunksDiscarded_ = chunksDiscarded_;
          to_bitField0_ |= 0x00000040;
        }
        if (((from_bitField0_ & 0x00000100) != 0)) {
          result.patchesDiscarded_ = patchesDiscarded_;
          to_bitField0_ |= 0x00000080;
        }
        if (((from_bitField0_ & 0x00000200) != 0)) {
          result.invalidPackets_ = invalidPackets_;
          to_bitField0_ |= 0x00000100;
        }
        if (((from_bitField0_ & 0x00000400) != 0)) {
          result.filterStats_ = filterStatsBuilder_ == null
              ? filterStats_
              : filterStatsBuilder_.build();
          to_bitField0_ |= 0x00000200;
        }
        if (((from_bitField0_ & 0x00000800) != 0)) {
          result.flushesRequested_ = flushesRequested_;
          to_bitField0_ |= 0x00000400;
        }
        if (((from_bitField0_ & 0x00001000) != 0)) {
          result.flushesSucceeded_ = flushesSucceeded_;
          to_bitField0_ |= 0x00000800;
        }
        if (((from_bitField0_ & 0x00002000) != 0)) {
          result.flushesFailed_ = flushesFailed_;
          to_bitField0_ |= 0x00001000;
        }
        if (((from_bitField0_ & 0x00004000) != 0)) {
          result.finalFlushOutcome_ = finalFlushOutcome_;
          to_bitField0_ |= 0x00002000;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof perfetto.protos.TraceStatsOuterClass.TraceStats) {
          return mergeFrom((perfetto.protos.TraceStatsOuterClass.TraceStats)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(perfetto.protos.TraceStatsOuterClass.TraceStats other) {
        if (other == perfetto.protos.TraceStatsOuterClass.TraceStats.getDefaultInstance()) return this;
        if (bufferStatsBuilder_ == null) {
          if (!other.bufferStats_.isEmpty()) {
            if (bufferStats_.isEmpty()) {
              bufferStats_ = other.bufferStats_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureBufferStatsIsMutable();
              bufferStats_.addAll(other.bufferStats_);
            }
            onChanged();
          }
        } else {
          if (!other.bufferStats_.isEmpty()) {
            if (bufferStatsBuilder_.isEmpty()) {
              bufferStatsBuilder_.dispose();
              bufferStatsBuilder_ = null;
              bufferStats_ = other.bufferStats_;
              bitField0_ = (bitField0_ & ~0x00000001);
              bufferStatsBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getBufferStatsFieldBuilder() : null;
            } else {
              bufferStatsBuilder_.addAllMessages(other.bufferStats_);
            }
          }
        }
        if (other.hasProducersConnected()) {
          setProducersConnected(other.getProducersConnected());
        }
        if (other.hasProducersSeen()) {
          setProducersSeen(other.getProducersSeen());
        }
        if (other.hasDataSourcesRegistered()) {
          setDataSourcesRegistered(other.getDataSourcesRegistered());
        }
        if (other.hasDataSourcesSeen()) {
          setDataSourcesSeen(other.getDataSourcesSeen());
        }
        if (other.hasTracingSessions()) {
          setTracingSessions(other.getTracingSessions());
        }
        if (other.hasTotalBuffers()) {
          setTotalBuffers(other.getTotalBuffers());
        }
        if (other.hasChunksDiscarded()) {
          setChunksDiscarded(other.getChunksDiscarded());
        }
        if (other.hasPatchesDiscarded()) {
          setPatchesDiscarded(other.getPatchesDiscarded());
        }
        if (other.hasInvalidPackets()) {
          setInvalidPackets(other.getInvalidPackets());
        }
        if (other.hasFilterStats()) {
          mergeFilterStats(other.getFilterStats());
        }
        if (other.hasFlushesRequested()) {
          setFlushesRequested(other.getFlushesRequested());
        }
        if (other.hasFlushesSucceeded()) {
          setFlushesSucceeded(other.getFlushesSucceeded());
        }
        if (other.hasFlushesFailed()) {
          setFlushesFailed(other.getFlushesFailed());
        }
        if (other.hasFinalFlushOutcome()) {
          setFinalFlushOutcome(other.getFinalFlushOutcome());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                perfetto.protos.TraceStatsOuterClass.TraceStats.BufferStats m =
                    input.readMessage(
                        perfetto.protos.TraceStatsOuterClass.TraceStats.BufferStats.PARSER,
                        extensionRegistry);
                if (bufferStatsBuilder_ == null) {
                  ensureBufferStatsIsMutable();
                  bufferStats_.add(m);
                } else {
                  bufferStatsBuilder_.addMessage(m);
                }
                break;
              } // case 10
              case 16: {
                producersConnected_ = input.readUInt32();
                bitField0_ |= 0x00000002;
                break;
              } // case 16
              case 24: {
                producersSeen_ = input.readUInt64();
                bitField0_ |= 0x00000004;
                break;
              } // case 24
              case 32: {
                dataSourcesRegistered_ = input.readUInt32();
                bitField0_ |= 0x00000008;
                break;
              } // case 32
              case 40: {
                dataSourcesSeen_ = input.readUInt64();
                bitField0_ |= 0x00000010;
                break;
              } // case 40
              case 48: {
                tracingSessions_ = input.readUInt32();
                bitField0_ |= 0x00000020;
                break;
              } // case 48
              case 56: {
                totalBuffers_ = input.readUInt32();
                bitField0_ |= 0x00000040;
                break;
              } // case 56
              case 64: {
                chunksDiscarded_ = input.readUInt64();
                bitField0_ |= 0x00000080;
                break;
              } // case 64
              case 72: {
                patchesDiscarded_ = input.readUInt64();
                bitField0_ |= 0x00000100;
                break;
              } // case 72
              case 80: {
                invalidPackets_ = input.readUInt64();
                bitField0_ |= 0x00000200;
                break;
              } // case 80
              case 90: {
                input.readMessage(
                    getFilterStatsFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000400;
                break;
              } // case 90
              case 96: {
                flushesRequested_ = input.readUInt64();
                bitField0_ |= 0x00000800;
                break;
              } // case 96
              case 104: {
                flushesSucceeded_ = input.readUInt64();
                bitField0_ |= 0x00001000;
                break;
              } // case 104
              case 112: {
                flushesFailed_ = input.readUInt64();
                bitField0_ |= 0x00002000;
                break;
              } // case 112
              case 120: {
                int tmpRaw = input.readEnum();
                perfetto.protos.TraceStatsOuterClass.TraceStats.FinalFlushOutcome tmpValue =
                    perfetto.protos.TraceStatsOuterClass.TraceStats.FinalFlushOutcome.forNumber(tmpRaw);
                if (tmpValue == null) {
                  mergeUnknownVarintField(15, tmpRaw);
                } else {
                  finalFlushOutcome_ = tmpRaw;
                  bitField0_ |= 0x00004000;
                }
                break;
              } // case 120
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.util.List<perfetto.protos.TraceStatsOuterClass.TraceStats.BufferStats> bufferStats_ =
        java.util.Collections.emptyList();
      private void ensureBufferStatsIsMutable() {
        if (!((bitField0_ & 0x00000001) != 0)) {
          bufferStats_ = new java.util.ArrayList<perfetto.protos.TraceStatsOuterClass.TraceStats.BufferStats>(bufferStats_);
          bitField0_ |= 0x00000001;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          perfetto.protos.TraceStatsOuterClass.TraceStats.BufferStats, perfetto.protos.TraceStatsOuterClass.TraceStats.BufferStats.Builder, perfetto.protos.TraceStatsOuterClass.TraceStats.BufferStatsOrBuilder> bufferStatsBuilder_;

      /**
       * <pre>
       * Stats for the TraceBuffer(s) of the current trace session.
       * </pre>
       *
       * <code>repeated .perfetto.protos.TraceStats.BufferStats buffer_stats = 1;</code>
       */
      public java.util.List<perfetto.protos.TraceStatsOuterClass.TraceStats.BufferStats> getBufferStatsList() {
        if (bufferStatsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(bufferStats_);
        } else {
          return bufferStatsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Stats for the TraceBuffer(s) of the current trace session.
       * </pre>
       *
       * <code>repeated .perfetto.protos.TraceStats.BufferStats buffer_stats = 1;</code>
       */
      public int getBufferStatsCount() {
        if (bufferStatsBuilder_ == null) {
          return bufferStats_.size();
        } else {
          return bufferStatsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Stats for the TraceBuffer(s) of the current trace session.
       * </pre>
       *
       * <code>repeated .perfetto.protos.TraceStats.BufferStats buffer_stats = 1;</code>
       */
      public perfetto.protos.TraceStatsOuterClass.TraceStats.BufferStats getBufferStats(int index) {
        if (bufferStatsBuilder_ == null) {
          return bufferStats_.get(index);
        } else {
          return bufferStatsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Stats for the TraceBuffer(s) of the current trace session.
       * </pre>
       *
       * <code>repeated .perfetto.protos.TraceStats.BufferStats buffer_stats = 1;</code>
       */
      public Builder setBufferStats(
          int index, perfetto.protos.TraceStatsOuterClass.TraceStats.BufferStats value) {
        if (bufferStatsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureBufferStatsIsMutable();
          bufferStats_.set(index, value);
          onChanged();
        } else {
          bufferStatsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Stats for the TraceBuffer(s) of the current trace session.
       * </pre>
       *
       * <code>repeated .perfetto.protos.TraceStats.BufferStats buffer_stats = 1;</code>
       */
      public Builder setBufferStats(
          int index, perfetto.protos.TraceStatsOuterClass.TraceStats.BufferStats.Builder builderForValue) {
        if (bufferStatsBuilder_ == null) {
          ensureBufferStatsIsMutable();
          bufferStats_.set(index, builderForValue.build());
          onChanged();
        } else {
          bufferStatsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Stats for the TraceBuffer(s) of the current trace session.
       * </pre>
       *
       * <code>repeated .perfetto.protos.TraceStats.BufferStats buffer_stats = 1;</code>
       */
      public Builder addBufferStats(perfetto.protos.TraceStatsOuterClass.TraceStats.BufferStats value) {
        if (bufferStatsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureBufferStatsIsMutable();
          bufferStats_.add(value);
          onChanged();
        } else {
          bufferStatsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Stats for the TraceBuffer(s) of the current trace session.
       * </pre>
       *
       * <code>repeated .perfetto.protos.TraceStats.BufferStats buffer_stats = 1;</code>
       */
      public Builder addBufferStats(
          int index, perfetto.protos.TraceStatsOuterClass.TraceStats.BufferStats value) {
        if (bufferStatsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureBufferStatsIsMutable();
          bufferStats_.add(index, value);
          onChanged();
        } else {
          bufferStatsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Stats for the TraceBuffer(s) of the current trace session.
       * </pre>
       *
       * <code>repeated .perfetto.protos.TraceStats.BufferStats buffer_stats = 1;</code>
       */
      public Builder addBufferStats(
          perfetto.protos.TraceStatsOuterClass.TraceStats.BufferStats.Builder builderForValue) {
        if (bufferStatsBuilder_ == null) {
          ensureBufferStatsIsMutable();
          bufferStats_.add(builderForValue.build());
          onChanged();
        } else {
          bufferStatsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Stats for the TraceBuffer(s) of the current trace session.
       * </pre>
       *
       * <code>repeated .perfetto.protos.TraceStats.BufferStats buffer_stats = 1;</code>
       */
      public Builder addBufferStats(
          int index, perfetto.protos.TraceStatsOuterClass.TraceStats.BufferStats.Builder builderForValue) {
        if (bufferStatsBuilder_ == null) {
          ensureBufferStatsIsMutable();
          bufferStats_.add(index, builderForValue.build());
          onChanged();
        } else {
          bufferStatsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Stats for the TraceBuffer(s) of the current trace session.
       * </pre>
       *
       * <code>repeated .perfetto.protos.TraceStats.BufferStats buffer_stats = 1;</code>
       */
      public Builder addAllBufferStats(
          java.lang.Iterable<? extends perfetto.protos.TraceStatsOuterClass.TraceStats.BufferStats> values) {
        if (bufferStatsBuilder_ == null) {
          ensureBufferStatsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, bufferStats_);
          onChanged();
        } else {
          bufferStatsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Stats for the TraceBuffer(s) of the current trace session.
       * </pre>
       *
       * <code>repeated .perfetto.protos.TraceStats.BufferStats buffer_stats = 1;</code>
       */
      public Builder clearBufferStats() {
        if (bufferStatsBuilder_ == null) {
          bufferStats_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          bufferStatsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Stats for the TraceBuffer(s) of the current trace session.
       * </pre>
       *
       * <code>repeated .perfetto.protos.TraceStats.BufferStats buffer_stats = 1;</code>
       */
      public Builder removeBufferStats(int index) {
        if (bufferStatsBuilder_ == null) {
          ensureBufferStatsIsMutable();
          bufferStats_.remove(index);
          onChanged();
        } else {
          bufferStatsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Stats for the TraceBuffer(s) of the current trace session.
       * </pre>
       *
       * <code>repeated .perfetto.protos.TraceStats.BufferStats buffer_stats = 1;</code>
       */
      public perfetto.protos.TraceStatsOuterClass.TraceStats.BufferStats.Builder getBufferStatsBuilder(
          int index) {
        return getBufferStatsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Stats for the TraceBuffer(s) of the current trace session.
       * </pre>
       *
       * <code>repeated .perfetto.protos.TraceStats.BufferStats buffer_stats = 1;</code>
       */
      public perfetto.protos.TraceStatsOuterClass.TraceStats.BufferStatsOrBuilder getBufferStatsOrBuilder(
          int index) {
        if (bufferStatsBuilder_ == null) {
          return bufferStats_.get(index);  } else {
          return bufferStatsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Stats for the TraceBuffer(s) of the current trace session.
       * </pre>
       *
       * <code>repeated .perfetto.protos.TraceStats.BufferStats buffer_stats = 1;</code>
       */
      public java.util.List<? extends perfetto.protos.TraceStatsOuterClass.TraceStats.BufferStatsOrBuilder> 
           getBufferStatsOrBuilderList() {
        if (bufferStatsBuilder_ != null) {
          return bufferStatsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(bufferStats_);
        }
      }
      /**
       * <pre>
       * Stats for the TraceBuffer(s) of the current trace session.
       * </pre>
       *
       * <code>repeated .perfetto.protos.TraceStats.BufferStats buffer_stats = 1;</code>
       */
      public perfetto.protos.TraceStatsOuterClass.TraceStats.BufferStats.Builder addBufferStatsBuilder() {
        return getBufferStatsFieldBuilder().addBuilder(
            perfetto.protos.TraceStatsOuterClass.TraceStats.BufferStats.getDefaultInstance());
      }
      /**
       * <pre>
       * Stats for the TraceBuffer(s) of the current trace session.
       * </pre>
       *
       * <code>repeated .perfetto.protos.TraceStats.BufferStats buffer_stats = 1;</code>
       */
      public perfetto.protos.TraceStatsOuterClass.TraceStats.BufferStats.Builder addBufferStatsBuilder(
          int index) {
        return getBufferStatsFieldBuilder().addBuilder(
            index, perfetto.protos.TraceStatsOuterClass.TraceStats.BufferStats.getDefaultInstance());
      }
      /**
       * <pre>
       * Stats for the TraceBuffer(s) of the current trace session.
       * </pre>
       *
       * <code>repeated .perfetto.protos.TraceStats.BufferStats buffer_stats = 1;</code>
       */
      public java.util.List<perfetto.protos.TraceStatsOuterClass.TraceStats.BufferStats.Builder> 
           getBufferStatsBuilderList() {
        return getBufferStatsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          perfetto.protos.TraceStatsOuterClass.TraceStats.BufferStats, perfetto.protos.TraceStatsOuterClass.TraceStats.BufferStats.Builder, perfetto.protos.TraceStatsOuterClass.TraceStats.BufferStatsOrBuilder> 
          getBufferStatsFieldBuilder() {
        if (bufferStatsBuilder_ == null) {
          bufferStatsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              perfetto.protos.TraceStatsOuterClass.TraceStats.BufferStats, perfetto.protos.TraceStatsOuterClass.TraceStats.BufferStats.Builder, perfetto.protos.TraceStatsOuterClass.TraceStats.BufferStatsOrBuilder>(
                  bufferStats_,
                  ((bitField0_ & 0x00000001) != 0),
                  getParentForChildren(),
                  isClean());
          bufferStats_ = null;
        }
        return bufferStatsBuilder_;
      }

      private int producersConnected_ ;
      /**
       * <pre>
       * Num. producers connected (whether they are involved in the current tracing
       * session or not).
       * </pre>
       *
       * <code>optional uint32 producers_connected = 2;</code>
       * @return Whether the producersConnected field is set.
       */
      @java.lang.Override
      public boolean hasProducersConnected() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * Num. producers connected (whether they are involved in the current tracing
       * session or not).
       * </pre>
       *
       * <code>optional uint32 producers_connected = 2;</code>
       * @return The producersConnected.
       */
      @java.lang.Override
      public int getProducersConnected() {
        return producersConnected_;
      }
      /**
       * <pre>
       * Num. producers connected (whether they are involved in the current tracing
       * session or not).
       * </pre>
       *
       * <code>optional uint32 producers_connected = 2;</code>
       * @param value The producersConnected to set.
       * @return This builder for chaining.
       */
      public Builder setProducersConnected(int value) {
        
        producersConnected_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Num. producers connected (whether they are involved in the current tracing
       * session or not).
       * </pre>
       *
       * <code>optional uint32 producers_connected = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearProducersConnected() {
        bitField0_ = (bitField0_ & ~0x00000002);
        producersConnected_ = 0;
        onChanged();
        return this;
      }

      private long producersSeen_ ;
      /**
       * <pre>
       * Num. producers ever seen for all trace sessions since startup (it's a good
       * proxy for inferring num. producers crashed / killed).
       * </pre>
       *
       * <code>optional uint64 producers_seen = 3;</code>
       * @return Whether the producersSeen field is set.
       */
      @java.lang.Override
      public boolean hasProducersSeen() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * Num. producers ever seen for all trace sessions since startup (it's a good
       * proxy for inferring num. producers crashed / killed).
       * </pre>
       *
       * <code>optional uint64 producers_seen = 3;</code>
       * @return The producersSeen.
       */
      @java.lang.Override
      public long getProducersSeen() {
        return producersSeen_;
      }
      /**
       * <pre>
       * Num. producers ever seen for all trace sessions since startup (it's a good
       * proxy for inferring num. producers crashed / killed).
       * </pre>
       *
       * <code>optional uint64 producers_seen = 3;</code>
       * @param value The producersSeen to set.
       * @return This builder for chaining.
       */
      public Builder setProducersSeen(long value) {
        
        producersSeen_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Num. producers ever seen for all trace sessions since startup (it's a good
       * proxy for inferring num. producers crashed / killed).
       * </pre>
       *
       * <code>optional uint64 producers_seen = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearProducersSeen() {
        bitField0_ = (bitField0_ & ~0x00000004);
        producersSeen_ = 0L;
        onChanged();
        return this;
      }

      private int dataSourcesRegistered_ ;
      /**
       * <pre>
       * Num. data sources registered for all trace sessions.
       * </pre>
       *
       * <code>optional uint32 data_sources_registered = 4;</code>
       * @return Whether the dataSourcesRegistered field is set.
       */
      @java.lang.Override
      public boolean hasDataSourcesRegistered() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * Num. data sources registered for all trace sessions.
       * </pre>
       *
       * <code>optional uint32 data_sources_registered = 4;</code>
       * @return The dataSourcesRegistered.
       */
      @java.lang.Override
      public int getDataSourcesRegistered() {
        return dataSourcesRegistered_;
      }
      /**
       * <pre>
       * Num. data sources registered for all trace sessions.
       * </pre>
       *
       * <code>optional uint32 data_sources_registered = 4;</code>
       * @param value The dataSourcesRegistered to set.
       * @return This builder for chaining.
       */
      public Builder setDataSourcesRegistered(int value) {
        
        dataSourcesRegistered_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Num. data sources registered for all trace sessions.
       * </pre>
       *
       * <code>optional uint32 data_sources_registered = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearDataSourcesRegistered() {
        bitField0_ = (bitField0_ & ~0x00000008);
        dataSourcesRegistered_ = 0;
        onChanged();
        return this;
      }

      private long dataSourcesSeen_ ;
      /**
       * <pre>
       * Num. data sources ever seen for all trace sessions since startup.
       * </pre>
       *
       * <code>optional uint64 data_sources_seen = 5;</code>
       * @return Whether the dataSourcesSeen field is set.
       */
      @java.lang.Override
      public boolean hasDataSourcesSeen() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * Num. data sources ever seen for all trace sessions since startup.
       * </pre>
       *
       * <code>optional uint64 data_sources_seen = 5;</code>
       * @return The dataSourcesSeen.
       */
      @java.lang.Override
      public long getDataSourcesSeen() {
        return dataSourcesSeen_;
      }
      /**
       * <pre>
       * Num. data sources ever seen for all trace sessions since startup.
       * </pre>
       *
       * <code>optional uint64 data_sources_seen = 5;</code>
       * @param value The dataSourcesSeen to set.
       * @return This builder for chaining.
       */
      public Builder setDataSourcesSeen(long value) {
        
        dataSourcesSeen_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Num. data sources ever seen for all trace sessions since startup.
       * </pre>
       *
       * <code>optional uint64 data_sources_seen = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearDataSourcesSeen() {
        bitField0_ = (bitField0_ & ~0x00000010);
        dataSourcesSeen_ = 0L;
        onChanged();
        return this;
      }

      private int tracingSessions_ ;
      /**
       * <pre>
       * Num. concurrently active tracing sessions.
       * </pre>
       *
       * <code>optional uint32 tracing_sessions = 6;</code>
       * @return Whether the tracingSessions field is set.
       */
      @java.lang.Override
      public boolean hasTracingSessions() {
        return ((bitField0_ & 0x00000020) != 0);
      }
      /**
       * <pre>
       * Num. concurrently active tracing sessions.
       * </pre>
       *
       * <code>optional uint32 tracing_sessions = 6;</code>
       * @return The tracingSessions.
       */
      @java.lang.Override
      public int getTracingSessions() {
        return tracingSessions_;
      }
      /**
       * <pre>
       * Num. concurrently active tracing sessions.
       * </pre>
       *
       * <code>optional uint32 tracing_sessions = 6;</code>
       * @param value The tracingSessions to set.
       * @return This builder for chaining.
       */
      public Builder setTracingSessions(int value) {
        
        tracingSessions_ = value;
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Num. concurrently active tracing sessions.
       * </pre>
       *
       * <code>optional uint32 tracing_sessions = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearTracingSessions() {
        bitField0_ = (bitField0_ & ~0x00000020);
        tracingSessions_ = 0;
        onChanged();
        return this;
      }

      private int totalBuffers_ ;
      /**
       * <pre>
       * Num. buffers for all tracing session (not just the current one). This will
       * be &gt;= buffer_stats.size(), because the latter is only about the current
       * session.
       * </pre>
       *
       * <code>optional uint32 total_buffers = 7;</code>
       * @return Whether the totalBuffers field is set.
       */
      @java.lang.Override
      public boolean hasTotalBuffers() {
        return ((bitField0_ & 0x00000040) != 0);
      }
      /**
       * <pre>
       * Num. buffers for all tracing session (not just the current one). This will
       * be &gt;= buffer_stats.size(), because the latter is only about the current
       * session.
       * </pre>
       *
       * <code>optional uint32 total_buffers = 7;</code>
       * @return The totalBuffers.
       */
      @java.lang.Override
      public int getTotalBuffers() {
        return totalBuffers_;
      }
      /**
       * <pre>
       * Num. buffers for all tracing session (not just the current one). This will
       * be &gt;= buffer_stats.size(), because the latter is only about the current
       * session.
       * </pre>
       *
       * <code>optional uint32 total_buffers = 7;</code>
       * @param value The totalBuffers to set.
       * @return This builder for chaining.
       */
      public Builder setTotalBuffers(int value) {
        
        totalBuffers_ = value;
        bitField0_ |= 0x00000040;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Num. buffers for all tracing session (not just the current one). This will
       * be &gt;= buffer_stats.size(), because the latter is only about the current
       * session.
       * </pre>
       *
       * <code>optional uint32 total_buffers = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearTotalBuffers() {
        bitField0_ = (bitField0_ & ~0x00000040);
        totalBuffers_ = 0;
        onChanged();
        return this;
      }

      private long chunksDiscarded_ ;
      /**
       * <pre>
       * Num. chunks that were discarded by the service before attempting to commit
       * them to a buffer, e.g. because the producer specified an invalid buffer ID.
       * </pre>
       *
       * <code>optional uint64 chunks_discarded = 8;</code>
       * @return Whether the chunksDiscarded field is set.
       */
      @java.lang.Override
      public boolean hasChunksDiscarded() {
        return ((bitField0_ & 0x00000080) != 0);
      }
      /**
       * <pre>
       * Num. chunks that were discarded by the service before attempting to commit
       * them to a buffer, e.g. because the producer specified an invalid buffer ID.
       * </pre>
       *
       * <code>optional uint64 chunks_discarded = 8;</code>
       * @return The chunksDiscarded.
       */
      @java.lang.Override
      public long getChunksDiscarded() {
        return chunksDiscarded_;
      }
      /**
       * <pre>
       * Num. chunks that were discarded by the service before attempting to commit
       * them to a buffer, e.g. because the producer specified an invalid buffer ID.
       * </pre>
       *
       * <code>optional uint64 chunks_discarded = 8;</code>
       * @param value The chunksDiscarded to set.
       * @return This builder for chaining.
       */
      public Builder setChunksDiscarded(long value) {
        
        chunksDiscarded_ = value;
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Num. chunks that were discarded by the service before attempting to commit
       * them to a buffer, e.g. because the producer specified an invalid buffer ID.
       * </pre>
       *
       * <code>optional uint64 chunks_discarded = 8;</code>
       * @return This builder for chaining.
       */
      public Builder clearChunksDiscarded() {
        bitField0_ = (bitField0_ & ~0x00000080);
        chunksDiscarded_ = 0L;
        onChanged();
        return this;
      }

      private long patchesDiscarded_ ;
      /**
       * <pre>
       * Num. patches that were discarded by the service before attempting to apply
       * them to a buffer, e.g. because the producer specified an invalid buffer ID.
       * </pre>
       *
       * <code>optional uint64 patches_discarded = 9;</code>
       * @return Whether the patchesDiscarded field is set.
       */
      @java.lang.Override
      public boolean hasPatchesDiscarded() {
        return ((bitField0_ & 0x00000100) != 0);
      }
      /**
       * <pre>
       * Num. patches that were discarded by the service before attempting to apply
       * them to a buffer, e.g. because the producer specified an invalid buffer ID.
       * </pre>
       *
       * <code>optional uint64 patches_discarded = 9;</code>
       * @return The patchesDiscarded.
       */
      @java.lang.Override
      public long getPatchesDiscarded() {
        return patchesDiscarded_;
      }
      /**
       * <pre>
       * Num. patches that were discarded by the service before attempting to apply
       * them to a buffer, e.g. because the producer specified an invalid buffer ID.
       * </pre>
       *
       * <code>optional uint64 patches_discarded = 9;</code>
       * @param value The patchesDiscarded to set.
       * @return This builder for chaining.
       */
      public Builder setPatchesDiscarded(long value) {
        
        patchesDiscarded_ = value;
        bitField0_ |= 0x00000100;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Num. patches that were discarded by the service before attempting to apply
       * them to a buffer, e.g. because the producer specified an invalid buffer ID.
       * </pre>
       *
       * <code>optional uint64 patches_discarded = 9;</code>
       * @return This builder for chaining.
       */
      public Builder clearPatchesDiscarded() {
        bitField0_ = (bitField0_ & ~0x00000100);
        patchesDiscarded_ = 0L;
        onChanged();
        return this;
      }

      private long invalidPackets_ ;
      /**
       * <pre>
       * Packets that failed validation of the TrustedPacket. If this is &gt; 0, there
       * is a bug in the producer.
       * </pre>
       *
       * <code>optional uint64 invalid_packets = 10;</code>
       * @return Whether the invalidPackets field is set.
       */
      @java.lang.Override
      public boolean hasInvalidPackets() {
        return ((bitField0_ & 0x00000200) != 0);
      }
      /**
       * <pre>
       * Packets that failed validation of the TrustedPacket. If this is &gt; 0, there
       * is a bug in the producer.
       * </pre>
       *
       * <code>optional uint64 invalid_packets = 10;</code>
       * @return The invalidPackets.
       */
      @java.lang.Override
      public long getInvalidPackets() {
        return invalidPackets_;
      }
      /**
       * <pre>
       * Packets that failed validation of the TrustedPacket. If this is &gt; 0, there
       * is a bug in the producer.
       * </pre>
       *
       * <code>optional uint64 invalid_packets = 10;</code>
       * @param value The invalidPackets to set.
       * @return This builder for chaining.
       */
      public Builder setInvalidPackets(long value) {
        
        invalidPackets_ = value;
        bitField0_ |= 0x00000200;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Packets that failed validation of the TrustedPacket. If this is &gt; 0, there
       * is a bug in the producer.
       * </pre>
       *
       * <code>optional uint64 invalid_packets = 10;</code>
       * @return This builder for chaining.
       */
      public Builder clearInvalidPackets() {
        bitField0_ = (bitField0_ & ~0x00000200);
        invalidPackets_ = 0L;
        onChanged();
        return this;
      }

      private perfetto.protos.TraceStatsOuterClass.TraceStats.FilterStats filterStats_;
      private com.google.protobuf.SingleFieldBuilderV3<
          perfetto.protos.TraceStatsOuterClass.TraceStats.FilterStats, perfetto.protos.TraceStatsOuterClass.TraceStats.FilterStats.Builder, perfetto.protos.TraceStatsOuterClass.TraceStats.FilterStatsOrBuilder> filterStatsBuilder_;
      /**
       * <code>optional .perfetto.protos.TraceStats.FilterStats filter_stats = 11;</code>
       * @return Whether the filterStats field is set.
       */
      public boolean hasFilterStats() {
        return ((bitField0_ & 0x00000400) != 0);
      }
      /**
       * <code>optional .perfetto.protos.TraceStats.FilterStats filter_stats = 11;</code>
       * @return The filterStats.
       */
      public perfetto.protos.TraceStatsOuterClass.TraceStats.FilterStats getFilterStats() {
        if (filterStatsBuilder_ == null) {
          return filterStats_ == null ? perfetto.protos.TraceStatsOuterClass.TraceStats.FilterStats.getDefaultInstance() : filterStats_;
        } else {
          return filterStatsBuilder_.getMessage();
        }
      }
      /**
       * <code>optional .perfetto.protos.TraceStats.FilterStats filter_stats = 11;</code>
       */
      public Builder setFilterStats(perfetto.protos.TraceStatsOuterClass.TraceStats.FilterStats value) {
        if (filterStatsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          filterStats_ = value;
        } else {
          filterStatsBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000400;
        onChanged();
        return this;
      }
      /**
       * <code>optional .perfetto.protos.TraceStats.FilterStats filter_stats = 11;</code>
       */
      public Builder setFilterStats(
          perfetto.protos.TraceStatsOuterClass.TraceStats.FilterStats.Builder builderForValue) {
        if (filterStatsBuilder_ == null) {
          filterStats_ = builderForValue.build();
        } else {
          filterStatsBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000400;
        onChanged();
        return this;
      }
      /**
       * <code>optional .perfetto.protos.TraceStats.FilterStats filter_stats = 11;</code>
       */
      public Builder mergeFilterStats(perfetto.protos.TraceStatsOuterClass.TraceStats.FilterStats value) {
        if (filterStatsBuilder_ == null) {
          if (((bitField0_ & 0x00000400) != 0) &&
            filterStats_ != null &&
            filterStats_ != perfetto.protos.TraceStatsOuterClass.TraceStats.FilterStats.getDefaultInstance()) {
            getFilterStatsBuilder().mergeFrom(value);
          } else {
            filterStats_ = value;
          }
        } else {
          filterStatsBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000400;
        onChanged();
        return this;
      }
      /**
       * <code>optional .perfetto.protos.TraceStats.FilterStats filter_stats = 11;</code>
       */
      public Builder clearFilterStats() {
        bitField0_ = (bitField0_ & ~0x00000400);
        filterStats_ = null;
        if (filterStatsBuilder_ != null) {
          filterStatsBuilder_.dispose();
          filterStatsBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <code>optional .perfetto.protos.TraceStats.FilterStats filter_stats = 11;</code>
       */
      public perfetto.protos.TraceStatsOuterClass.TraceStats.FilterStats.Builder getFilterStatsBuilder() {
        bitField0_ |= 0x00000400;
        onChanged();
        return getFilterStatsFieldBuilder().getBuilder();
      }
      /**
       * <code>optional .perfetto.protos.TraceStats.FilterStats filter_stats = 11;</code>
       */
      public perfetto.protos.TraceStatsOuterClass.TraceStats.FilterStatsOrBuilder getFilterStatsOrBuilder() {
        if (filterStatsBuilder_ != null) {
          return filterStatsBuilder_.getMessageOrBuilder();
        } else {
          return filterStats_ == null ?
              perfetto.protos.TraceStatsOuterClass.TraceStats.FilterStats.getDefaultInstance() : filterStats_;
        }
      }
      /**
       * <code>optional .perfetto.protos.TraceStats.FilterStats filter_stats = 11;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          perfetto.protos.TraceStatsOuterClass.TraceStats.FilterStats, perfetto.protos.TraceStatsOuterClass.TraceStats.FilterStats.Builder, perfetto.protos.TraceStatsOuterClass.TraceStats.FilterStatsOrBuilder> 
          getFilterStatsFieldBuilder() {
        if (filterStatsBuilder_ == null) {
          filterStatsBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              perfetto.protos.TraceStatsOuterClass.TraceStats.FilterStats, perfetto.protos.TraceStatsOuterClass.TraceStats.FilterStats.Builder, perfetto.protos.TraceStatsOuterClass.TraceStats.FilterStatsOrBuilder>(
                  getFilterStats(),
                  getParentForChildren(),
                  isClean());
          filterStats_ = null;
        }
        return filterStatsBuilder_;
      }

      private long flushesRequested_ ;
      /**
       * <pre>
       * Count of Flush() requests (either from the Consumer, or self-induced
       * periodic flushes). The final Flush() is also included in the count.
       * </pre>
       *
       * <code>optional uint64 flushes_requested = 12;</code>
       * @return Whether the flushesRequested field is set.
       */
      @java.lang.Override
      public boolean hasFlushesRequested() {
        return ((bitField0_ & 0x00000800) != 0);
      }
      /**
       * <pre>
       * Count of Flush() requests (either from the Consumer, or self-induced
       * periodic flushes). The final Flush() is also included in the count.
       * </pre>
       *
       * <code>optional uint64 flushes_requested = 12;</code>
       * @return The flushesRequested.
       */
      @java.lang.Override
      public long getFlushesRequested() {
        return flushesRequested_;
      }
      /**
       * <pre>
       * Count of Flush() requests (either from the Consumer, or self-induced
       * periodic flushes). The final Flush() is also included in the count.
       * </pre>
       *
       * <code>optional uint64 flushes_requested = 12;</code>
       * @param value The flushesRequested to set.
       * @return This builder for chaining.
       */
      public Builder setFlushesRequested(long value) {
        
        flushesRequested_ = value;
        bitField0_ |= 0x00000800;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Count of Flush() requests (either from the Consumer, or self-induced
       * periodic flushes). The final Flush() is also included in the count.
       * </pre>
       *
       * <code>optional uint64 flushes_requested = 12;</code>
       * @return This builder for chaining.
       */
      public Builder clearFlushesRequested() {
        bitField0_ = (bitField0_ & ~0x00000800);
        flushesRequested_ = 0L;
        onChanged();
        return this;
      }

      private long flushesSucceeded_ ;
      /**
       * <pre>
       * The count of the Flush() requests that were completed successfully.
       * In a well behaving trace this should always be == `flush_requests`.
       * </pre>
       *
       * <code>optional uint64 flushes_succeeded = 13;</code>
       * @return Whether the flushesSucceeded field is set.
       */
      @java.lang.Override
      public boolean hasFlushesSucceeded() {
        return ((bitField0_ & 0x00001000) != 0);
      }
      /**
       * <pre>
       * The count of the Flush() requests that were completed successfully.
       * In a well behaving trace this should always be == `flush_requests`.
       * </pre>
       *
       * <code>optional uint64 flushes_succeeded = 13;</code>
       * @return The flushesSucceeded.
       */
      @java.lang.Override
      public long getFlushesSucceeded() {
        return flushesSucceeded_;
      }
      /**
       * <pre>
       * The count of the Flush() requests that were completed successfully.
       * In a well behaving trace this should always be == `flush_requests`.
       * </pre>
       *
       * <code>optional uint64 flushes_succeeded = 13;</code>
       * @param value The flushesSucceeded to set.
       * @return This builder for chaining.
       */
      public Builder setFlushesSucceeded(long value) {
        
        flushesSucceeded_ = value;
        bitField0_ |= 0x00001000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The count of the Flush() requests that were completed successfully.
       * In a well behaving trace this should always be == `flush_requests`.
       * </pre>
       *
       * <code>optional uint64 flushes_succeeded = 13;</code>
       * @return This builder for chaining.
       */
      public Builder clearFlushesSucceeded() {
        bitField0_ = (bitField0_ & ~0x00001000);
        flushesSucceeded_ = 0L;
        onChanged();
        return this;
      }

      private long flushesFailed_ ;
      /**
       * <pre>
       * The count of the Flush() requests that failed (in most timed out).
       * In a well behaving trace this should always be == 0.
       * </pre>
       *
       * <code>optional uint64 flushes_failed = 14;</code>
       * @return Whether the flushesFailed field is set.
       */
      @java.lang.Override
      public boolean hasFlushesFailed() {
        return ((bitField0_ & 0x00002000) != 0);
      }
      /**
       * <pre>
       * The count of the Flush() requests that failed (in most timed out).
       * In a well behaving trace this should always be == 0.
       * </pre>
       *
       * <code>optional uint64 flushes_failed = 14;</code>
       * @return The flushesFailed.
       */
      @java.lang.Override
      public long getFlushesFailed() {
        return flushesFailed_;
      }
      /**
       * <pre>
       * The count of the Flush() requests that failed (in most timed out).
       * In a well behaving trace this should always be == 0.
       * </pre>
       *
       * <code>optional uint64 flushes_failed = 14;</code>
       * @param value The flushesFailed to set.
       * @return This builder for chaining.
       */
      public Builder setFlushesFailed(long value) {
        
        flushesFailed_ = value;
        bitField0_ |= 0x00002000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The count of the Flush() requests that failed (in most timed out).
       * In a well behaving trace this should always be == 0.
       * </pre>
       *
       * <code>optional uint64 flushes_failed = 14;</code>
       * @return This builder for chaining.
       */
      public Builder clearFlushesFailed() {
        bitField0_ = (bitField0_ & ~0x00002000);
        flushesFailed_ = 0L;
        onChanged();
        return this;
      }

      private int finalFlushOutcome_ = 0;
      /**
       * <code>optional .perfetto.protos.TraceStats.FinalFlushOutcome final_flush_outcome = 15;</code>
       * @return Whether the finalFlushOutcome field is set.
       */
      @java.lang.Override public boolean hasFinalFlushOutcome() {
        return ((bitField0_ & 0x00004000) != 0);
      }
      /**
       * <code>optional .perfetto.protos.TraceStats.FinalFlushOutcome final_flush_outcome = 15;</code>
       * @return The finalFlushOutcome.
       */
      @java.lang.Override
      public perfetto.protos.TraceStatsOuterClass.TraceStats.FinalFlushOutcome getFinalFlushOutcome() {
        perfetto.protos.TraceStatsOuterClass.TraceStats.FinalFlushOutcome result = perfetto.protos.TraceStatsOuterClass.TraceStats.FinalFlushOutcome.forNumber(finalFlushOutcome_);
        return result == null ? perfetto.protos.TraceStatsOuterClass.TraceStats.FinalFlushOutcome.FINAL_FLUSH_UNSPECIFIED : result;
      }
      /**
       * <code>optional .perfetto.protos.TraceStats.FinalFlushOutcome final_flush_outcome = 15;</code>
       * @param value The finalFlushOutcome to set.
       * @return This builder for chaining.
       */
      public Builder setFinalFlushOutcome(perfetto.protos.TraceStatsOuterClass.TraceStats.FinalFlushOutcome value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00004000;
        finalFlushOutcome_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <code>optional .perfetto.protos.TraceStats.FinalFlushOutcome final_flush_outcome = 15;</code>
       * @return This builder for chaining.
       */
      public Builder clearFinalFlushOutcome() {
        bitField0_ = (bitField0_ & ~0x00004000);
        finalFlushOutcome_ = 0;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:perfetto.protos.TraceStats)
    }

    // @@protoc_insertion_point(class_scope:perfetto.protos.TraceStats)
    private static final perfetto.protos.TraceStatsOuterClass.TraceStats DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new perfetto.protos.TraceStatsOuterClass.TraceStats();
    }

    public static perfetto.protos.TraceStatsOuterClass.TraceStats getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<TraceStats>
        PARSER = new com.google.protobuf.AbstractParser<TraceStats>() {
      @java.lang.Override
      public TraceStats parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<TraceStats> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<TraceStats> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public perfetto.protos.TraceStatsOuterClass.TraceStats getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_perfetto_protos_TraceStats_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_perfetto_protos_TraceStats_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_perfetto_protos_TraceStats_BufferStats_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_perfetto_protos_TraceStats_BufferStats_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_perfetto_protos_TraceStats_FilterStats_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_perfetto_protos_TraceStats_FilterStats_fieldAccessorTable;

  public static com.google.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
    return descriptor;
  }
  private static  com.google.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
    java.lang.String[] descriptorData = {
      "\n(protos/perfetto/common/trace_stats.pro" +
      "to\022\017perfetto.protos\"\347\t\n\nTraceStats\022=\n\014bu" +
      "ffer_stats\030\001 \003(\0132\'.perfetto.protos.Trace" +
      "Stats.BufferStats\022\033\n\023producers_connected" +
      "\030\002 \001(\r\022\026\n\016producers_seen\030\003 \001(\004\022\037\n\027data_s" +
      "ources_registered\030\004 \001(\r\022\031\n\021data_sources_" +
      "seen\030\005 \001(\004\022\030\n\020tracing_sessions\030\006 \001(\r\022\025\n\r" +
      "total_buffers\030\007 \001(\r\022\030\n\020chunks_discarded\030" +
      "\010 \001(\004\022\031\n\021patches_discarded\030\t \001(\004\022\027\n\017inva" +
      "lid_packets\030\n \001(\004\022=\n\014filter_stats\030\013 \001(\0132" +
      "\'.perfetto.protos.TraceStats.FilterStats" +
      "\022\031\n\021flushes_requested\030\014 \001(\004\022\031\n\021flushes_s" +
      "ucceeded\030\r \001(\004\022\026\n\016flushes_failed\030\016 \001(\004\022J" +
      "\n\023final_flush_outcome\030\017 \001(\0162-.perfetto.p" +
      "rotos.TraceStats.FinalFlushOutcome\032\212\004\n\013B" +
      "ufferStats\022\023\n\013buffer_size\030\014 \001(\004\022\025\n\rbytes" +
      "_written\030\001 \001(\004\022\031\n\021bytes_overwritten\030\r \001(" +
      "\004\022\022\n\nbytes_read\030\016 \001(\004\022\035\n\025padding_bytes_w" +
      "ritten\030\017 \001(\004\022\035\n\025padding_bytes_cleared\030\020 " +
      "\001(\004\022\026\n\016chunks_written\030\002 \001(\004\022\030\n\020chunks_re" +
      "written\030\n \001(\004\022\032\n\022chunks_overwritten\030\003 \001(" +
      "\004\022\030\n\020chunks_discarded\030\022 \001(\004\022\023\n\013chunks_re" +
      "ad\030\021 \001(\004\022%\n\035chunks_committed_out_of_orde" +
      "r\030\013 \001(\004\022\030\n\020write_wrap_count\030\004 \001(\004\022\031\n\021pat" +
      "ches_succeeded\030\005 \001(\004\022\026\n\016patches_failed\030\006" +
      " \001(\004\022\034\n\024readaheads_succeeded\030\007 \001(\004\022\031\n\021re" +
      "adaheads_failed\030\010 \001(\004\022\026\n\016abi_violations\030" +
      "\t \001(\004\022 \n\030trace_writer_packet_loss\030\023 \001(\004\032" +
      "_\n\013FilterStats\022\025\n\rinput_packets\030\001 \001(\004\022\023\n" +
      "\013input_bytes\030\002 \001(\004\022\024\n\014output_bytes\030\003 \001(\004" +
      "\022\016\n\006errors\030\004 \001(\004\"c\n\021FinalFlushOutcome\022\033\n" +
      "\027FINAL_FLUSH_UNSPECIFIED\020\000\022\031\n\025FINAL_FLUS" +
      "H_SUCCEEDED\020\001\022\026\n\022FINAL_FLUSH_FAILED\020\002"
    };
    descriptor = com.google.protobuf.Descriptors.FileDescriptor
      .internalBuildGeneratedFileFrom(descriptorData,
        new com.google.protobuf.Descriptors.FileDescriptor[] {
        });
    internal_static_perfetto_protos_TraceStats_descriptor =
      getDescriptor().getMessageTypes().get(0);
    internal_static_perfetto_protos_TraceStats_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_perfetto_protos_TraceStats_descriptor,
        new java.lang.String[] { "BufferStats", "ProducersConnected", "ProducersSeen", "DataSourcesRegistered", "DataSourcesSeen", "TracingSessions", "TotalBuffers", "ChunksDiscarded", "PatchesDiscarded", "InvalidPackets", "FilterStats", "FlushesRequested", "FlushesSucceeded", "FlushesFailed", "FinalFlushOutcome", });
    internal_static_perfetto_protos_TraceStats_BufferStats_descriptor =
      internal_static_perfetto_protos_TraceStats_descriptor.getNestedTypes().get(0);
    internal_static_perfetto_protos_TraceStats_BufferStats_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_perfetto_protos_TraceStats_BufferStats_descriptor,
        new java.lang.String[] { "BufferSize", "BytesWritten", "BytesOverwritten", "BytesRead", "PaddingBytesWritten", "PaddingBytesCleared", "ChunksWritten", "ChunksRewritten", "ChunksOverwritten", "ChunksDiscarded", "ChunksRead", "ChunksCommittedOutOfOrder", "WriteWrapCount", "PatchesSucceeded", "PatchesFailed", "ReadaheadsSucceeded", "ReadaheadsFailed", "AbiViolations", "TraceWriterPacketLoss", });
    internal_static_perfetto_protos_TraceStats_FilterStats_descriptor =
      internal_static_perfetto_protos_TraceStats_descriptor.getNestedTypes().get(1);
    internal_static_perfetto_protos_TraceStats_FilterStats_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_perfetto_protos_TraceStats_FilterStats_descriptor,
        new java.lang.String[] { "InputPackets", "InputBytes", "OutputBytes", "Errors", });
  }

  // @@protoc_insertion_point(outer_class_scope)
}
